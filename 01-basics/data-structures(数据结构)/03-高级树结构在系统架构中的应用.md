# 高级树结构在系统架构中的应用

## 概述

树结构是计算机科学中最重要和常用的数据结构之一，在系统架构中有着广泛的应用。从数据库索引到文件系统，从组织架构到配置管理，树结构都发挥着重要作用。本文档将深入探讨各种树结构在系统架构中的具体应用场景和实现方案。

## 二叉搜索树（BST）及其变种

### 平衡二叉搜索树 - 内存索引系统

```python
import threading
from typing import Optional, List, Dict
import time

class AVLTreeNode:
    """AVL树节点"""
    
    def __init__(self, key: str, value: any):
        self.key = key
        self.value = value
        self.left: Optional['AVLTreeNode'] = None
        self.right: Optional['AVLTreeNode'] = None
        self.height = 1
        self.count = 1  # 重复key的计数
        self.lock = threading.RLock()  # 线程安全

class AVLTree:
    """AVL树实现 - 用于内存索引系统"""
    
    def __init__(self):
        self.root: Optional[AVLTreeNode] = None
        self.lock = threading.RLock()
    
    def _height(self, node: Optional[AVLTreeNode]) -> int:
        """获取节点高度"""
        return node.height if node else 0
    
    def _balance_factor(self, node: Optional[AVLTreeNode]) -> int:
        """获取平衡因子"""
        return self._height(node.left) - self._height(node.right) if node else 0
    
    def _update_height(self, node: AVLTreeNode):
        """更新节点高度"""
        node.height = 1 + max(self._height(node.left), self._height(node.right))
    
    def _rotate_right(self, y: AVLTreeNode) -> AVLTreeNode:
        """右旋"""
        x = y.left
        y.left = x.right
        x.right = y
        self._update_height(y)
        self._update_height(x)
        return x
    
    def _rotate_left(self, x: AVLTreeNode) -> AVLTreeNode:
        """左旋"""
        y = x.right
        x.right = y.left
        y.left = x
        self._update_height(x)
        self._update_height(y)
        return y
    
    def _insert_node(self, node: Optional[AVLTreeNode], key: str, value: any) -> AVLTreeNode:
        """插入节点"""
        if not node:
            return AVLTreeNode(key, value)
        
        with node.lock:
            if key < node.key:
                node.left = self._insert_node(node.left, key, value)
            elif key > node.key:
                node.right = self._insert_node(node.right, key, value)
            else:  # 重复key
                node.count += 1
                node.value = value  # 更新值
                return node
        
        self._update_height(node)
        
        # 平衡检查
        balance = self._balance_factor(node)
        
        # 左左情况
        if balance > 1 and key < node.left.key:
            return self._rotate_right(node)
        
        # 右右情况
        if balance < -1 and key > node.right.key:
            return self._rotate_left(node)
        
        # 左右情况
        if balance > 1 and key > node.left.key:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        
        # 右左情况
        if balance < -1 and key < node.right.key:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        
        return node
    
    def insert(self, key: str, value: any):
        """插入键值对"""
        with self.lock:
            self.root = self._insert_node(self.root, key, value)
    
    def _search_node(self, node: Optional[AVLTreeNode], key: str) -> Optional[any]:
        """搜索节点"""
        if not node:
            return None
        
        with node.lock:
            if key == node.key:
                return node.value
            elif key < node.key:
                return self._search_node(node.left, key)
            else:
                return self._search_node(node.right, key)
    
    def search(self, key: str) -> Optional[any]:
        """搜索值"""
        return self._search_node(self.root, key)
    
    def _inorder_traversal(self, node: Optional[AVLTreeNode], result: List[tuple]):
        """中序遍历"""
        if node:
            self._inorder_traversal(node.left, result)
            for _ in range(node.count):
                result.append((node.key, node.value))
            self._inorder_traversal(node.right, result)
    
    def get_all_items(self) -> List[tuple]:
        """获取所有项目（已排序）"""
        result = []
        self._inorder_traversal(self.root, result)
        return result
    
    def range_query(self, start_key: str, end_key: str) -> List[tuple]:
        """范围查询"""
        result = []
        self._range_query_recursive(self.root, start_key, end_key, result)
        return result
    
    def _range_query_recursive(self, node: Optional[AVLTreeNode], start: str, end: str, result: List[tuple]):
        """递归范围查询"""
        if not node:
            return
        
        with node.lock:
            if start < node.key:
                self._range_query_recursive(node.left, start, end, result)
            
            if start <= node.key <= end:
                for _ in range(node.count):
                    result.append((node.key, node.value))
            
            if node.key < end:
                self._range_query_recursive(node.right, start, end, result)

class MemoryIndexSystem:
    """内存索引系统"""
    
    def __init__(self):
        self.index = AVLTree()
        self.metadata = {}
        self.stats = {
            'total_keys': 0,
            'total_queries': 0,
            'avg_query_time': 0
        }
    
    def index_document(self, doc_id: str, fields: Dict[str, any]):
        """索引文档"""
        for field_name, field_value in fields.items():
            index_key = f"{field_name}:{field_value}"
            doc_list = self.index.search(index_key) or []
            if doc_id not in doc_list:
                doc_list.append(doc_id)
                self.index.insert(index_key, doc_list)
                self.stats['total_keys'] += 1
    
    def search_by_field(self, field_name: str, field_value: str) -> List[str]:
        """按字段搜索"""
        start_time = time.time()
        index_key = f"{field_name}:{field_value}"
        result = self.index.search(index_key) or []
        
        # 更新统计信息
        query_time = time.time() - start_time
        self.stats['total_queries'] += 1
        self.stats['avg_query_time'] = (
            (self.stats['avg_query_time'] * (self.stats['total_queries'] - 1) + query_time) / 
            self.stats['total_queries']
        )
        
        return result
    
    def range_search(self, field_name: str, start_value: str, end_value: str) -> List[str]:
        """范围搜索"""
        start_key = f"{field_name}:{start_value}"
        end_key = f"{field_name}:{end_value}"
        results = []
        
        indexed_results = self.index.range_query(start_key, end_key)
        for _, doc_list in indexed_results:
            results.extend(doc_list)
        
        return list(set(results))  # 去重
    
    def get_stats(self) -> Dict:
        """获取系统统计信息"""
        return self.stats.copy()
```

## 红黑树 - 文件系统实现

```python
from enum import Enum
from typing import Optional, List

class NodeColor(Enum):
    RED = 0
    BLACK = 1

class FileSystemNode:
    """文件系统节点"""
    
    def __init__(self, name: str, node_type: str, size: int = 0):
        self.name = name
        self.type = node_type  # 'file' or 'directory'
        self.size = size
        self.color = NodeColor.RED
        self.parent: Optional['FileSystemNode'] = None
        self.left: Optional['FileSystemNode'] = None
        self.right: Optional['FileSystemNode'] = None
        self.children = {}  # 对于目录，存储子节点
        self.created_at = time.time()
        self.modified_at = time.time()

class RedBlackFileSystem:
    """基于红黑树的文件系统"""
    
    def __init__(self):
        self.root: Optional[FileSystemNode] = None
        self.total_size = 0
        self.file_count = 0
        self.dir_count = 0
    
    def _rotate_left(self, node: FileSystemNode) -> FileSystemNode:
        """左旋"""
        right_child = node.right
        node.right = right_child.left
        
        if right_child.left:
            right_child.left.parent = node
        
        right_child.parent = node.parent
        
        if not node.parent:
            self.root = right_child
        elif node == node.parent.left:
            node.parent.left = right_child
        else:
            node.parent.right = right_child
        
        right_child.left = node
        node.parent = right_child
        
        return right_child
    
    def _rotate_right(self, node: FileSystemNode) -> FileSystemNode:
        """右旋"""
        left_child = node.left
        node.left = left_child.right
        
        if left_child.right:
            left_child.right.parent = node
        
        left_child.parent = node.parent
        
        if not node.parent:
            self.root = left_child
        elif node == node.parent.right:
            node.parent.right = left_child
        else:
            node.parent.left = left_child
        
        left_child.right = node
        node.parent = left_child
        
        return left_child
    
    def _fix_insert(self, node: FileSystemNode):
        """修复插入后的红黑树性质"""
        while node != self.root and node.parent.color == NodeColor.RED:
            if node.parent == node.parent.parent.left:
                uncle = node.parent.parent.right
                
                if uncle and uncle.color == NodeColor.RED:
                    # 情况1：叔节点为红色
                    node.parent.color = NodeColor.BLACK
                    uncle.color = NodeColor.BLACK
                    node.parent.parent.color = NodeColor.RED
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        # 情况2：节点为右子节点
                        node = node.parent
                        self._rotate_left(node)
                    
                    # 情况3：节点为左子节点
                    node.parent.color = NodeColor.BLACK
                    node.parent.parent.color = NodeColor.RED
                    self._rotate_right(node.parent.parent)
            else:
                # 对称情况
                uncle = node.parent.parent.left
                
                if uncle and uncle.color == NodeColor.RED:
                    node.parent.color = NodeColor.BLACK
                    uncle.color = NodeColor.BLACK
                    node.parent.parent.color = NodeColor.RED
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self._rotate_right(node)
                    
                    node.parent.color = NodeColor.BLACK
                    node.parent.parent.color = NodeColor.RED
                    self._rotate_left(node.parent.parent)
        
        self.root.color = NodeColor.BLACK
    
    def insert_file(self, name: str, size: int = 0):
        """插入文件"""
        if not self.root:
            self.root = FileSystemNode(name, 'file', size)
            self.root.color = NodeColor.BLACK
            self.file_count += 1
            self.total_size += size
            return
        
        # 寻找插入位置
        current = self.root
        parent = None
        while current:
            parent = current
            if name < current.name:
                current = current.left
            else:
                current = current.right
        
        # 创建新节点
        new_node = FileSystemNode(name, 'file', size)
        new_node.parent = parent
        
        if name < parent.name:
            parent.left = new_node
        else:
            parent.right = new_node
        
        self._fix_insert(new_node)
        self.file_count += 1
        self.total_size += size
    
    def search_file(self, name: str) -> Optional[FileSystemNode]:
        """搜索文件"""
        current = self.root
        while current:
            if name == current.name:
                return current
            elif name < current.name:
                current = current.left
            else:
                current = current.right
        return None
    
    def _inorder_traversal(self, node: Optional[FileSystemNode], files: List[str]):
        """中序遍历获取所有文件"""
        if node:
            self._inorder_traversal(node.left, files)
            files.append(f"{node.name} ({node.size} bytes)")
            self._inorder_traversal(node.right, files)
    
    def list_all_files(self) -> List[str]:
        """列出所有文件（按名称排序）"""
        files = []
        self._inorder_traversal(self.root, files)
        return files
    
    def get_directory_stats(self) -> Dict:
        """获取目录统计信息"""
        return {
            'total_files': self.file_count,
            'total_size': self.total_size,
            'average_file_size': self.total_size / self.file_count if self.file_count > 0 else 0,
            'root_name': self.root.name if self.root else None
        }

# 使用示例
def demo_file_system():
    """文件系统演示"""
    fs = RedBlackFileSystem()
    
    # 插入文件
    files = [
        ('config.txt', 1024),
        ('data.csv', 5120),
        ('readme.md', 2048),
        ('script.py', 3072),
        ('image.png', 8192)
    ]
    
    for name, size in files:
        fs.insert_file(name, size)
    
    # 搜索文件
    found_file = fs.search_file('data.csv')
    if found_file:
        print(f"找到文件: {found_file.name}, 大小: {found_file.size} bytes")
    
    # 列出所有文件
    all_files = fs.list_all_files()
    print("所有文件（按名称排序）:")
    for file in all_files:
        print(f"  {file}")
    
    # 统计信息
    stats = fs.get_directory_stats()
    print(f"目录统计: {stats}")

demo_file_system()
```

## B树和B+树 - 数据库索引

### B+树实现

```python
import math
from typing import List, Optional

class BPlusTreeNode:
    """B+树节点"""
    
    def __init__(self, is_leaf: bool = False):
        self.is_leaf = is_leaf
        self.keys: List[any] = []
        self.values: List[any] = []  # 叶节点存储值，内部节点存储子节点引用
        self.children: List['BPlusTreeNode'] = []  # 内部节点子节点
        self.next_leaf: Optional['BPlusTreeNode'] = None  # 叶节点链表链接
    
    def is_full(self, order: int) -> bool:
        """检查节点是否已满"""
        return len(self.keys) >= order
    
    def split_node(self, order: int) -> 'BPlusTreeNode':
        """分裂节点"""
        mid = len(self.keys) // 2
        mid_key = self.keys[mid]
        
        if self.is_leaf:
            # 叶节点分裂
            new_node = BPlusTreeNode(is_leaf=True)
            
            # 移动后半部分键值对到新节点
            new_node.keys = self.keys[mid:]
            new_node.values = self.values[mid:]
            new_node.next_leaf = self.next_leaf
            
            # 当前节点保留前半部分
            self.keys = self.keys[:mid]
            self.values = self.values[:mid]
            self.next_leaf = new_node
            
            return new_node
        else:
            # 内部节点分裂
            new_node = BPlusTreeNode(is_leaf=False)
            
            # 移动后半部分键和子节点到新节点（注意：mid_key上移）
            new_node.keys = self.keys[mid+1:]
            new_node.children = self.children[mid+1:]
            
            # 当前节点保留前半部分和中间键
            self.keys = self.keys[:mid]
            self.children = self.children[:mid+1]
            
            return new_node
    
    def merge_with_sibling(self, sibling: 'BPlusTreeNode', parent_key: any):
        """与兄弟节点合并"""
        if self.is_leaf:
            # 叶节点合并
            self.keys.extend([parent_key] + sibling.keys)
            self.values.extend(sibling.values)
            self.next_leaf = sibling.next_leaf
        else:
            # 内部节点合并
            self.keys.append(parent_key)
            self.keys.extend(sibling.keys)
            self.children.extend(sibling.children)

class BPlusTree:
    """B+树实现"""
    
    def __init__(self, order: int = 100):
        self.order = order
        self.min_keys = (order + 1) // 2 - 1
        self.root: Optional[BPlusTreeNode] = None
        self.size = 0
    
    def _find_leaf(self, key: any) -> BPlusTreeNode:
        """找到包含key的叶节点"""
        current = self.root
        while current and not current.is_leaf:
            # 在当前节点的键中找到插入位置
            i = 0
            while i < len(current.keys) and key >= current.keys[i]:
                i += 1
            current = current.children[i]
        return current
    
    def _insert_non_full(self, node: BPlusTreeNode, key: any, value: any):
        """在非满节点中插入"""
        i = len(node.keys) - 1
        
        if node.is_leaf:
            # 叶节点插入
            node.keys.append(None)
            node.values.append(None)
            
            while i >= 0 and key < node.keys[i]:
                node.keys[i + 1] = node.keys[i]
                node.values[i + 1] = node.values[i]
                i -= 1
            
            node.keys[i + 1] = key
            node.values[i + 1] = value
        else:
            # 内部节点插入
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            
            if node.children[i].is_full(self.order):
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
            
            self._insert_non_full(node.children[i], key, value)
    
    def _split_child(self, parent: BPlusTreeNode, index: int):
        """分裂子节点"""
        child = parent.children[index]
        new_child = child.split_node(self.order)
        
        # 将新的子节点和中间键插入到父节点
        parent.keys.insert(index, child.keys[-1])
        parent.children.insert(index + 1, new_child)
        
        # 从原节点移除上移的键
        if child.is_leaf:
            child.keys.pop()  # 移除上移的键
        else:
            child.keys.pop()  # 移除上移的键
    
    def _handle_underflow(self, node: BPlusTreeNode, child_index: int):
        """处理下溢"""
        child = node.children[child_index]
        
        # 尝试从左兄弟借用
        if child_index > 0 and len(node.children[child_index - 1].keys) > self.min_keys:
            self._borrow_from_left(node, child_index)
        # 尝试从右兄弟借用
        elif child_index < len(node.children) - 1 and len(node.children[child_index + 1].keys) > self.min_keys:
            self._borrow_from_right(node, child_index)
        # 合并节点
        else:
            self._merge_children(node, child_index)
    
    def _borrow_from_left(self, parent: BPlusTreeNode, child_index: int):
        """从左兄弟借用"""
        child = parent.children[child_index]
        left_sibling = parent.children[child_index - 1]
        
        if child.is_leaf:
            # 叶节点借用
            child.keys.insert(0, left_sibling.keys.pop())
            child.values.insert(0, left_sibling.values.pop())
            parent.keys[child_index - 1] = left_sibling.keys[-1]
        else:
            # 内部节点借用
            child.keys.insert(0, parent.keys[child_index - 1])
            child.children.insert(0, left_sibling.children.pop())
            parent.keys[child_index - 1] = left_sibling.keys.pop()
    
    def _borrow_from_right(self, parent: BPlusTreeNode, child_index: int):
        """从右兄弟借用"""
        child = parent.children[child_index]
        right_sibling = parent.children[child_index + 1]
        
        if child.is_leaf:
            # 叶节点借用
            child.keys.append(right_sibling.keys.pop(0))
            child.values.append(right_sibling.values.pop(0))
            parent.keys[child_index] = right_sibling.keys[0]
        else:
            # 内部节点借用
            child.keys.append(parent.keys[child_index])
            child.children.append(right_sibling.children.pop(0))
            parent.keys[child_index] = right_sibling.keys.pop(0)
    
    def _merge_children(self, parent: BPlusTreeNode, child_index: int):
        """合并子节点"""
        child = parent.children[child_index]
        sibling = parent.children[child_index + 1]
        
        # 与右兄弟合并（或左兄弟）
        if child_index < len(parent.children) - 1:
            child.merge_with_sibling(sibling, parent.keys[child_index])
            parent.keys.pop(child_index)
            parent.children.pop(child_index + 1)
        else:
            sibling.merge_with_sibling(child, parent.keys[child_index - 1])
            parent.keys.pop(child_index - 1)
            parent.children.pop(child_index)
    
    def insert(self, key: any, value: any):
        """插入键值对"""
        if not self.root:
            self.root = BPlusTreeNode(is_leaf=True)
        
        # 如果根已满，分裂根
        if self.root.is_full(self.order):
            new_root = BPlusTreeNode(is_leaf=False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        
        self._insert_non_full(self.root, key, value)
        self.size += 1
    
    def search(self, key: any) -> Optional[any]:
        """搜索值"""
        leaf = self._find_leaf(key)
        
        # 在叶节点中搜索
        for i, k in enumerate(leaf.keys):
            if k == key:
                return leaf.values[i]
        return None
    
    def range_search(self, start_key: any, end_key: any) -> List[tuple]:
        """范围查询"""
        results = []
        leaf = self._find_leaf(start_key)
        
        while leaf:
            for i, key in enumerate(leaf.keys):
                if start_key <= key <= end_key:
                    results.append((key, leaf.values[i]))
                elif key > end_key:
                    return results
            leaf = leaf.next_leaf
        
        return results
    
    def delete(self, key: any) -> bool:
        """删除键值对"""
        # 这里简化实现，实际的删除操作更复杂
        # 需要处理节点合并和重新平衡
        leaf = self._find_leaf(key)
        
        for i, k in enumerate(leaf.keys):
            if k == key:
                leaf.keys.pop(i)
                leaf.values.pop(i)
                self.size -= 1
                return True
        return False

class DatabaseIndex:
    """数据库索引系统"""
    
    def __init__(self, order: int = 100):
        self.btree = BPlusTree(order)
        self.index_stats = {
            'total_inserts': 0,
            'total_lookups': 0,
            'total_ranges': 0,
            'avg_lookup_time': 0
        }
    
    def create_index(self, table_name: str, column_name: str):
        """创建索引"""
        index_name = f"{table_name}_{column_name}_idx"
        print(f"创建索引: {index_name}")
    
    def insert_record(self, record_id: any, indexed_values: Dict[str, any]):
        """插入记录到索引"""
        for column, value in indexed_values.items():
            self.btree.insert((record_id, column), value)
        self.index_stats['total_inserts'] += 1
    
    def query_by_column(self, column: str, value: any) -> List[any]:
        """按列查询"""
        start_time = time.time()
        results = []
        
        # 遍历所有匹配的记录
        for i in range(self.btree.size):
            key = (i, column)
            found_value = self.btree.search(key)
            if found_value == value:
                results.append(i)
        
        query_time = time.time() - start_time
        self.index_stats['total_lookups'] += 1
        self.index_stats['avg_lookup_time'] = (
            (self.index_stats['avg_lookup_time'] * (self.index_stats['total_lookups'] - 1) + query_time) /
            self.index_stats['total_lookups']
        )
        
        return results
    
    def range_query(self, column: str, start_value: any, end_value: any) -> List[tuple]:
        """范围查询"""
        self.index_stats['total_ranges'] += 1
        return self.btree.range_search(start_value, end_value)
    
    def get_stats(self) -> Dict:
        """获取索引统计信息"""
        return {
            'total_records': self.btree.size,
            'tree_height': self._calculate_tree_height(),
            'index_stats': self.index_stats.copy()
        }
    
    def _calculate_tree_height(self) -> int:
        """计算树的高度"""
        if not self.btree.root:
            return 0
        
        height = 1
        current = self.btree.root
        while not current.is_leaf:
            height += 1
            current = current.children[0]
        return height
```

## Trie树 - 前缀匹配和路由

```python
from typing import Dict, List, Optional

class TrieNode:
    """Trie树节点"""
    
    def __init__(self):
        self.children: Dict[str, 'TrieNode'] = {}
        self.is_end_of_word = False
        self.is_end_of_prefix = False
        self.value = None  # 存储关联的值
        self.metadata = {}  # 存储元数据
        self.path = ""  # 从根到当前节点的路径

class Trie:
    """前缀树实现"""
    
    def __init__(self):
        self.root = TrieNode()
        self.size = 0
        self.prefix_counts = {}  # 前缀使用统计
    
    def insert(self, word: str, value: any = None, metadata: Dict = None):
        """插入单词"""
        current = self.root
        
        for char in word:
            if char not in current.children:
                new_node = TrieNode()
                new_node.path = current.path + char
                current.children[char] = new_node
            current = current.children[char]
            current.is_end_of_prefix = True
        
        if not current.is_end_of_word:
            current.is_end_of_word = True
            current.value = value
            current.metadata = metadata or {}
            self.size += 1
        
        # 更新前缀统计
        self._update_prefix_count(word)
    
    def search(self, word: str) -> Optional[tuple]:
        """搜索单词"""
        current = self.root
        
        for char in word:
            if char not in current.children:
                return None
            current = current.children[char]
        
        if current.is_end_of_word:
            return (current.value, current.metadata)
        return None
    
    def starts_with(self, prefix: str) -> List[tuple]:
        """找到以prefix开头的所有单词"""
        current = self.root
        
        for char in prefix:
            if char not in current.children:
                return []
            current = current.children[char]
        
        results = []
        self._collect_words(current, prefix, results)
        return results
    
    def _collect_words(self, node: TrieNode, prefix: str, results: List[tuple]):
        """递归收集单词"""
        if node.is_end_of_word:
            results.append((prefix, node.value, node.metadata))
        
        for char, child_node in node.children.items():
            self._collect_words(child_node, prefix + char, results)
    
    def _update_prefix_count(self, word: str):
        """更新前缀使用统计"""
        for i in range(1, len(word) + 1):
            prefix = word[:i]
            self.prefix_counts[prefix] = self.prefix_counts.get(prefix, 0) + 1
    
    def get_suggestions(self, prefix: str, max_suggestions: int = 5) -> List[tuple]:
        """获取智能建议"""
        if prefix not in self.prefix_counts:
            return []
        
        suggestions = self.starts_with(prefix)
        
        # 按使用频率和字典序排序
        suggestions.sort(key=lambda x: (
            -self.prefix_counts.get(x[0], 0),  # 使用频率降序
            x[0]  # 字典序升序
        ))
        
        return suggestions[:max_suggestions]
    
    def get_prefix_frequency(self, prefix: str) -> int:
        """获取前缀使用频率"""
        return self.prefix_counts.get(prefix, 0)

class URLRoutingTrie:
    """URL路由Trie树"""
    
    def __init__(self):
        self.trie = Trie()
        self.routes = {}  # 存储路由配置
        self.middleware = {}  # 存储中间件
    
    def add_route(self, path: str, handler: callable, methods: List[str] = ['GET'], 
                  middleware: List[callable] = None):
        """添加路由"""
        # 解析路径参数和通配符
        path_parts = self._parse_path(path)
        
        for method in methods:
            route_key = f"{method}:{path}"
            self.routes[route_key] = {
                'handler': handler,
                'parts': path_parts,
                'middleware': middleware or []
            }
            
            # 插入到Trie树
            self.trie.insert(f"{method}:{path}")
    
    def _parse_path(self, path: str) -> List[Dict]:
        """解析路径"""
        parts = []
        current_part = ""
        param_type = None
        
        for char in path:
            if char == ':':
                if current_part:
                    parts.append({'type': 'static', 'value': current_part})
                    current_part = ""
                param_type = 'param'
            elif char == '*':
                if current_part:
                    parts.append({'type': 'static', 'value': current_part})
                    current_part = ""
                param_type = 'wildcard'
            elif char == '/':
                if current_part:
                    parts.append({'type': param_type or 'static', 'value': current_part})
                    current_part = ""
                param_type = None
            else:
                current_part += char
        
        if current_part:
            parts.append({'type': param_type or 'static', 'value': current_part})
        
        return parts
    
    def match_route(self, method: str, path: str) -> Optional[Dict]:
        """匹配路由"""
        # 精确匹配
        route_key = f"{method}:{path}"
        if route_key in self.routes:
            return self.routes[route_key]
        
        # 模式匹配
        matches = self._match_pattern(method, path)
        if matches:
            route_key = f"{method}:{matches['pattern']}"
            return self.routes[route_key]
        
        return None
    
    def _match_pattern(self, method: str, path: str) -> Optional[Dict]:
        """模式匹配"""
        path_parts = path.strip('/').split('/')
        
        for route_key, route_config in self.routes.items():
            if not route_key.startswith(method + ':'):
                continue
            
            pattern = route_key.split(':', 1)[1]
            pattern_parts = self._parse_path(pattern)
            
            if len(pattern_parts) != len(path_parts):
                continue
            
            params = {}
            match = True
            
            for i, (pattern_part, path_part) in enumerate(zip(pattern_parts, path_parts)):
                if pattern_part['type'] == 'static':
                    if pattern_part['value'] != path_part:
                        match = False
                        break
                elif pattern_part['type'] == 'param':
                    params[pattern_part['value']] = path_part
                elif pattern_part['type'] == 'wildcard':
                    # 通配符匹配剩余所有部分
                    params[pattern_part['value']] = '/'.join(path_parts[i:])
                    break
            
            if match:
                return {
                    'pattern': pattern,
                    'params': params,
                    'route_config': route_config
                }
        
        return None

# 使用示例
def demo_url_router():
    """URL路由演示"""
    router = URLRoutingTrie()
    
    # 添加路由
    def user_handler(params):
        return f"User: {params.get('user_id')}"
    
    def post_handler(params):
        return f"Post: {params.get('post_id')}"
    
    def files_handler(params):
        return f"Files: {params.get('file_path')}"
    
    router.add_route('/users/:user_id', user_handler, ['GET', 'POST'])
    router.add_route('/posts/:post_id/comments/:comment_id', post_handler)
    router.add_route('/files/*file_path', files_handler)
    
    # 测试路由匹配
    test_paths = [
        ('GET', '/users/123'),
        ('POST', '/users/456'),
        ('GET', '/posts/789/comments/abc'),
        ('GET', '/files/documents/readme.txt')
    ]
    
    for method, path in test_paths:
        match = router.match_route(method, path)
        if match:
            print(f"{method} {path} -> 匹配路由: {match['pattern']}")
            print(f"  参数: {match['params']}")
            result = match['route_config']['handler'](match['params'])
            print(f"  结果: {result}")
        else:
            print(f"{method} {path} -> 未匹配路由")

demo_url_router()
```

## 段树 - 区间查询和更新

```python
import math
from typing import List, Optional

class SegmentTreeNode:
    """线段树节点"""
    
    def __init__(self, start: int, end: int):
        self.start = start
        self.end = end
        self.left: Optional['SegmentTreeNode'] = None
        self.right: Optional['SegmentTreeNode'] = None
        self.value = 0
        self.lazy = 0  # 懒标记
        
        # 统计信息
        self.sum = 0
        self.max = float('-inf')
        self.min = float('inf')
        self.count = end - start + 1

class SegmentTree:
    """线段树 - 支持区间查询和更新"""
    
    def __init__(self, data: List[int]):
        self.data = data
        self.root = self._build_tree(0, len(data) - 1)
    
    def _build_tree(self, start: int, end: int) -> SegmentTreeNode:
        """构建线段树"""
        node = SegmentTreeNode(start, end)
        
        if start == end:
            value = self.data[start]
            node.value = value
            node.sum = value
            node.max = value
            node.min = value
        else:
            mid = (start + end) // 2
            node.left = self._build_tree(start, mid)
            node.right = self._build_tree(mid + 1, end)
            self._pull_up(node)
        
        return node
    
    def _pull_up(self, node: SegmentTreeNode):
        """向上更新节点信息"""
        node.sum = node.left.sum + node.right.sum
        node.max = max(node.left.max, node.right.max)
        node.min = min(node.left.min, node.right.min)
    
    def _push_down(self, node: SegmentTreeNode):
        """向下传递懒标记"""
        if node.lazy != 0 and node.left:
            # 更新左子节点
            node.left.value += node.lazy
            node.left.sum += node.lazy * node.left.count
            node.left.max += node.lazy
            node.left.min += node.lazy
            node.left.lazy += node.lazy
            
            # 更新右子节点
            node.right.value += node.lazy
            node.right.sum += node.lazy * node.right.count
            node.right.max += node.lazy
            node.right.min += node.lazy
            node.right.lazy += node.lazy
            
            node.lazy = 0
    
    def range_update(self, l: int, r: int, delta: int):
        """区间更新"""
        self._range_update(self.root, l, r, delta)
    
    def _range_update(self, node: SegmentTreeNode, l: int, r: int, delta: int):
        """递归区间更新"""
        if l > node.end or r < node.start:
            return
        
        if l <= node.start and node.end <= r:
            # 完全覆盖，更新当前节点
            node.value += delta
            node.sum += delta * node.count
            node.max += delta
            node.min += delta
            node.lazy += delta
            return
        
        # 部分覆盖，递归更新
        self._push_down(node)
        self._range_update(node.left, l, r, delta)
        self._range_update(node.right, l, r, delta)
        self._pull_up(node)
    
    def range_query(self, l: int, r: int) -> Dict:
        """区间查询"""
        return self._range_query(self.root, l, r)
    
    def _range_query(self, node: SegmentTreeNode, l: int, r: int) -> Dict:
        """递归区间查询"""
        if l > node.end or r < node.start:
            return {'sum': 0, 'max': float('-inf'), 'min': float('inf')}
        
        if l <= node.start and node.end <= r:
            # 完全覆盖
            return {'sum': node.sum, 'max': node.max, 'min': node.min}
        
        # 部分覆盖
        self._push_down(node)
        left_result = self._range_query(node.left, l, r)
        right_result = self._range_query(node.right, l, r)
        
        return {
            'sum': left_result['sum'] + right_result['sum'],
            'max': max(left_result['max'], right_result['max']),
            'min': min(left_result['min'], right_result['min'])
        }
    
    def point_query(self, index: int) -> int:
        """点查询"""
        return self._point_query(self.root, index)
    
    def _point_query(self, node: SegmentTreeNode, index: int) -> int:
        """递归点查询"""
        if node.start == node.end:
            return node.value
        
        self._push_down(node)
        
        if index <= node.left.end:
            return self._point_query(node.left, index)
        else:
            return self._point_query(node.right, index)

class MonitoringSegmentTree:
    """监控系统的线段树"""
    
    def __init__(self, metrics_window: int):
        self.segment_tree = SegmentTree([0] * metrics_window)
        self.window_size = metrics_window
        self.current_index = 0
        self.monitoring_stats = {
            'total_updates': 0,
            'total_queries': 0,
            'alert_thresholds': {
                'cpu_usage': 80,
                'memory_usage': 85,
                'response_time': 1000
            }
        }
    
    def update_metric(self, metric_name: str, value: int, timestamp: int):
        """更新监控指标"""
        index = timestamp % self.window_size
        self.segment_tree.range_update(index, index, value)
        self.monitoring_stats['total_updates'] += 1
        
        # 检查告警阈值
        self._check_alerts(metric_name, value)
    
    def _check_alerts(self, metric_name: str, value: int):
        """检查告警"""
        threshold = self.monitoring_stats['alert_thresholds'].get(metric_name)
        if threshold and value > threshold:
            print(f"⚠️ 告警: {metric_name} 超过阈值 {threshold}，当前值: {value}")
    
    def get_current_metrics(self) -> Dict:
        """获取当前指标"""
        result = self.segment_tree.range_query(0, self.window_size - 1)
        self.monitoring_stats['total_queries'] += 1
        
        return {
            'sum': result['sum'],
            'max': result['max'],
            'min': result['min'],
            'average': result['sum'] / self.window_size if self.window_size > 0 else 0
        }
    
    def detect_anomalies(self, window_size: int = 10) -> List[Dict]:
        """异常检测"""
        anomalies = []
        
        for i in range(self.window_size - window_size + 1):
            window_data = []
            for j in range(i, i + window_size):
                value = self.segment_tree.point_query(j)
                window_data.append(value)
            
            # 简单的异常检测：使用3-sigma规则
            mean = sum(window_data) / len(window_data)
            variance = sum((x - mean) ** 2 for x in window_data) / len(window_data)
            std_dev = math.sqrt(variance)
            
            for j, value in enumerate(window_data):
                if abs(value - mean) > 3 * std_dev:
                    anomalies.append({
                        'timestamp': i + j,
                        'value': value,
                        'expected': mean,
                        'deviation': abs(value - mean)
                    })
        
        return anomalies

# 使用示例
def demo_monitoring_system():
    """监控系统演示"""
    monitor = MonitoringSegmentTree(100)
    
    # 模拟监控数据更新
    import random
    
    for i in range(50):
        cpu_usage = random.randint(10, 100)
        memory_usage = random.randint(20, 90)
        
        monitor.update_metric('cpu_usage', cpu_usage, i)
        monitor.update_metric('memory_usage', memory_usage, i)
        
        if random.random() < 0.1:  # 10%概率生成异常值
            monitor.update_metric('cpu_usage', random.randint(90, 150), i)
    
    # 获取当前指标
    metrics = monitor.get_current_metrics()
    print(f"当前监控指标: {metrics}")
    
    # 检测异常
    anomalies = monitor.detect_anomalies()
    if anomalies:
        print(f"检测到 {len(anomalies)} 个异常点:")
        for anomaly in anomalies[:5]:  # 只显示前5个
            print(f"  时间点 {anomaly['timestamp']}: 值={anomaly['value']}, 期望={anomaly['expected']:.2f}")

demo_monitoring_system()
```

## 总结

树结构在系统架构中扮演着至关重要的角色，不同类型的树结构适用于不同的应用场景：

### 应用场景分类

1. **内存索引系统**
   - AVL树：适用于需要频繁搜索和有序遍历的场景
   - 红黑树：适用于需要动态插入删除的内存数据库

2. **数据库索引**
   - B+树：数据库索引的标准实现，支持范围查询
   - B树：适用于磁盘存储的索引结构

3. **路由和前缀匹配**
   - Trie树：适用于URL路由、搜索引擎、自动补全
   - 前缀树：高效的字符串匹配和前缀搜索

4. **区间查询和监控**
   - 线段树：适用于监控系统、统计分析、范围查询
   - 树状数组：适用于动态区间求和

5. **文件系统**
   - B树变种：文件系统的目录结构
   - 扩展树：支持动态扩展的文件索引

### 性能优化策略

1. **内存管理**
   - 使用对象池减少内存分配
   - 实现懒加载机制
   - 优化树的平衡因子

2. **并发控制**
   - 实现读写锁
   - 使用无锁数据结构
   - 分片策略

3. **缓存优化**
   - 节点缓存
   - 结果缓存
   - 预热机制

4. **持久化策略**
   - WAL（预写日志）
   - 快照机制
   - 增量更新

选择合适的树结构并正确实现是构建高性能系统的关键。需要根据具体的应用场景、性能要求和资源限制来做出最适合的选择。