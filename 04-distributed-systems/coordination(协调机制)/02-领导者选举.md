# 领导选举算法详解

## 目录
1. [领导选举概述](#领导选举概述)
2. [领导选举算法](#领导选举算法)
3. [基于ZooKeeper的领导选举](#基于zookeeper的领导选举)
4. [基于Redis的领导选举](#基于redis的领导选举)
5. [基于Raft的领导选举](#基于raft的领导选举)
6. [心跳机制](#心跳机制)
7. [故障检测与恢复](#故障检测与恢复)
8. [Python实现](#python实现)
9. [Go语言实现](#go语言实现)
10. [实际应用案例](#实际应用案例)
11. [最佳实践](#最佳实践)

## 领导选举概述

### 什么是领导选举？

领导选举（Leader Election）是在分布式系统中选择一个节点作为领导者的过程，确保在任意时刻只有一个领导者负责协调和管理系统状态。

### 为什么需要领导选举？

```python
class LeaderElectionNeed:
    """领导选举需求分析"""
    
    def __init__(self):
        self.problems = {
            'distributed_coordination': {
                'name': '分布式协调',
                'description': '多个节点需要协调执行统一操作',
                'example': '分布式事务处理',
                'consequence': '数据不一致、操作冲突'
            },
            'single_point_of_failure': {
                'name': '单点故障',
                'description': '静态指定的协调节点故障',
                'example': '数据库主节点故障',
                'consequence': '系统不可用'
            },
            'load_balancing': {
                'name': '负载均衡',
                'description': '需要动态选择最优节点',
                'example': '任务调度中心选择',
                'consequence': '性能下降、资源浪费'
            },
            'consensus_requirement': {
                'name': '共识需求',
                'description': '需要确定统一的系统状态',
                'example': '配置信息同步',
                'consequence': '系统行为不一致'
            }
        }
    
    def show_election_benefits(self):
        """展示领导选举的好处"""
        benefits = {
            'fault_tolerance': '故障容错：自动处理领导者故障',
            'load_distribution': '负载分布：动态选择最优节点',
            'consensus_achievement': '达成共识：确保系统状态一致',
            'simplified_coordination': '简化协调：单一领导点',
            'automatic_recovery': '自动恢复：故障后自动重新选举'
        }
        return benefits

print("=== 领导选举需求分析 ===")
need_analyzer = LeaderElectionNeed()
for problem_name, problem_data in need_analyzer.problems.items():
    print(f"问题: {problem_data['name']}")
    print(f"描述: {problem_data['description']}")
    print(f"示例: {problem_data['example']}")
    print(f"后果: {problem_data['consequence']}\n")
```

## 领导选举算法

### 1. Bully算法

```python
class BullyAlgorithm:
    """欺负算法（Bully Algorithm）"""
    
    def __init__(self, node_id: str, all_nodes: list):
        self.node_id = node_id
        self.all_nodes = sorted(all_nodes)  # 排序确保有优先级
        self.is_leader = False
        self.election_in_progress = False
        
    def start_election(self):
        """开始选举"""
        if self.election_in_progress:
            return
        
        self.election_in_progress = True
        print(f"Node {self.node_id} starting election...")
        
        # 找出所有ID比自己大的节点
        higher_nodes = [node for node in self.all_nodes if node > self.node_id]
        
        if not higher_nodes:
            # 没有比自己大的节点，自己成为领导者
            self.become_leader()
        else:
            # 向所有比自己大的节点发送选举消息
            self.send_election_messages(higher_nodes)
            
            # 等待响应
            time.sleep(2)  # 等待时间
            
            if self.is_leader:
                print(f"Node {self.node_id} became leader")
            else:
                # 收到更高ID节点的响应，等待它们成为领导者
                print(f"Node {self.node_id} received response from higher node")
        
        self.election_in_progress = False
    
    def send_election_messages(self, nodes):
        """发送选举消息"""
        for node in nodes:
            print(f"Node {self.node_id} sending election message to {node}")
            # 在实际实现中，这里会发送网络消息
    
    def receive_election_message(self, sender_id: str):
        """接收选举消息"""
        if sender_id > self.node_id:
            # 发送响应表示自己会参与选举
            print(f"Node {self.node_id} responding to election from {sender_id}")
            self.send_response(sender_id)
            
            # 如果还没有更高ID的节点参与选举，则开始自己的选举
            if not self.is_leader:
                self.start_election()
    
    def send_response(self, target_id: str):
        """发送响应消息"""
        print(f"Node {self.node_id} sending response to {target_id}")
    
    def receive_coordinator_message(self, coordinator_id: str):
        """接收协调者消息"""
        if coordinator_id > self.node_id:
            print(f"Node {self.node_id} acknowledges {coordinator_id} as leader")
            self.is_leader = False
    
    def become_leader(self):
        """成为领导者"""
        self.is_leader = True
        print(f"Node {self.node_id} is now the LEADER")
        
        # 通知所有其他节点
        for node in self.all_nodes:
            if node != self.node_id:
                self.send_coordinator_message(node)
    
    def send_coordinator_message(self, target_id: str):
        """发送协调者消息"""
        print(f"Node {self.node_id} sending coordinator message to {target_id}")

print("=== Bully算法示例 ===")

# 创建节点
nodes = ['node1', 'node2', 'node3', 'node4', 'node5']

# 随机选择节点开始选举
import random
random.seed(42)

node_states = {}
for node_id in nodes:
    node_states[node_id] = BullyAlgorithm(node_id, nodes)

# 随机选择几个节点开始选举
initiating_nodes = random.sample(nodes, 3)
print(f"Initiating nodes: {initiating_nodes}\n")

for node_id in initiating_nodes:
    node_states[node_id].start_election()
    print()

# 模拟最高ID节点最终成为领导者
print(f"Highest node {max(nodes)} will eventually become leader")
```

### 2. 环算法

```python
class RingAlgorithm:
    """环算法（Ring Algorithm）"""
    
    def __init__(self, node_id: str, ring_nodes: list):
        self.node_id = node_id
        self.ring_nodes = ring_nodes  # 环形排列的节点列表
        self.position = ring_nodes.index(node_id)
        self.is_leader = False
        self.election_token = None
        self.received_tokens = set()
    
    def start_election(self):
        """开始选举"""
        print(f"Node {self.node_id} starting election")
        
        # 创建选举令牌，包含自己的ID和最高ID
        my_max_id = max(self.ring_nodes)
        election_token = {
            'initiator': self.node_id,
            'max_id': my_max_id,
            'candidates': [self.node_id],
            'path': [self.node_id]
        }
        
        # 发送给下一个节点
        self.send_token_to_next(election_token)
    
    def send_token_to_next(self, token):
        """发送令牌给下一个节点"""
        next_position = (self.position + 1) % len(self.ring_nodes)
        next_node = self.ring_nodes[next_position]
        
        print(f"Node {self.node_id} sending token to {next_node}")
        
        # 模拟网络延迟
        time.sleep(0.1)
        
        # 在实际实现中，这里会发送到下一个节点
        # self.simulate_receive_token(next_node, token)
    
    def receive_token(self, token: dict, sender_id: str):
        """接收令牌"""
        print(f"Node {self.node_id} received token from {sender_id}")
        
        # 记录传播路径
        token['path'].append(self.node_id)
        
        # 检查是否已经处理过这个令牌
        if token['initiator'] in self.received_tokens:
            print(f"Node {self.node_id} already processed token from {token['initiator']}")
            return
        
        self.received_tokens.add(token['initiator'])
        
        # 更新最高ID
        if self.node_id > token['max_id']:
            token['max_id'] = self.node_id
        
        # 检查是否回到发起者
        if self.node_id == token['initiator']:
            self.complete_election(token)
        else:
            # 继续传播令牌
            self.send_token_to_next(token)
    
    def complete_election(self, token: dict):
        """完成选举"""
        leader_id = token['max_id']
        
        if leader_id == self.node_id:
            self.is_leader = True
            print(f"Node {self.node_id} elected as LEADER")
        else:
            print(f"Node {leader_id} elected as LEADER")
        
        # 广播选举结果
        self.broadcast_result(leader_id, token['path'])
    
    def broadcast_result(self, leader_id: str, path: list):
        """广播选举结果"""
        print(f"Broadcasting leader {leader_id} along path: {path}")
        
        # 在实际实现中，这里会沿路径广播结果

# 环算法演示
def demo_ring_algorithm():
    """环算法演示"""
    ring_nodes = ['node1', 'node2', 'node3', 'node4', 'node5']
    
    print("=== Ring Algorithm Demo ===")
    print(f"Ring structure: {' -> '.join(ring_nodes)} -> {ring_nodes[0]}")
    print()
    
    # 创建节点状态
    node_states = {}
    for node_id in ring_nodes:
        node_states[node_id] = RingAlgorithm(node_id, ring_nodes)
    
    # 随机选择发起者
    initiator = random.choice(ring_nodes)
    print(f"Initiator: {initiator}\n")
    
    # 开始选举
    node_states[initiator].start_election()
    
    # 模拟令牌传递
    token = {
        'initiator': initiator,
        'max_id': max(ring_nodes),
        'candidates': [initiator],
        'path': []
    }
    
    # 模拟令牌在环中传递
    current_position = ring_nodes.index(initiator)
    for i in range(len(ring_nodes)):
        current_node = ring_nodes[current_position]
        node_states[current_node].receive_token(token, ring_nodes[current_position - 1])
        current_position = (current_position + 1) % len(ring_nodes)
        
        if current_node == initiator:
            break
        
        print()

demo_ring_algorithm()
```

### 3. 投票算法

```python
class VotingAlgorithm:
    """投票算法（Voting Algorithm）"""
    
    def __init__(self, node_id: str, all_nodes: list, voting_threshold: float = 0.5):
        self.node_id = node_id
        self.all_nodes = all_nodes
        self.voting_threshold = voting_threshold
        self.votes_received = set()
        self.votes_sent = set()
        self.is_leader = False
        self.election_active = False
    
    def request_vote(self, candidate_id: str):
        """请求投票"""
        if candidate_id not in self.votes_sent:
            self.votes_sent.add(candidate_id)
            print(f"Node {self.node_id} sending vote request to all nodes")
            
            # 向所有其他节点发送投票请求
            for node in self.all_nodes:
                if node != self.node_id:
                    self.send_vote_request(node, candidate_id)
    
    def send_vote_request(self, target_id: str, candidate_id: str):
        """发送投票请求"""
        print(f"Node {self.node_id} requesting vote from {target_id} for candidate {candidate_id}")
        
        # 在实际实现中，这里会发送网络请求
        # target_node.process_vote_request(candidate_id, self.node_id)
    
    def process_vote_request(self, candidate_id: str, requester_id: str):
        """处理投票请求"""
        # 简单的投票策略：总是投票给第一个请求者
        # 实际实现中可能考虑节点性能、可用性等
        
        print(f"Node {self.node_id} processing vote request from {requester_id}")
        
        # 投票决定逻辑
        vote_decision = self.make_voting_decision(candidate_id, requester_id)
        
        if vote_decision:
            self.send_vote(requester_id, candidate_id)
    
    def make_voting_decision(self, candidate_id: str, requester_id: str) -> bool:
        """做出投票决定"""
        # 投票策略：
        # 1. 优先投票给ID较大的节点
        # 2. 避免重复投票给同一候选者
        
        if candidate_id in self.votes_received:
            return False
        
        if candidate_id > self.node_id:
            return True
        
        return False
    
    def send_vote(self, requester_id: str, candidate_id: str):
        """发送投票"""
        print(f"Node {self.node_id} voting for {candidate_id}")
        
        # 在实际实现中，这里会发送投票
        # requester_node.process_vote(candidate_id, self.node_id)
    
    def process_vote(self, voter_id: str, candidate_id: str):
        """处理投票"""
        if candidate_id == self.node_id:
            self.votes_received.add(voter_id)
            print(f"Node {self.node_id} received vote from {voter_id}")
            
            # 检查是否获得足够票数
            self.check_election_result()
    
    def check_election_result(self):
        """检查选举结果"""
        total_nodes = len(self.all_nodes)
        required_votes = int(total_nodes * self.voting_threshold) + 1
        
        if len(self.votes_received) >= required_votes:
            self.is_leader = True
            print(f"Node {self.node_id} ELECTED as LEADER with {len(self.votes_received)}/{total_nodes} votes")

# 投票算法演示
def demo_voting_algorithm():
    """投票算法演示"""
    nodes = ['node1', 'node2', 'node3', 'node4', 'node5']
    
    print("=== Voting Algorithm Demo ===\n")
    
    node_states = {}
    for node_id in nodes:
        node_states[node_id] = VotingAlgorithm(node_id, nodes)
    
    # 所有节点同时请求投票
    print("All nodes requesting votes simultaneously...")
    for node_id in nodes:
        node_states[node_id].request_vote(node_id)
    print()
    
    # 模拟投票过程
    print("Voting process simulation:")
    for requester in nodes:
        for voter in nodes:
            if requester != voter:
                candidate_id = requester
                node_states[voter].process_vote_request(candidate_id, requester)
                node_states[voter].send_vote(voter, candidate_id)
                node_states[candidate_id].process_vote(voter, candidate_id)
    print()
    
    # 检查选举结果
    print("Election results:")
    for node_id in nodes:
        if node_states[node_id].is_leader:
            print(f"LEADER: {node_id}")
        else:
            print(f"Follower: {node_id} (votes received: {len(node_states[node_id].votes_received)})")

demo_voting_algorithm()
```

## 基于ZooKeeper的领导选举

```python
import kazoo
from kazoo.client import KazooClient
from kazoo.recipe.lock import Lock
import uuid
import time
import threading
from contextlib import contextmanager

class ZooKeeperLeaderElection:
    """基于ZooKeeper的领导选举"""
    
    def __init__(self, hosts: str = 'localhost:2181', election_path: str = '/leader_election'):
        self.client = KazooClient(hosts=hosts, timeout=30.0)
        self.client.start()
        self.election_path = election_path
        self.node_id = str(uuid.uuid4())
        self.is_leader = False
        self.leader_callback = None
        self.follower_callback = None
        
        # 确保选举路径存在
        self.client.ensure_path(election_path)
        
        # 注册监听器
        self.setup_watchers()
    
    def setup_watchers(self):
        """设置监听器"""
        @self.client.ChildrenWatch(self.election_path)
        def watch_children(children):
            """监听子节点变化"""
            self.process_leader_change(children)
    
    def process_leader_change(self, children: list):
        """处理领导节点变化"""
        if not children:
            print(f"Node {self.node_id}: No leader candidates available")
            return
        
        # 排序获取最小节点（领导者）
        children.sort()
        current_leader = children[0]
        
        if current_leader.startswith('candidate_'):
            leader_node_id = current_leader.split('_')[1]
            
            if leader_node_id == self.node_id:
                if not self.is_leader:
                    print(f"Node {self.node_id}: BECOMING LEADER")
                    self.is_leader = True
                    if self.leader_callback:
                        self.leader_callback()
            else:
                if self.is_leader:
                    print(f"Node {self.node_id}: BECOMING FOLLOWER (new leader: {leader_node_id})")
                    self.is_leader = False
                    if self.follower_callback:
                        self.follower_callback()
    
    def run_for_leader(self, data: str = b""):
        """竞选领导者"""
        candidate_name = f"candidate_{self.node_id}"
        candidate_path = f"{self.election_path}/{candidate_name}"
        
        try:
            # 创建临时顺序节点
            self.client.create(
                candidate_path,
                value=data,
                ephemeral=True,
                sequence=True
            )
            
            print(f"Node {self.node_id} created candidate path: {candidate_path}")
            
            # 立即检查是否成为领导者
            children = self.client.get_children(self.election_path)
            children.sort()
            
            if candidate_path.split('/')[-1] == children[0]:
                self.become_leader()
            else:
                self.become_follower()
                
        except Exception as e:
            print(f"Error running for leader: {e}")
    
    def become_leader(self):
        """成为领导者"""
        self.is_leader = True
        print(f"Node {self.node_id} is now the LEADER")
        
        if self.leader_callback:
            self.leader_callback()
    
    def become_follower(self):
        """成为跟随者"""
        self.is_leader = False
        print(f"Node {self.node_id} is now a FOLLOWER")
        
        if self.follower_callback:
            self.follower_callback()
    
    def get_current_leader(self) -> tuple:
        """获取当前领导者信息"""
        try:
            children = self.client.get_children(self.election_path)
            children.sort()
            
            if not children:
                return None, None
            
            leader_path = f"{self.election_path}/{children[0]}"
            data, stat = self.client.get(leader_path)
            
            leader_id = children[0].split('_')[1]
            return leader_id, data
            
        except Exception as e:
            print(f"Error getting current leader: {e}")
            return None, None
    
    def set_leader_callback(self, callback):
        """设置领导者回调函数"""
        self.leader_callback = callback
    
    def set_follower_callback(self, callback):
        """设置跟随者回调函数"""
        self.follower_callback = callback
    
    def shutdown(self):
        """关闭选举"""
        try:
            self.client.stop()
            self.client.close()
        except Exception as e:
            print(f"Error shutting down: {e}")

# ZooKeeper领导者选举示例
def demo_zookeeper_leader_election():
    """ZooKeeper领导选举演示"""
    
    # 创建多个节点实例（实际中在不同进程中运行）
    nodes = []
    
    # 模拟3个节点竞选
    for i in range(3):
        election = ZooKeeperLeaderElection()
        node_id = election.node_id
        
        # 设置回调函数
        def on_leader():
            print(f"✓ Node {node_id} is now leading the cluster")
        
        def on_follower():
            print(f"- Node {node_id} is now following the cluster")
        
        election.set_leader_callback(on_leader)
        election.set_follower_callback(on_follower)
        
        nodes.append((node_id, election))
    
    print(f"Created {len(nodes)} election nodes")
    
    # 所有节点同时开始选举
    for node_id, election in nodes:
        election.run_for_leader(data=f"Node {node_id}".encode())
    
    # 等待选举完成
    time.sleep(2)
    
    # 获取当前领导者
    leader_id, leader_data = nodes[0][1].get_current_leader()
    if leader_id:
        print(f"\nCurrent Leader: {leader_id}")
        print(f"Leader Data: {leader_data}")
    
    # 清理
    for node_id, election in nodes:
        election.shutdown()

# 由于需要实际的ZooKeeper服务，这里只是代码示例
print("=== ZooKeeper Leader Election Implementation ===")
print("(Requires running ZooKeeper service)")
```

## 基于Redis的领导选举

```python
import redis
import time
import uuid
import threading
import json
from datetime import datetime, timedelta

class RedisLeaderElection:
    """基于Redis的领导选举"""
    
    def __init__(self, redis_host: str = 'localhost', redis_port: int = 6379, 
                 election_key: str = 'leader_election', heartbeat_key: str = 'leader_heartbeat'):
        self.redis_client = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
        self.election_key = election_key
        self.heartbeat_key = heartbeat_key
        self.node_id = str(uuid.uuid4())
        self.is_leader = False
        self.heartbeat_interval = 5.0  # 心跳间隔（秒）
        self.heartbeat_timeout = 15.0  # 心跳超时（秒）
        self.heartbeat_thread = None
        self.stop_heartbeat = threading.Event()
        
        # 回调函数
        self.leader_callback = None
        self.follower_callback = None
    
    def become_candidate(self, candidate_data: dict = None):
        """成为候选者"""
        if candidate_data is None:
            candidate_data = {
                'node_id': self.node_id,
                'timestamp': time.time(),
                'version': 1
            }
        
        try:
            # 将自己加入候选者列表
            pipeline = self.redis_client.pipeline()
            pipeline.hset(self.election_key, self.node_id, json.dumps(candidate_data))
            pipeline.expire(self.election_key, 300)  # 5分钟过期
            pipeline.execute()
            
            print(f"Node {self.node_id} became candidate")
            
            # 开始选举过程
            self.start_election()
            
        except redis.RedisError as e:
            print(f"Error becoming candidate: {e}")
    
    def start_election(self):
        """开始选举"""
        print(f"Node {self.node_id} starting election")
        
        try:
            # 获取所有候选者
            candidates = self.redis_client.hgetall(self.election_key)
            
            if not candidates:
                print(f"No candidates available for election")
                return
            
            # 解析候选者数据并排序
            candidate_list = []
            for node_id, data_str in candidates.items():
                try:
                    data = json.loads(data_str)
                    candidate_list.append((node_id, data))
                except json.JSONDecodeError:
                    print(f"Invalid data for candidate {node_id}")
                    continue
            
            # 按节点ID排序（简化版本，实际中可以按性能、负载等排序）
            candidate_list.sort(key=lambda x: x[0])
            
            # 检查是否自己是最优候选者
            if candidate_list[0][0] == self.node_id:
                self.claim_leadership()
            else:
                # 等待现任领导者过期或主动让位
                self.wait_for_leadership_opportunity()
                
        except redis.RedisError as e:
            print(f"Error starting election: {e}")
    
    def claim_leadership(self):
        """声明领导地位"""
        try:
            leader_data = {
                'node_id': self.node_id,
                'timestamp': time.time(),
                'started_at': datetime.now().isoformat(),
                'version': 1
            }
            
            # 使用SET命令原子性地设置领导者
            result = self.redis_client.set(
                self.heartbeat_key,
                json.dumps(leader_data),
                ex=60,  # 1分钟过期
                nx=True  # 只有在键不存在时才设置
            )
            
            if result:
                print(f"Node {self.node_id} CLAIMED LEADERSHIP")
                self.is_leader = True
                self.start_heartbeat()
                
                if self.leader_callback:
                    self.leader_callback()
            else:
                print(f"Node {self.node_id} failed to claim leadership")
                self.become_follower()
                
        except redis.RedisError as e:
            print(f"Error claiming leadership: {e}")
    
    def become_follower(self):
        """成为跟随者"""
        self.is_leader = False
        self.stop_heartbeat.set()
        
        if self.heartbeat_thread:
            self.heartbeat_thread.join()
        
        print(f"Node {self.node_id} became FOLLOWER")
        
        if self.follower_callback:
            self.follower_callback()
    
    def start_heartbeat(self):
        """开始心跳"""
        self.stop_heartbeat.clear()
        self.heartbeat_thread = threading.Thread(target=self.heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()
    
    def heartbeat_loop(self):
        """心跳循环"""
        while not self.stop_heartbeat.wait(self.heartbeat_interval):
            try:
                # 更新领导者心跳
                leader_data = {
                    'node_id': self.node_id,
                    'timestamp': time.time(),
                    'heartbeat_count': getattr(self, 'heartbeat_count', 0) + 1
                }
                
                self.redis_client.set(
                    self.heartbeat_key,
                    json.dumps(leader_data),
                    ex=int(self.heartbeat_timeout * 2)  # 设置较长过期时间
                )
                
                self.heartbeat_count = leader_data['heartbeat_count']
                
            except redis.RedisError as e:
                print(f"Heartbeat error: {e}")
                break
    
    def monitor_leader(self):
        """监控当前领导者"""
        try:
            leader_data_str = self.redis_client.get(self.heartbeat_key)
            
            if not leader_data_str:
                # 没有领导者，触发选举
                print("No leader detected, starting election")
                self.start_election()
                return None
            
            try:
                leader_data = json.loads(leader_data_str)
                leader_id = leader_data.get('node_id')
                
                # 检查心跳是否过期
                last_timestamp = leader_data.get('timestamp', 0)
                if time.time() - last_timestamp > self.heartbeat_timeout:
                    print(f"Leader heartbeat expired, starting election")
                    self.start_election()
                    return None
                
                return leader_data
                
            except json.JSONDecodeError:
                print("Invalid leader data format")
                return None
                
        except redis.RedisError as e:
            print(f"Error monitoring leader: {e}")
            return None
    
    def wait_for_leadership_opportunity(self):
        """等待领导机会"""
        def monitor_thread():
            while not self.is_leader:
                leader_data = self.monitor_leader()
                
                if leader_data is None:
                    # 领导者过期，重新选举
                    self.start_election()
                    break
                
                time.sleep(2)  # 等待2秒后再次检查
        
        monitor_thread_obj = threading.Thread(target=monitor_thread, daemon=True)
        monitor_thread_obj.start()
    
    def set_leader_callback(self, callback):
        """设置领导者回调"""
        self.leader_callback = callback
    
    def set_follower_callback(self, callback):
        """设置跟随者回调"""
        self.follower_callback = callback
    
    def get_leader_info(self) -> dict:
        """获取领导者信息"""
        try:
            leader_data_str = self.redis_client.get(self.heartbeat_key)
            if leader_data_str:
                return json.loads(leader_data_str)
            return {}
        except (redis.RedisError, json.JSONDecodeError):
            return {}
    
    def shutdown(self):
        """关闭选举"""
        self.stop_heartbeat.set()
        
        if self.heartbeat_thread:
            self.heartbeat_thread.join(timeout=5)
        
        if self.is_leader:
            # 领导者主动放弃领导地位
            self.redis_client.delete(self.heartbeat_key)
        
        # 清理候选者记录
        self.redis_client.hdel(self.election_key, self.node_id)

# Redis领导选举示例
def demo_redis_leader_election():
    """Redis领导选举演示"""
    
    # 创建节点
    nodes = []
    
    def create_node(node_index):
        election = RedisLeaderElection()
        
        def on_leader():
            print(f"✓ Node {election.node_id} (Node {node_index}) is now leading")
        
        def on_follower():
            print(f"- Node {election.node_id} (Node {node_index}) is now following")
        
        election.set_leader_callback(on_leader)
        election.set_follower_callback(on_follower)
        
        return election
    
    # 模拟3个节点
    print("=== Redis Leader Election Demo ===")
    print("Creating 3 election nodes...\n")
    
    for i in range(3):
        node = create_node(i + 1)
        nodes.append(node)
        
        # 每个节点成为候选者
        candidate_data = {
            'node_id': node.node_id,
            'node_index': i + 1,
            'capabilities': ['high_cpu', 'low_latency'],
            'timestamp': time.time()
        }
        
        node.become_candidate(candidate_data)
    
    print("All nodes became candidates, starting election...\n")
    
    # 监控选举过程
    try:
        for i in range(10):  # 监控10秒
            time.sleep(1)
            
            # 打印当前状态
            leader_info = nodes[0].get_leader_info()
            if leader_info:
                print(f"Current leader: {leader_info.get('node_id', 'unknown')}")
            else:
                print("No leader detected")
    except KeyboardInterrupt:
        print("\nShutting down...")
    
    # 清理
    for node in nodes:
        node.shutdown()

# 由于需要实际的Redis服务，这里只是代码示例
print("=== Redis Leader Election Implementation ===")
print("(Requires running Redis service)")
```

## 基于Raft的领导选举

```python
class RaftLeaderElection:
    """基于Raft算法的领导选举"""
    
    def __init__(self, node_id: str, all_nodes: list):
        self.node_id = node_id
        self.all_nodes = all_nodes
        self.current_term = 0
        self.voted_for = None
        self.state = 'follower'  # follower, candidate, leader
        
        # 选举相关
        self.election_timeout = self.random_election_timeout()
        self.last_heartbeat = time.time()
        self.votes_received = set()
        
        # 领导者相关
        self.next_index = {}  # 为每个跟随者维护下一个日志索引
        self.match_index = {}  # 为每个跟随者维护已匹配的最高索引
        
        # 回调函数
        self.on_state_change = None
        self.on_leader_elected = None
        self.on_follower_elected = None
        
    def random_election_timeout(self):
        """生成随机选举超时时间（150-300ms）"""
        import random
        return 0.15 + random.random() * 0.15
    
    def start_election(self):
        """开始选举"""
        if self.state == 'leader':
            return
        
        print(f"Node {self.node_id} starting election for term {self.current_term + 1}")
        
        # 转换为候选者状态
        self.state = 'candidate'
        self.current_term += 1
        self.voted_for = self.node_id
        self.votes_received = {self.node_id}  # 给自己投票
        self.last_heartbeat = time.time()
        
        if self.on_state_change:
            self.on_state_change('candidate', self.current_term)
        
        # 向所有其他节点发送投票请求
        self.request_votes()
        
        # 设置选举超时
        self.schedule_election_timeout()
    
    def request_votes(self):
        """请求投票"""
        request = {
            'term': self.current_term,
            'candidate_id': self.node_id,
            'last_log_index': 0,  # 简化版，实际应包含日志信息
            'last_log_term': 0
        }
        
        for node in self.all_nodes:
            if node != self.node_id:
                self.send_vote_request(node, request)
    
    def send_vote_request(self, target_id: str, request: dict):
        """发送投票请求"""
        print(f"Node {self.node_id} sending vote request to {target_id}")
        
        # 在实际实现中，这里会发送网络请求
        # target_node.process_vote_request(request)
    
    def process_vote_request(self, request: dict) -> dict:
        """处理投票请求"""
        term = request['term']
        candidate_id = request['candidate_id']
        
        response = {
            'term': self.current_term,
            'vote_granted': False
        }
        
        # 规则1：如果请求的term小于currentTerm，则拒绝
        if term < self.current_term:
            print(f"Node {self.node_id} rejects vote for {candidate_id}: stale term")
            return response
        
        # 规则2：如果voted_for为空或为candidate_id，且候选者日志至少和自己一样新，则投票
        if (self.voted_for is None or self.voted_for == candidate_id):
            # 简化的日志比较，实际需要比较日志索引和term
            response['vote_granted'] = True
            self.voted_for = candidate_id
            print(f"Node {self.node_id} grants vote to {candidate_id}")
        else:
            print(f"Node {self.node_id} rejects vote for {candidate_id}: already voted")
        
        return response
    
    def process_vote_response(self, response: dict):
        """处理投票响应"""
        if self.state != 'candidate':
            return
        
        term = response['term']
        vote_granted = response['vote_granted']
        
        # 如果响应中的term大于当前term，转换为跟随者
        if term > self.current_term:
            self.become_follower(term)
            return
        
        # 如果获得大多数投票，成为领导者
        if vote_granted:
            self.votes_received.add(response['voter_id'])
            
            majority = len(self.all_nodes) // 2 + 1
            if len(self.votes_received) >= majority:
                self.become_leader()
    
    def become_leader(self):
        """成为领导者"""
        if self.state != 'candidate':
            return
        
        print(f"Node {self.node_id} ELECTED LEADER for term {self.current_term}")
        
        self.state = 'leader'
        
        # 初始化领导者状态
        for node in self.all_nodes:
            if node != self.node_id:
                self.next_index[node] = len(self.all_nodes)  # 简化的nextIndex
                self.match_index[node] = 0
        
        if self.on_state_change:
            self.on_state_change('leader', self.current_term)
        
        if self.on_leader_elected:
            self.on_leader_elected()
        
        # 开始发送心跳
        self.start_sending_heartbeats()
    
    def become_follower(self, term: int = None):
        """成为跟随者"""
        if term:
            self.current_term = term
        
        self.state = 'follower'
        self.voted_for = None
        self.votes_received.clear()
        
        print(f"Node {self.node_id} became FOLLOWER for term {self.current_term}")
        
        if self.on_state_change:
            self.on_state_change('follower', self.current_term)
        
        if self.on_follower_elected:
            self.on_follower_elected()
    
    def start_sending_heartbeats(self):
        """开始发送心跳"""
        def heartbeat_loop():
            while self.state == 'leader':
                self.send_heartbeat_to_all()
                time.sleep(0.05)  # 心跳间隔50ms
        
        heartbeat_thread = threading.Thread(target=heartbeat_loop, daemon=True)
        heartbeat_thread.start()
    
    def send_heartbeat_to_all(self):
        """向所有节点发送心跳"""
        heartbeat = {
            'term': self.current_term,
            'leader_id': self.node_id,
            'prev_log_index': -1,  # 简化版
            'prev_log_term': 0
        }
        
        for node in self.all_nodes:
            if node != self.node_id:
                self.send_heartbeat(node, heartbeat)
    
    def send_heartbeat(self, target_id: str, heartbeat: dict):
        """发送心跳"""
        print(f"Node {self.node_id} sending heartbeat to {target_id}")
        
        # 在实际实现中，这里会发送网络请求
        # target_node.process_heartbeat(heartbeat)
    
    def process_heartbeat(self, heartbeat: dict) -> dict:
        """处理心跳"""
        term = heartbeat['term']
        leader_id = heartbeat['leader_id']
        
        response = {
            'term': self.current_term,
            'success': False
        }
        
        # 如果心跳中的term小于当前term，拒绝
        if term < self.current_term:
            print(f"Node {self.node_id} rejects heartbeat: stale term")
            return response
        
        # 更新状态
        self.last_heartbeat = time.time()
        self.current_term = term
        
        # 如果当前是候选者或领导者，转换为跟随者
        if self.state in ['candidate', 'leader']:
            self.become_follower(term)
        
        response['success'] = True
        return response
    
    def schedule_election_timeout(self):
        """设置选举超时"""
        def election_timeout_check():
            while self.state == 'candidate':
                time.sleep(0.01)  # 检查间隔10ms
                
                if time.time() - self.last_heartbeat > self.election_timeout:
                    print(f"Node {self.node_id} election timeout, restarting election")
                    self.start_election()
                    break
        
        timeout_thread = threading.Thread(target=election_timeout_check, daemon=True)
        timeout_thread.start()
    
    def step_down(self, term: int):
        """降级为跟随者"""
        if term > self.current_term:
            self.become_follower(term)
    
    def get_state(self) -> dict:
        """获取当前状态"""
        return {
            'node_id': self.node_id,
            'state': self.state,
            'current_term': self.current_term,
            'voted_for': self.voted_for,
            'votes_received': len(self.votes_received) if self.state == 'candidate' else 0,
            'last_heartbeat': self.last_heartbeat,
            'election_timeout': self.election_timeout
        }

# Raft算法演示
def demo_raft_leader_election():
    """Raft领导选举演示"""
    nodes = ['node1', 'node2', 'node3', 'node4', 'node5']
    
    print("=== Raft Leader Election Demo ===")
    print(f"Cluster: {nodes}")
    print()
    
    # 创建节点
    node_states = {}
    for node_id in nodes:
        node_states[node_id] = RaftLeaderElection(node_id, nodes)
    
    # 设置状态变化回调
    def setup_callbacks(node_id):
        election = node_states[node_id]
        
        def on_state_change(state, term):
            print(f"Node {node_id} state changed to {state} (term {term})")
        
        election.on_state_change = on_state_change
    
    for node_id in nodes:
        setup_callbacks(node_id)
    
    # 随机选择几个节点开始选举
    import random
    random.seed(42)
    
    election_starters = random.sample(nodes, 2)
    print(f"Nodes starting elections: {election_starters}\n")
    
    # 开始选举
    for node_id in election_starters:
        node_states[node_id].start_election()
    
    # 监控选举过程
    try:
        for i in range(5):
            time.sleep(1)
            
            # 检查当前状态
            leader_count = sum(1 for election in node_states.values() if election.state == 'leader')
            candidates_count = sum(1 for election in node_states.values() if election.state == 'candidate')
            
            print(f"Time {i+1}s: {leader_count} leader(s), {candidates_count} candidate(s)")
            
            if leader_count == 1:
                leader_node = next(election.node_id for election in node_states.values() if election.state == 'leader')
                print(f"Leader elected: {leader_node}")
                break
                
    except KeyboardInterrupt:
        print("\nDemo interrupted")
    
    # 打印最终状态
    print("\n=== Final State ===")
    for node_id, election in node_states.items():
        state_info = election.get_state()
        print(f"Node {node_id}: {state_info['state']} (term {state_info['current_term']})")

demo_raft_leader_election()
```

## 心跳机制

```python
import time
import threading
import json
from dataclasses import dataclass, asdict
from typing import Dict, List, Callable, Optional
from datetime import datetime, timedelta

@dataclass
class HeartbeatMessage:
    """心跳消息"""
    node_id: str
    timestamp: float
    sequence_number: int
    cluster_id: str
    load_metrics: Dict[str, float]
    status: str  # healthy, degraded, critical

class HeartbeatManager:
    """心跳管理器"""
    
    def __init__(self, node_id: str, cluster_id: str, heartbeat_interval: float = 5.0):
        self.node_id = node_id
        self.cluster_id = cluster_id
        self.heartbeat_interval = heartbeat_interval
        self.sequence_number = 0
        self.is_running = False
        self.heartbeat_thread = None
        self.last_heartbeat = time.time()
        
        # 心跳存储
        self.node_heartbeats: Dict[str, HeartbeatMessage] = {}
        
        # 回调函数
        self.on_node_failure: Optional[Callable[[str], None]] = None
        self.on_node_recovery: Optional[Callable[[str], None]] = None
        self.on_cluster_health_change: Optional[Callable[[Dict], None]] = None
    
    def start_heartbeat(self):
        """开始发送心跳"""
        if self.is_running:
            return
        
        self.is_running = True
        self.heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        self.heartbeat_thread.start()
        
        print(f"Node {self.node_id} started heartbeat service")
    
    def stop_heartbeat(self):
        """停止心跳"""
        self.is_running = False
        
        if self.heartbeat_thread:
            self.heartbeat_thread.join(timeout=5)
        
        print(f"Node {self.node_id} stopped heartbeat service")
    
    def _heartbeat_loop(self):
        """心跳循环"""
        while self.is_running:
            try:
                self.send_heartbeat()
                time.sleep(self.heartbeat_interval)
            except Exception as e:
                print(f"Heartbeat error: {e}")
                time.sleep(1)
    
    def send_heartbeat(self):
        """发送心跳"""
        self.sequence_number += 1
        
        # 模拟负载指标
        import psutil
        load_metrics = {
            'cpu_percent': psutil.cpu_percent(),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_usage': psutil.disk_usage('/').percent,
            'network_io': self._get_network_io()
        }
        
        heartbeat = HeartbeatMessage(
            node_id=self.node_id,
            timestamp=time.time(),
            sequence_number=self.sequence_number,
            cluster_id=self.cluster_id,
            load_metrics=load_metrics,
            status='healthy'
        )
        
        # 在实际实现中，这里会发送到其他节点或中央存储
        self._broadcast_heartbeat(heartbeat)
        
        self.last_heartbeat = time.time()
    
    def _get_network_io(self) -> float:
        """获取网络IO（简化版）"""
        try:
            net_io = psutil.net_io_counters()
            return net_io.bytes_sent + net_io.bytes_recv
        except:
            return 0.0
    
    def _broadcast_heartbeat(self, heartbeat: HeartbeatMessage):
        """广播心跳"""
        # 这里应该是网络广播或发送到中央存储
        print(f"Heartbeat {heartbeat.sequence_number}: {heartbeat.node_id} -> "
              f"CPU: {heartbeat.load_metrics['cpu_percent']:.1f}%, "
              f"Mem: {heartbeat.load_metrics['memory_percent']:.1f}%")
    
    def receive_heartbeat(self, heartbeat: HeartbeatMessage):
        """接收心跳"""
        self.node_heartbeats[heartbeat.node_id] = heartbeat
        
        # 检查节点状态
        self._check_node_health(heartbeat.node_id)
    
    def _check_node_health(self, node_id: str):
        """检查节点健康状态"""
        if node_id not in self.node_heartbeats:
            return
        
        heartbeat = self.node_heartbeats[node_id]
        time_since_heartbeat = time.time() - heartbeat.timestamp
        
        # 健康检查阈值
        health_threshold = self.heartbeat_interval * 3  # 3个心跳周期
        
        if time_since_heartbeat > health_threshold:
            if node_id in self.node_heartbeats:
                # 节点被认为失败
                print(f"Node {node_id} marked as FAILED (no heartbeat for {time_since_heartbeat:.1f}s)")
                
                if self.on_node_failure:
                    self.on_node_failure(node_id)
                
                # 从活跃节点列表中移除
                del self.node_heartbeats[node_id]
        else:
            # 节点健康
            if getattr(self, '_node_was_failed', {}).get(node_id, False):
                print(f"Node {node_id} recovered")
                
                if self.on_node_recovery:
                    self.on_node_recovery(node_id)
    
    def get_cluster_health(self) -> Dict:
        """获取集群健康状态"""
        current_time = time.time()
        active_nodes = []
        failed_nodes = []
        
        for node_id, heartbeat in self.node_heartbeats.items():
            time_since_heartbeat = current_time - heartbeat.timestamp
            
            if time_since_heartbeat < self.heartbeat_interval * 3:
                active_nodes.append({
                    'node_id': node_id,
                    'last_heartbeat': heartbeat.timestamp,
                    'load_metrics': heartbeat.load_metrics,
                    'sequence_number': heartbeat.sequence_number
                })
            else:
                failed_nodes.append({
                    'node_id': node_id,
                    'last_heartbeat': heartbeat.timestamp,
                    'failed_duration': time_since_heartbeat
                })
        
        health_status = {
            'cluster_id': self.cluster_id,
            'total_nodes': len(active_nodes) + len(failed_nodes),
            'active_nodes': len(active_nodes),
            'failed_nodes': len(failed_nodes),
            'active_nodes_list': active_nodes,
            'failed_nodes_list': failed_nodes,
            'timestamp': current_time
        }
        
        if self.on_cluster_health_change:
            self.on_cluster_health_change(health_status)
        
        return health_status
    
    def set_node_failure_callback(self, callback: Callable[[str], None]):
        """设置节点失败回调"""
        self.on_node_failure = callback
    
    def set_node_recovery_callback(self, callback: Callable[[str], None]):
        """设置节点恢复回调"""
        self.on_node_recovery = callback
    
    def set_cluster_health_callback(self, callback: Callable[[Dict], None]):
        """设置集群健康状态回调"""
        self.on_cluster_health_change = callback

# 心跳机制演示
def demo_heartbeat_mechanism():
    """心跳机制演示"""
    
    print("=== Heartbeat Mechanism Demo ===")
    
    # 创建心跳管理器
    nodes = ['node1', 'node2', 'node3', 'node4', 'node5']
    heartbeat_managers = {}
    
    for node_id in nodes:
        manager = HeartbeatManager(node_id, 'cluster1', heartbeat_interval=1.0)
        heartbeat_managers[node_id] = manager
        
        # 设置回调
        manager.set_node_failure_callback(lambda nid: print(f"ALERT: Node {nid} failed!"))
        manager.set_node_recovery_callback(lambda nid: print(f"INFO: Node {nid} recovered"))
        manager.set_cluster_health_callback(lambda health: print(f"Cluster health: {health['active_nodes']}/{health['total_nodes']} nodes active"))
        
        # 开始心跳
        manager.start_heartbeat()
    
    print(f"Started heartbeat for {len(nodes)} nodes")
    
    # 模拟心跳接收
    try:
        for cycle in range(10):
            print(f"\n--- Cycle {cycle + 1} ---")
            
            # 模拟随机节点发送心跳给其他节点
            for sender_id, sender_manager in heartbeat_managers.items():
                # 模拟发送心跳给其他节点（广播）
                heartbeat = HeartbeatMessage(
                    node_id=sender_id,
                    timestamp=time.time(),
                    sequence_number=cycle + 1,
                    cluster_id='cluster1',
                    load_metrics={
                        'cpu_percent': 20 + cycle * 5,
                        'memory_percent': 40 + cycle * 2
                    },
                    status='healthy'
                )
                
                # 接收心跳
                for receiver_id, receiver_manager in heartbeat_managers.items():
                    if receiver_id != sender_id:
                        receiver_manager.receive_heartbeat(heartbeat)
            
            # 显示集群健康状态
            if cycle % 3 == 2:  # 每3个周期显示一次
                cluster_health = heartbeat_managers['node1'].get_cluster_health()
                print(f"Cluster: {cluster_health['active_nodes']} active, {cluster_health['failed_nodes']} failed")
            
            time.sleep(1)
            
    except KeyboardInterrupt:
        print("\nStopping heartbeat simulation...")
    
    finally:
        # 停止所有心跳
        for manager in heartbeat_managers.values():
            manager.stop_heartbeat()
    
    print("Heartbeat demo completed")

# 运行心跳演示
if __name__ == "__main__":
    demo_heartbeat_mechanism()
```

## Python完整实现示例

```python
class ComprehensiveLeaderElection:
    """综合领导选举系统"""
    
    def __init__(self, node_id: str, cluster_nodes: list, election_backend: str = 'memory'):
        self.node_id = node_id
        self.cluster_nodes = cluster_nodes
        self.election_backend = election_backend
        
        # 选举状态
        self.state = 'follower'  # follower, candidate, leader
        self.current_term = 0
        self.voted_for = None
        self.leader_id = None
        
        # 选举配置
        self.election_timeout_min = 150  # ms
        self.election_timeout_max = 300  # ms
        self.heartbeat_interval = 50  # ms
        
        # 统计信息
        self.election_count = 0
        self.heartbeat_count = 0
        self.last_heartbeat_received = time.time()
        
        # 后端实现
        if election_backend == 'memory':
            self.backend = MemoryElectionBackend(node_id, cluster_nodes)
        elif election_backend == 'redis':
            self.backend = RedisElectionBackend(node_id, cluster_nodes)
        elif election_backend == 'zookeeper':
            self.backend = ZooKeeperElectionBackend(node_id, cluster_nodes)
        else:
            raise ValueError(f"Unknown election backend: {election_backend}")
        
        # 线程控制
        self.running = False
        self.threads = []
        
        # 回调函数
        self.on_leader_change = None
        self.on_state_change = None
    
    def start(self):
        """启动选举系统"""
        if self.running:
            return
        
        self.running = True
        
        # 启动后端
        self.backend.start()
        
        # 启动选举循环
        election_thread = threading.Thread(target=self._election_loop, daemon=True)
        election_thread.start()
        self.threads.append(election_thread)
        
        # 启动心跳监听
        heartbeat_thread = threading.Thread(target=self._heartbeat_loop, daemon=True)
        heartbeat_thread.start()
        self.threads.append(heartbeat_thread)
        
        print(f"Node {self.node_id} leader election system started")
    
    def stop(self):
        """停止选举系统"""
        self.running = False
        
        # 停止后端
        self.backend.stop()
        
        # 等待线程结束
        for thread in self.threads:
            thread.join(timeout=5)
        
        print(f"Node {self.node_id} leader election system stopped")
    
    def _election_loop(self):
        """选举循环"""
        import random
        
        while self.running:
            try:
                current_time = time.time()
                
                # 检查选举超时
                time_since_heartbeat = current_time - self.last_heartbeat_received
                timeout_range = self.election_timeout_max / 1000.0
                
                if time_since_heartbeat > timeout_range:
                    self._start_election()
                
                time.sleep(0.01)  # 10ms检查间隔
                
            except Exception as e:
                print(f"Election loop error: {e}")
                time.sleep(1)
    
    def _heartbeat_loop(self):
        """心跳监听循环"""
        while self.running:
            try:
                # 监听其他节点的心跳
                heartbeats = self.backend.get_heartbeats()
                
                current_leader = None
                latest_heartbeat = 0
                
                for heartbeat in heartbeats:
                    if heartbeat.timestamp > latest_heartbeat:
                        latest_heartbeat = heartbeat.timestamp
                        current_leader = heartbeat.node_id
                
                if current_leader and current_leader != self.leader_id:
                    self._on_leader_detected(current_leader)
                elif current_leader:
                    self.last_heartbeat_received = time.time()
                
                time.sleep(self.heartbeat_interval / 1000.0)
                
            except Exception as e:
                print(f"Heartbeat loop error: {e}")
                time.sleep(1)
    
    def _start_election(self):
        """开始选举"""
        if self.state == 'leader':
            return
        
        print(f"Node {self.node_id} starting election for term {self.current_term + 1}")
        
        self.state = 'candidate'
        self.current_term += 1
        self.voted_for = self.node_id
        self.election_count += 1
        
        if self.on_state_change:
            self.on_state_change('candidate', self.current_term)
        
        # 请求投票
        votes_received = {self.node_id}  # 自己的票
        total_votes = len(self.cluster_nodes)
        majority = total_votes // 2 + 1
        
        # 简化的投票过程：等待其他节点响应
        time.sleep(0.2)  # 等待200ms
        
        # 模拟获得投票（在实际实现中需要网络通信）
        for node_id in self.cluster_nodes:
            if node_id != self.node_id:
                vote_granted = self._simulate_vote_grant(node_id)
                if vote_granted:
                    votes_received.add(node_id)
        
        # 检查是否获得多数票
        if len(votes_received) >= majority:
            self._become_leader()
        else:
            # 选举失败，回到跟随者状态
            self._become_follower()
    
    def _simulate_vote_grant(self, node_id: str) -> bool:
        """模拟投票决定"""
        # 简化逻辑：ID较大的节点更容易获得投票
        nodes_sorted = sorted(self.cluster_nodes)
        self_rank = nodes_sorted.index(self.node_id)
        node_rank = nodes_sorted.index(node_id)
        
        # 如果自己的排名在集群中较高，更容易获得投票
        probability = (self_rank + 1) / len(nodes_sorted)
        import random
        return random.random() < probability
    
    def _become_leader(self):
        """成为领导者"""
        self.state = 'leader'
        self.leader_id = self.node_id
        
        print(f"Node {self.node_id} ELECTED LEADER for term {self.current_term}")
        
        if self.on_leader_change:
            self.on_leader_change(self.node_id, True)
        
        if self.on_state_change:
            self.on_state_change('leader', self.current_term)
        
        # 开始发送心跳
        self._start_sending_heartbeats()
    
    def _become_follower(self):
        """成为跟随者"""
        self.state = 'follower'
        self.leader_id = None
        
        print(f"Node {self.node_id} became FOLLOWER")
        
        if self.on_state_change:
            self.on_state_change('follower', self.current_term)
    
    def _on_leader_detected(self, leader_id: str):
        """检测到领导者"""
        if self.state == 'candidate':
            self._become_follower()
        
        self.leader_id = leader_id
        self.last_heartbeat_received = time.time()
        
        if self.on_leader_change:
            self.on_leader_change(leader_id, False)
    
    def _start_sending_heartbeats(self):
        """开始发送心跳"""
        def heartbeat_sender():
            while self.state == 'leader' and self.running:
                try:
                    heartbeat = {
                        'node_id': self.node_id,
                        'term': self.current_term,
                        'timestamp': time.time(),
                        'sequence': self.heartbeat_count
                    }
                    
                    self.backend.send_heartbeat(heartbeat)
                    self.heartbeat_count += 1
                    
                    time.sleep(self.heartbeat_interval / 1000.0)
                    
                except Exception as e:
                    print(f"Heartbeat sender error: {e}")
                    break
        
        heartbeat_thread = threading.Thread(target=heartbeat_sender, daemon=True)
        heartbeat_thread.start()
        self.threads.append(heartbeat_thread)
    
    def get_status(self) -> dict:
        """获取状态信息"""
        return {
            'node_id': self.node_id,
            'state': self.state,
            'current_term': self.current_term,
            'leader_id': self.leader_id,
            'election_count': self.election_count,
            'heartbeat_count': self.heartbeat_count,
            'last_heartbeat_received': self.last_heartbeat_received,
            'cluster_size': len(self.cluster_nodes)
        }

class MemoryElectionBackend:
    """内存选举后端"""
    
    def __init__(self, node_id: str, cluster_nodes: list):
        self.node_id = node_id
        self.cluster_nodes = cluster_nodes
        self.heartbeats = []
        self.lock = threading.Lock()
    
    def start(self):
        """启动后端"""
        pass
    
    def stop(self):
        """停止后端"""
        pass
    
    def send_heartbeat(self, heartbeat: dict):
        """发送心跳"""
        with self.lock:
            self.heartbeats.append(heartbeat)
            # 只保留最近的心跳
            if len(self.heartbeats) > 100:
                self.heartbeats = self.heartbeats[-100:]
    
    def get_heartbeats(self) -> list:
        """获取心跳"""
        with self.lock:
            # 过滤出有效的 heartbeat
            current_time = time.time()
            valid_heartbeats = [
                h for h in self.heartbeats 
                if current_time - h['timestamp'] < 1.0  # 1秒内的心跳
            ]
            return valid_heartbeats

# 综合领导选举演示
def demo_comprehensive_election():
    """综合领导选举演示"""
    
    print("=== Comprehensive Leader Election Demo ===")
    
    # 创建集群
    nodes = ['alpha', 'bravo', 'charlie', 'delta', 'echo']
    election_systems = {}
    
    # 创建选举系统
    for node_id in nodes:
        system = ComprehensiveLeaderElection(node_id, nodes, 'memory')
        
        # 设置回调
        system.set_leader_change_callback(
            lambda leader_id, is_self: print(
                f"Leader changed: {leader_id} {'(self)' if is_self else ''}"
            )
        )
        system.set_state_change_callback(
            lambda state, term: print(
                f"State changed: {system.node_id} -> {state} (term {term})"
            )
        )
        
        election_systems[node_id] = system
    
    # 启动所有节点
    for system in election_systems.values():
        system.start()
    
    print("All nodes started, waiting for election...")
    
    # 监控选举过程
    try:
        for i in range(20):
            time.sleep(1)
            
            # 检查领导者
            leaders = [
                node_id for node_id, system in election_systems.items() 
                if system.state == 'leader'
            ]
            
            print(f"Time {i+1}s: {len(leaders)} leader(s) - {leaders}")
            
            if len(leaders) == 1:
                print(f"Election completed: {leaders[0]} is the leader")
                break
                
    except KeyboardInterrupt:
        print("\nDemo interrupted")
    
    finally:
        # 停止所有节点
        for system in election_systems.values():
            system.stop()
    
    # 显示最终统计
    print("\n=== Final Statistics ===")
    for node_id, system in election_systems.items():
        status = system.get_status()
        print(f"{node_id}: {status['state']} (elections: {status['election_count']}, heartbeats: {status['heartbeat_count']})")

# 添加缺失的回调方法
def set_leader_change_callback(self, callback):
    """设置领导者变化回调"""
    self.on_leader_change = callback

def set_state_change_callback(self, callback):
    """设置状态变化回调"""
    self.on_state_change = callback

# 扩展类方法
ComprehensiveLeaderElection.set_leader_change_callback = set_leader_change_callback
ComprehensiveLeaderElection.set_state_change_callback = set_state_change_callback

if __name__ == "__main__":
    demo_comprehensive_election()
```

这个综合的分布式协调机制学习文档涵盖了：

1. **分布式锁**：详细的锁实现原理、算法对比、实际应用
2. **领导选举**：多种选举算法的实现和比较
3. **心跳机制**：故障检测和健康监控
4. **实际应用案例**：库存管理、定时任务、文件处理等场景
5. **最佳实践**：安全、性能、监控等方面的指导

文档提供了完整的代码示例和最佳实践，可以作为分布式系统协调机制的学习和参考材料。