# 服务治理概述

## 目录
1. [服务治理概述](#服务治理概述)
2. [服务注册与发现](#服务注册与发现)
3. [负载均衡](#负载均衡)
4. [熔断器模式](#熔断器模式)
5. [限流控制](#限流控制)
6. [服务配置管理](#服务配置管理)
7. [服务监控与观测](#服务监控与观测)
8. [服务安全治理](#服务安全治理)
9. [治理平台建设](#治理平台建设)

## 服务治理概述

服务治理是微服务架构中的核心基础设施，负责管理、监控、协调和控制分布式系统中的各个服务实例。它确保微服务系统的可靠性、可观测性和可维护性。

### 服务治理架构
```
服务治理平台
├── 服务注册与发现
│   ├── 服务注册中心
│   ├── 健康检查
│   └── 负载均衡
├── 流量管理
│   ├── 请求路由
│   ├── 负载均衡
│   └── 限流控制
├── 容错机制
│   ├── 熔断器
│   ├── 重试机制
│   └── 降级策略
├── 配置管理
│   ├── 动态配置
│   ├── 配置版本控制
│   └── 配置分发
├── 监控观测
│   ├── 指标收集
│   ├── 日志聚合
│   ├── 分布式追踪
│   └── 健康检查
└── 安全治理
    ├── 认证授权
    ├── 访问控制
    ├── 审计日志
    └── 敏感数据保护
```

## 服务注册与发现

### 1. 服务注册中心实现
```python
import time
import uuid
import asyncio
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import json

@dataclass
class ServiceInstance:
    """服务实例"""
    service_id: str
    service_name: str
    host: str
    port: int
    version: str = "1.0.0"
    metadata: Dict = field(default_factory=dict)
    status: str = "UP"  # UP, DOWN, STARTING, OUT_OF_SERVICE
    health_check_url: Optional[str] = None
    last_heartbeat: float = field(default_factory=time.time)
    registration_time: float = field(default_factory=time.time)
    instance_id: str = field(default_factory=lambda: str(uuid.uuid4()))

class ServiceRegistry:
    """服务注册中心"""
    
    def __init__(self, health_check_interval: int = 30, ttl: int = 90):
        self.services: Dict[str, Dict[str, ServiceInstance]] = {}
        self.health_check_interval = health_check_interval
        self.ttl = ttl  # 服务实例TTL（秒）
        self.subscribers: Set[callable] = set()
        self._lock = asyncio.Lock()
        self._heartbeat_task = None
        self._running = False
    
    async def start(self):
        """启动服务注册中心"""
        self._running = True
        self._heartbeat_task = asyncio.create_task(self._heartbeat_monitor())
    
    async def stop(self):
        """停止服务注册中心"""
        self._running = False
        if self._heartbeat_task:
            self._heartbeat_task.cancel()
    
    async def register(self, instance: ServiceInstance) -> bool:
        """注册服务实例"""
        async with self._lock:
            service_name = instance.service_name
            
            if service_name not in self.services:
                self.services[service_name] = {}
            
            # 检查服务实例是否已存在
            existing_instances = self.services[service_name]
            for existing_instance in existing_instances.values():
                if (existing_instance.host == instance.host and 
                    existing_instance.port == instance.port):
                    # 更新现有实例
                    existing_instance.status = instance.status
                    existing_instance.metadata = instance.metadata
                    existing_instance.last_heartbeat = time.time()
                    self._notify_subscribers('updated', service_name, existing_instance)
                    return True
            
            # 注册新实例
            self.services[service_name][instance.instance_id] = instance
            self._notify_subscribers('registered', service_name, instance)
            return True
    
    async def deregister(self, service_name: str, instance_id: str) -> bool:
        """注销服务实例"""
        async with self._lock:
            if service_name in self.services and instance_id in self.services[service_name]:
                instance = self.services[service_name][instance_id]
                del self.services[service_name][instance_id]
                self._notify_subscribers('deregistered', service_name, instance)
                return True
            return False
    
    async def heartbeat(self, service_name: str, instance_id: str) -> bool:
        """心跳"""
        async with self._lock:
            if service_name in self.services and instance_id in self.services[service_name]:
                instance = self.services[service_name][instance_id]
                instance.last_heartbeat = time.time()
                if instance.status == "DOWN":
                    instance.status = "UP"
                    self._notify_subscribers('updated', service_name, instance)
                return True
            return False
    
    async def get_instances(self, service_name: str) -> List[ServiceInstance]:
        """获取服务实例列表"""
        async with self._lock:
            if service_name not in self.services:
                return []
            
            current_time = time.time()
            healthy_instances = []
            
            for instance in self.services[service_name].values():
                # 检查实例是否健康（根据TTL）
                if current_time - instance.last_heartbeat <= self.ttl:
                    healthy_instances.append(instance)
                else:
                    # 移除不健康的实例
                    del self.services[service_name][instance.instance_id]
                    self._notify_subscribers('expired', service_name, instance)
            
            return healthy_instances
    
    async def get_all_services(self) -> List[str]:
        """获取所有服务名称"""
        async with self._lock:
            return list(self.services.keys())
    
    async def get_service_info(self, service_name: str) -> Optional[Dict]:
        """获取服务信息"""
        instances = await self.get_instances(service_name)
        if not instances:
            return None
        
        return {
            'service_name': service_name,
            'instances_count': len(instances),
            'instances': [
                {
                    'instance_id': inst.instance_id,
                    'host': inst.host,
                    'port': inst.port,
                    'version': inst.version,
                    'status': inst.status,
                    'metadata': inst.metadata,
                    'last_heartbeat': inst.last_heartbeat
                }
                for inst in instances
            ]
        }
    
    def subscribe(self, callback: callable):
        """订阅服务变化"""
        self.subscribers.add(callback)
    
    def unsubscribe(self, callback: callable):
        """取消订阅"""
        self.subscribers.discard(callback)
    
    def _notify_subscribers(self, event_type: str, service_name: str, instance: ServiceInstance):
        """通知订阅者"""
        for callback in self.subscribers:
            try:
                callback(event_type, service_name, instance)
            except Exception as e:
                print(f"Error notifying subscriber: {e}")
    
    async def _heartbeat_monitor(self):
        """心跳监控任务"""
        while self._running:
            try:
                await self._check_expired_instances()
                await asyncio.sleep(self.health_check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Heartbeat monitor error: {e}")
    
    async def _check_expired_instances(self):
        """检查过期实例"""
        current_time = time.time()
        expired_instances = []
        
        async with self._lock:
            for service_name, instances in self.services.items():
                for instance_id, instance in list(instances.items()):
                    if current_time - instance.last_heartbeat > self.ttl:
                        expired_instances.append((service_name, instance))
                        del instances[instance_id]
        
        # 通知订阅者
        for service_name, instance in expired_instances:
            self._notify_subscribers('expired', service_name, instance)

# 客户端发现服务实现
class ClientSideDiscovery:
    """客户端服务发现"""
    
    def __init__(self, registry: ServiceRegistry, load_balancer=None):
        self.registry = registry
        self.load_balancer = load_balancer or RoundRobinLoadBalancer()
    
    async def discover(self, service_name: str) -> Optional[ServiceInstance]:
        """发现服务实例"""
        instances = await self.registry.get_instances(service_name)
        if not instances:
            return None
        
        # 使用负载均衡器选择实例
        return await self.load_balancer.select(instances)
    
    async def discover_all(self, service_name: str) -> List[ServiceInstance]:
        """发现所有健康实例"""
        return await self.registry.get_instances(service_name)

# 第三方集成：Consul
import consul

class ConsulServiceRegistry:
    """基于Consul的服务注册中心"""
    
    def __init__(self, host: str = 'localhost', port: int = 8500):
        self.consul = consul.Consul(host=host, port=port)
        self.registry = ServiceRegistry()
    
    async def register(self, service_name: str, host: str, port: int, 
                      health_check: str = None, metadata: Dict = None) -> bool:
        """注册服务到Consul"""
        service_id = f"{service_name}-{host}-{port}"
        
        try:
            # 注册服务
            self.consul.agent.service.register(
                name=service_name,
                service_id=service_id,
                address=host,
                port=port,
                check=health_check or consul.Check.http(f"http://{host}:{port}/health", 
                                                       interval="10s"),
                meta=metadata
            )
            
            # 同步到内存注册表
            instance = ServiceInstance(
                service_id=service_id,
                service_name=service_name,
                host=host,
                port=port,
                metadata=metadata or {}
            )
            
            await self.registry.register(instance)
            return True
            
        except Exception as e:
            print(f"Failed to register service to Consul: {e}")
            return False
    
    async def deregister(self, service_name: str, host: str, port: int) -> bool:
        """从Consul注销服务"""
        service_id = f"{service_name}-{host}-{port}"
        
        try:
            self.consul.agent.service.deregister(service_id=service_id)
            await self.registry.deregister(service_name, service_id)
            return True
            
        except Exception as e:
            print(f"Failed to deregister service from Consul: {e}")
            return False
    
    async def discover(self, service_name: str) -> List[Dict]:
        """从Consul发现服务"""
        try:
            _, services = self.consul.health.service(service_name, passing=True)
            return [
                {
                    'service': service['Service'],
                    'address': service['Service']['Address'],
                    'port': service['Service']['Port']
                }
                for service in services
            ]
            
        except Exception as e:
            print(f"Failed to discover service from Consul: {e}")
            return []
```

## 负载均衡

### 2. 智能负载均衡器
```python
import random
import time
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class ServerMetrics:
    """服务器指标"""
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    response_time: float = 0.0
    error_rate: float = 0.0
    active_connections: int = 0
    throughput: float = 0.0

class LoadBalancer(ABC):
    """负载均衡器抽象"""
    
    @abstractmethod
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        """选择实例"""
        pass

class RoundRobinLoadBalancer(LoadBalancer):
    """轮询负载均衡器"""
    
    def __init__(self):
        self.counter = 0
        self._lock = asyncio.Lock()
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        async with self._lock:
            selected = instances[self.counter % len(instances)]
            self.counter += 1
            return selected

class WeightedRoundRobinLoadBalancer(LoadBalancer):
    """加权轮询负载均衡器"""
    
    def __init__(self):
        self.weights: Dict[str, int] = {}
        self.current_weights: Dict[str, int] = {}
    
    def set_weight(self, instance_id: str, weight: int):
        """设置实例权重"""
        self.weights[instance_id] = weight
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        # 初始化当前权重
        total_weight = sum(self.weights.get(inst.instance_id, 1) for inst in instances)
        
        if not any(self.current_weights.values()):
            for inst in instances:
                self.current_weights[inst.instance_id] = self.weights.get(inst.instance_id, 1)
        else:
            for inst in instances:
                weight = self.weights.get(inst.instance_id, 1)
                self.current_weights[inst.instance_id] += weight
        
        # 选择权重最高的实例
        max_weight_instance = max(
            instances,
            key=lambda x: self.current_weights[x.instance_id]
        )
        
        # 减少被选中实例的权重
        self.current_weights[max_weight_instance.instance_id] -= total_weight
        
        return max_weight_instance

class LeastConnectionsLoadBalancer(LoadBalancer):
    """最少连接负载均衡器"""
    
    def __init__(self):
        self.connection_counts: Dict[str, int] = {}
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        # 选择连接数最少的实例
        selected = min(
            instances,
            key=lambda x: self.connection_counts.get(x.instance_id, 0)
        )
        
        # 增加连接计数
        self.connection_counts[selected.instance_id] = \
            self.connection_counts.get(selected.instance_id, 0) + 1
        
        return selected
    
    def release_connection(self, instance_id: str):
        """释放连接"""
        if instance_id in self.connection_counts:
            self.connection_counts[instance_id] = max(0, self.connection_counts[instance_id] - 1)
    
    def increment_error(self, instance_id: str):
        """增加错误计数"""
        # 可以用于错误率计算
        pass

class ResourceBasedLoadBalancer(LoadBalancer):
    """基于资源的负载均衡器"""
    
    def __init__(self):
        self.metrics: Dict[str, ServerMetrics] = {}
    
    def update_metrics(self, instance_id: str, metrics: ServerMetrics):
        """更新实例指标"""
        self.metrics[instance_id] = metrics
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        # 计算负载分数（越低越好）
        def calculate_load_score(instance: ServiceInstance) -> float:
            metrics = self.metrics.get(instance.instance_id)
            if not metrics:
                return 0.5  # 默认中等负载
            
            # 综合指标计算负载分数
            cpu_factor = metrics.cpu_usage / 100.0
            memory_factor = metrics.memory_usage / 100.0
            response_factor = min(metrics.response_time / 1000.0, 1.0)  # 归一化响应时间
            connection_factor = min(metrics.active_connections / 1000.0, 1.0)
            
            # 加权计算
            load_score = (
                cpu_factor * 0.3 +
                memory_factor * 0.2 +
                response_factor * 0.3 +
                connection_factor * 0.2
            )
            
            return load_score
        
        # 选择负载最低的实例
        selected = min(instances, key=calculate_load_score)
        return selected

class LatencyBasedLoadBalancer(LoadBalancer):
    """基于延迟的负载均衡器"""
    
    def __init__(self, history_size: int = 100):
        self.latency_history: Dict[str, List[float]] = {}
        self.history_size = history_size
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        # 计算平均延迟
        def get_average_latency(instance: ServiceInstance) -> float:
            history = self.latency_history.get(instance.instance_id, [])
            return sum(history) / len(history) if history else 100.0  # 默认100ms
        
        # 选择延迟最低的实例
        selected = min(instances, key=get_average_latency)
        return selected
    
    def record_latency(self, instance_id: str, latency: float):
        """记录延迟"""
        if instance_id not in self.latency_history:
            self.latency_history[instance_id] = []
        
        self.latency_history[instance_id].append(latency)
        
        # 保持历史记录大小
        if len(self.latency_history[instance_id]) > self.history_size:
            self.latency_history[instance_id] = \
                self.latency_history[instance_id][-self.history_size:]

class HealthAwareLoadBalancer(LoadBalancer):
    """健康感知负载均衡器"""
    
    def __init__(self, base_balancer: LoadBalancer):
        self.base_balancer = base_balancer
        self.health_status: Dict[str, bool] = {}
    
    def set_health_status(self, instance_id: str, is_healthy: bool):
        """设置健康状态"""
        self.health_status[instance_id] = is_healthy
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        # 只选择健康的实例
        healthy_instances = [
            inst for inst in instances
            if self.health_status.get(inst.instance_id, True)
        ]
        
        if not healthy_instances:
            # 如果没有健康实例，降级到选择不健康的实例
            healthy_instances = instances
        
        return await self.base_balancer.select(healthy_instances)

# 智能负载均衡器
class IntelligentLoadBalancer:
    """智能负载均衡器"""
    
    def __init__(self):
        self.balancers = {
            'round_robin': RoundRobinLoadBalancer(),
            'weighted_round_robin': WeightedRoundRobinLoadBalancer(),
            'least_connections': LeastConnectionsLoadBalancer(),
            'resource_based': ResourceBasedLoadBalancer(),
            'latency_based': LatencyBasedLoadBalancer()
        }
        self.current_strategy = 'round_robin'
        self.fallback_strategies = ['resource_based', 'latency_based', 'round_robin']
    
    def set_strategy(self, strategy: str):
        """设置负载均衡策略"""
        if strategy in self.balancers:
            self.current_strategy = strategy
    
    async def select(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        if not instances:
            return None
        
        # 尝试当前策略
        try:
            result = await self.balancers[self.current_strategy].select(instances)
            if result:
                return result
        except Exception as e:
            print(f"Load balancing strategy {self.current_strategy} failed: {e}")
        
        # 策略失败时尝试回退策略
        for strategy in self.fallback_strategies:
            if strategy != self.current_strategy:
                try:
                    result = await self.balancers[strategy].select(instances)
                    if result:
                        print(f"Fallback to strategy: {strategy}")
                        return result
                except Exception as e:
                    continue
        
        # 所有策略都失败，返回第一个实例
        return instances[0]
```

## 熔断器模式

### 3. 熔断器实现
```python
from enum import Enum
from typing import Callable, Any, Optional
import asyncio
from datetime import datetime, timedelta

class CircuitState(Enum):
    """熔断器状态"""
    CLOSED = "closed"    # 关闭：正常操作
    OPEN = "open"        # 打开：快速失败
    HALF_OPEN = "half_open"  # 半开：尝试恢复

class CircuitBreakerError(Exception):
    """熔断器异常"""
    pass

class CircuitBreaker:
    """熔断器"""
    
    def __init__(self, 
                 failure_threshold: int = 5,
                 timeout: int = 60,
                 success_threshold: int = 3,
                 monitor_window: int = 60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.success_threshold = success_threshold
        self.monitor_window = monitor_window
        
        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.requests = []  # 请求历史
        
        # 指标
        self.total_requests = 0
        self.successful_requests = 0
        self.failed_requests = 0
    
    async def call(self, func: Callable, *args, **kwargs) -> Any:
        """调用函数，带熔断器保护"""
        if not await self._before_request():
            raise CircuitBreakerError(f"Circuit breaker is {self.state.value}")
        
        try:
            result = await func(*args, **kwargs)
            await self._on_success()
            return result
            
        except Exception as e:
            await self._on_failure()
            raise e
    
    async def _before_request(self) -> bool:
        """请求前检查"""
        current_time = datetime.now()
        
        if self.state == CircuitState.OPEN:
            # 检查是否应该尝试恢复
            if self._should_attempt_reset(current_time):
                self.state = CircuitState.HALF_OPEN
                self.success_count = 0
                print("Circuit breaker moved to HALF_OPEN state")
                return True
            return False
        
        # CLOSED 或 HALF_OPEN 状态允许请求
        return True
    
    def _should_attempt_reset(self, current_time: datetime) -> bool:
        """检查是否应该尝试重置熔断器"""
        if not self.last_failure_time:
            return True
        
        time_since_failure = (current_time - self.last_failure_time).total_seconds()
        return time_since_failure >= self.timeout
    
    async def _on_success(self):
        """成功回调"""
        self.total_requests += 1
        self.successful_requests += 1
        
        if self.state == CircuitState.HALF_OPEN:
            self.success_count += 1
            if self.success_count >= self.success_threshold:
                self.state = CircuitState.CLOSED
                self.failure_count = 0
                print("Circuit breaker moved to CLOSED state")
    
    async def _on_failure(self):
        """失败回调"""
        self.total_requests += 1
        self.failed_requests += 1
        
        self.failure_count += 1
        self.last_failure_time = datetime.now()
        
        if self.state == CircuitState.CLOSED:
            if self.failure_count >= self.failure_threshold:
                self.state = CircuitState.OPEN
                print("Circuit breaker moved to OPEN state")
        
        elif self.state == CircuitState.HALF_OPEN:
            # 半开状态下任何失败都会立即打开熔断器
            self.state = CircuitState.OPEN
            print("Circuit breaker moved to OPEN state from HALF_OPEN")
        
        # 记录请求历史
        self._record_request(datetime.now(), False)
    
    def _record_request(self, timestamp: datetime, success: bool):
        """记录请求"""
        self.requests.append((timestamp, success))
        
        # 清理过旧记录
        cutoff_time = timestamp - timedelta(seconds=self.monitor_window)
        self.requests = [(t, s) for t, s in self.requests if t > cutoff_time]
    
    def get_metrics(self) -> Dict[str, Any]:
        """获取熔断器指标"""
        current_time = datetime.now()
        
        # 计算窗口内的指标
        window_requests = [
            (t, s) for t, s in self.requests 
            if (current_time - t).total_seconds() <= self.monitor_window
        ]
        
        window_success = sum(1 for _, success in window_requests if success)
        window_total = len(window_requests)
        window_error_rate = (window_total - window_success) / window_total if window_total > 0 else 0
        
        return {
            'state': self.state.value,
            'failure_count': self.failure_count,
            'success_count': self.success_count,
            'total_requests': self.total_requests,
            'successful_requests': self.successful_requests,
            'failed_requests': self.failed_requests,
            'window_requests': window_total,
            'window_success': window_success,
            'window_error_rate': window_error_rate,
            'last_failure_time': self.last_failure_time.isoformat() if self.last_failure_time else None
        }

# 熔断器集群管理
class CircuitBreakerCluster:
    """熔断器集群管理"""
    
    def __init__(self):
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
        self.global_config = {
            'failure_threshold': 5,
            'timeout': 60,
            'success_threshold': 3,
            'monitor_window': 60
        }
    
    def get_circuit_breaker(self, service_name: str) -> CircuitBreaker:
        """获取服务的熔断器"""
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker(**self.global_config)
        
        return self.circuit_breakers[service_name]
    
    async def call_service(self, service_name: str, func: Callable, *args, **kwargs) -> Any:
        """调用服务，带熔断器保护"""
        circuit_breaker = self.get_circuit_breaker(service_name)
        return await circuit_breaker.call(func, *args, **kwargs)
    
    def get_cluster_metrics(self) -> Dict[str, Any]:
        """获取集群熔断器指标"""
        return {
            service_name: cb.get_metrics()
            for service_name, cb in self.circuit_breakers.items()
        }
    
    def set_global_config(self, config: Dict[str, Any]):
        """设置全局配置"""
        self.global_config.update(config)
        
        # 更新现有熔断器配置
        for cb in self.circuit_breakers.values():
            for key, value in config.items():
                if hasattr(cb, key):
                    setattr(cb, key, value)

# 服务端熔断器监控
class CircuitBreakerMonitor:
    """熔断器监控"""
    
    def __init__(self, cluster: CircuitBreakerCluster):
        self.cluster = cluster
        self.alerts: List[Dict] = []
    
    async def monitor(self):
        """监控熔断器状态"""
        while True:
            try:
                metrics = self.cluster.get_cluster_metrics()
                await self._check_alerts(metrics)
                await asyncio.sleep(30)  # 每30秒检查一次
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Circuit breaker monitoring error: {e}")
    
    async def _check_alerts(self, metrics: Dict[str, Any]):
        """检查告警条件"""
        for service_name, service_metrics in metrics.items():
            state = service_metrics['state']
            
            if state == 'open':
                await self._trigger_alert(
                    service_name,
                    'CIRCUIT_BREAKER_OPEN',
                    f"Circuit breaker is OPEN for service {service_name}",
                    service_metrics
                )
            
            elif service_metrics['window_error_rate'] > 0.5:
                await self._trigger_alert(
                    service_name,
                    'HIGH_ERROR_RATE',
                    f"High error rate ({service_metrics['window_error_rate']:.2%}) for service {service_name}",
                    service_metrics
                )
    
    async def _trigger_alert(self, service_name: str, alert_type: str, 
                           message: str, metrics: Dict):
        """触发告警"""
        alert = {
            'service': service_name,
            'type': alert_type,
            'message': message,
            'metrics': metrics,
            'timestamp': datetime.now().isoformat()
        }
        
        self.alerts.append(alert)
        
        # 这里可以集成各种告警渠道（邮件、短信、钉钉等）
        print(f"ALERT: {alert}")
        
        # 限制告警历史长度
        if len(self.alerts) > 1000:
            self.alerts = self.alerts[-500:]
```

## 限流控制

### 4. 限流算法实现
```python
from abc import ABC, abstractmethod
from collections import defaultdict, deque
from typing import Dict, Optional
import time

class RateLimiter(ABC):
    """限流器抽象"""
    
    @abstractmethod
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        pass
    
    @abstractmethod
    def get_remaining_quota(self, key: str) -> int:
        """获取剩余配额"""
        pass

class TokenBucketLimiter(RateLimiter):
    """令牌桶限流器"""
    
    def __init__(self, capacity: int, refill_rate: float):
        self.capacity = capacity
        self.refill_rate = refill_rate  # 每秒补充的令牌数
        self.buckets: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1))
        self.last_refill: Dict[str, float] = defaultdict(time.time)
    
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        now = time.time()
        
        # 补充令牌
        await self._refill_tokens(key, now)
        
        # 检查并消耗令牌
        if self.buckets[key][0] > 0:
            self.buckets[key][0] -= 1
            return True
        
        return False
    
    def _refill_tokens(self, key: str, now: float):
        """补充令牌"""
        time_passed = now - self.last_refill[key]
        tokens_to_add = time_passed * self.refill_rate
        
        if not self.buckets[key]:
            self.buckets[key].append(self.capacity)
        else:
            current_tokens = self.buckets[key][0]
            new_tokens = min(self.capacity, current_tokens + tokens_to_add)
            self.buckets[key][0] = new_tokens
        
        self.last_refill[key] = now
    
    def get_remaining_quota(self, key: str) -> int:
        """获取剩余配额"""
        if not self.buckets[key]:
            return self.capacity
        return int(self.buckets[key][0])

class SlidingWindowLimiter(RateLimiter):
    """滑动窗口限流器"""
    
    def __init__(self, limit: int, window_size: int):
        self.limit = limit
        self.window_size = window_size  # 窗口大小（秒）
        self.requests: Dict[str, deque] = defaultdict(deque)
    
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        now = time.time()
        
        # 清理过期请求
        self._cleanup_expired_requests(key, now)
        
        # 检查当前窗口内的请求数
        if len(self.requests[key]) < self.limit:
            self.requests[key].append(now)
            return True
        
        return False
    
    def _cleanup_expired_requests(self, key: str, now: float):
        """清理过期请求"""
        window_start = now - self.window_size
        
        # 移除过期请求
        while self.requests[key] and self.requests[key][0] < window_start:
            self.requests[key].popleft()
    
    def get_remaining_quota(self, key: str) -> int:
        """获取剩余配额"""
        self._cleanup_expired_requests(key, time.time())
        return max(0, self.limit - len(self.requests[key]))

class FixedWindowLimiter(RateLimiter):
    """固定窗口限流器"""
    
    def __init__(self, limit: int, window_size: int):
        self.limit = limit
        self.window_size = window_size
        self.windows: Dict[str, Dict[int, int]] = defaultdict(dict)
    
    def _get_window_key(self, timestamp: float) -> int:
        """获取窗口键"""
        return int(timestamp // self.window_size)
    
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        now = time.time()
        window_key = self._get_window_key(now)
        
        # 获取当前窗口的计数
        current_count = self.windows[key].get(window_key, 0)
        
        if current_count < self.limit:
            self.windows[key][window_key] = current_count + 1
            return True
        
        return False
    
    def get_remaining_quota(self, key: str) -> int:
        """获取剩余配额"""
        now = time.time()
        window_key = self._get_window_key(now)
        current_count = self.windows[key].get(window_key, 0)
        
        return max(0, self.limit - current_count)

class LeakyBucketLimiter(RateLimiter):
    """漏桶限流器"""
    
    def __init__(self, capacity: int, leak_rate: float):
        self.capacity = capacity
        self.leak_rate = leak_rate  # 每秒泄漏的请求数
        self.buckets: Dict[str, int] = defaultdict(int)
        self.last_leak: Dict[str, float] = defaultdict(time.time)
    
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        now = time.time()
        
        # 泄漏请求
        await self._leak_requests(key, now)
        
        # 检查桶是否已满
        if self.buckets[key] < self.capacity:
            self.buckets[key] += 1
            return True
        
        return False
    
    def _leak_requests(self, key: str, now: float):
        """泄漏请求"""
        time_passed = now - self.last_leak[key]
        requests_to_leak = int(time_passed * self.leak_rate)
        
        if requests_to_leak > 0:
            self.buckets[key] = max(0, self.buckets[key] - requests_to_leak)
            self.last_leak[key] = now
    
    def get_remaining_quota(self, key: str) -> int:
        """获取剩余配额"""
        return max(0, self.capacity - self.buckets[key])

class MultiTierRateLimiter:
    """多层级限流器"""
    
    def __init__(self):
        self.limiters: Dict[str, RateLimiter] = {}
    
    def add_limiter(self, name: str, limiter: RateLimiter):
        """添加限流器"""
        self.limiters[name] = limiter
    
    async def allow_request(self, keys: Dict[str, str]) -> Dict[str, bool]:
        """检查所有限流器"""
        results = {}
        
        for limiter_name, key in keys.items():
            if limiter_name in self.limiters:
                results[limiter_name] = await self.limiters[limiter_name].allow_request(key)
            else:
                results[limiter_name] = True  # 默认允许
        
        return results
    
    def is_allowed(self, keys: Dict[str, str]) -> bool:
        """检查是否所有限流器都允许"""
        results = asyncio.run(self.allow_request(keys))
        return all(results.values())
    
    def get_remaining_quotas(self, keys: Dict[str, str]) -> Dict[str, int]:
        """获取所有限流器的剩余配额"""
        quotas = {}
        
        for limiter_name, key in keys.items():
            if limiter_name in self.limiters:
                quotas[limiter_name] = self.limiters[limiter_name].get_remaining_quota(key)
        
        return quotas

# 分布式限流
import redis

class RedisRateLimiter(RateLimiter):
    """基于Redis的分布式限流器"""
    
    def __init__(self, redis_client: redis.Redis, key_prefix: str = "rate_limit"):
        self.redis = redis_client
        self.key_prefix = key_prefix
    
    async def allow_request(self, key: str, limit: int, window: int) -> bool:
        """检查Redis限流（使用INCR + EXPIRE）"""
        redis_key = f"{self.key_prefix}:{key}"
        
        try:
            # 使用管道执行多个操作
            pipe = self.redis.pipeline()
            pipe.incr(redis_key)
            pipe.expire(redis_key, window)
            results = pipe.execute()
            
            current_count = results[0]
            return current_count <= limit
            
        except redis.RedisError as e:
            print(f"Redis error in rate limiter: {e}")
            return True  # 发生错误时默认允许请求
    
    async def allow_request_sliding_window(self, key: str, limit: int, window: int) -> bool:
        """滑动窗口限流（Redis实现）"""
        redis_key = f"{self.key_prefix}:{key}:sliding"
        current_time = int(time.time())
        
        try:
            # 移除过期的记录
            pipe = self.redis.pipeline()
            pipe.zremrangebyscore(redis_key, 0, current_time - window)
            pipe.zcard(redis_key)
            pipe.zadd(redis_key, {str(current_time): current_time})
            pipe.expire(redis_key, window)
            results = pipe.execute()
            
            current_count = results[1]
            return current_count < limit
            
        except redis.RedisError as e:
            print(f"Redis error in sliding window rate limiter: {e}")
            return True

# 限流中间件
class RateLimitMiddleware:
    """限流中间件"""
    
    def __init__(self, rate_limiter: RateLimiter):
        self.rate_limiter = rate_limiter
        self.default_limit = 100  # 默认每秒100请求
        self.default_window = 60  # 默认1分钟窗口
    
    async def check_rate_limit(self, identifier: str, limit: int = None, 
                              window: int = None) -> Dict[str, Any]:
        """检查限流"""
        limit = limit or self.default_limit
        window = window or self.default_window
        
        allowed = await self.rate_limiter.allow_request(identifier)
        remaining = self.rate_limiter.get_remaining_quota(identifier)
        
        # 计算重置时间
        reset_time = int(time.time()) + window
        
        return {
            'allowed': allowed,
            'remaining': remaining,
            'limit': limit,
            'reset_time': reset_time,
            'headers': {
                'X-RateLimit-Limit': str(limit),
                'X-RateLimit-Remaining': str(remaining),
                'X-RateLimit-Reset': str(reset_time)
            }
        }
    
    def create_rate_limit_decorator(self, limit: int, window: int = 60):
        """创建限流装饰器"""
        def decorator(func):
            async def wrapper(*args, **kwargs):
                # 获取请求标识符（这里简化为函数名）
                identifier = f"{func.__name__}"
                
                result = await self.check_rate_limit(identifier, limit, window)
                
                if not result['allowed']:
                    raise Exception(f"Rate limit exceeded. Try again in {result['reset_time']} seconds")
                
                return await func(*args, **kwargs)
            
            return wrapper
        return decorator
```

## 服务配置管理

### 5. 动态配置系统
```python
import yaml
import json
import os
from pathlib import Path
from typing import Dict, Any, Optional, List, Callable
from dataclasses import dataclass, asdict
from enum import Enum
import hashlib

class ConfigSource(Enum):
    """配置源类型"""
    FILE = "file"
    ENVIRONMENT = "environment"
    DATABASE = "database"
    CONSUL = "consul"
    ETCD = "etcd"
    ZOOKEEPER = "zookeeper"

class ConfigChangeType(Enum):
    """配置变更类型"""
    ADDED = "added"
    MODIFIED = "modified"
    DELETED = "deleted"

@dataclass
class ConfigItem:
    """配置项"""
    key: str
    value: Any
    version: str
    source: ConfigSource
    metadata: Dict[str, Any]
    last_modified: float = None
    checksum: str = None
    
    def __post_init__(self):
        if self.last_modified is None:
            self.last_modified = time.time()
        if self.checksum is None:
            self.checksum = self._calculate_checksum()
    
    def _calculate_checksum(self) -> str:
        """计算校验和"""
        content = f"{self.key}:{self.value}:{self.version}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def is_valid(self) -> bool:
        """验证配置项完整性"""
        return self.checksum == self._calculate_checksum()

@dataclass
class ConfigChange:
    """配置变更"""
    change_type: ConfigChangeType
    key: str
    old_value: Any = None
    new_value: Any = None
    timestamp: float = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = time.time()

class ConfigChangeListener:
    """配置变更监听器"""
    
    async def on_config_change(self, change: ConfigChange):
        """配置变更回调"""
        pass

class FileConfigSource:
    """文件配置源"""
    
    def __init__(self, config_dir: str, patterns: List[str] = None):
        self.config_dir = Path(config_dir)
        self.patterns = patterns or ["*.yaml", "*.yml", "*.json"]
        self.watch_handlers: List[Callable] = []
    
    def load_configs(self) -> Dict[str, ConfigItem]:
        """加载配置文件"""
        configs = {}
        
        for pattern in self.patterns:
            for file_path in self.config_dir.glob(pattern):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        if file_path.suffix in ['.yaml', '.yml']:
                            data = yaml.safe_load(f)
                        else:
                            data = json.load(f)
                        
                        # 扁平化配置
                        flat_config = self._flatten_dict(data, file_path.stem)
                        
                        for key, value in flat_config.items():
                            config_item = ConfigItem(
                                key=key,
                                value=value,
                                version=str(file_path.stat().st_mtime),
                                source=ConfigSource.FILE,
                                metadata={'file_path': str(file_path)}
                            )
                            configs[key] = config_item
                
                except Exception as e:
                    print(f"Error loading config file {file_path}: {e}")
        
        return configs
    
    def _flatten_dict(self, d: Dict, prefix: str = "") -> Dict[str, Any]:
        """扁平化字典"""
        result = {}
        
        for key, value in d.items():
            new_key = f"{prefix}.{key}" if prefix else key
            
            if isinstance(value, dict):
                result.update(self._flatten_dict(value, new_key))
            else:
                result[new_key] = value
        
        return result
    
    def watch_changes(self, callback: Callable):
        """监听文件变化"""
        # 这里可以使用watchdog库实现文件监听
        # 简化实现，仅作为示例
        self.watch_handlers.append(callback)

class EnvironmentConfigSource:
    """环境变量配置源"""
    
    def load_configs(self) -> Dict[str, ConfigItem]:
        """加载环境变量配置"""
        configs = {}
        
        for key, value in os.environ.items():
            if key.startswith('APP_CONFIG_'):
                config_key = key.replace('APP_CONFIG_', '').lower()
                config_item = ConfigItem(
                    key=config_key,
                    value=self._parse_value(value),
                    version="1.0",
                    source=ConfigSource.ENVIRONMENT,
                    metadata={'env_var': key}
                )
                configs[config_key] = config_item
        
        return configs
    
    def _parse_value(self, value: str) -> Any:
        """解析环境变量值"""
        # 尝试解析为JSON
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            pass
        
        # 尝试解析为数字
        if value.isdigit():
            return int(value)
        
        try:
            return float(value)
        except ValueError:
            pass
        
        # 尝试解析布尔值
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'
        
        return value

class ConfigManager:
    """配置管理器"""
    
    def __init__(self):
        self.configs: Dict[str, ConfigItem] = {}
        self.listeners: List[ConfigChangeListener] = []
        self.sources: List[Any] = []
        self._lock = asyncio.Lock()
    
    def add_source(self, source):
        """添加配置源"""
        self.sources.append(source)
    
    def add_listener(self, listener: ConfigChangeListener):
        """添加配置变更监听器"""
        self.listeners.append(listener)
    
    async def load_configurations(self):
        """加载所有配置"""
        all_configs = {}
        
        for source in self.sources:
            if hasattr(source, 'load_configs'):
                configs = source.load_configs()
                all_configs.update(configs)
        
        async with self._lock:
            # 检查配置变更
            changes = self._detect_changes(self.configs, all_configs)
            
            # 更新配置
            self.configs = all_configs
            
            # 通知监听器
            for change in changes:
                await self._notify_listeners(change)
    
    def _detect_changes(self, old_configs: Dict[str, ConfigItem], 
                       new_configs: Dict[str, ConfigItem]) -> List[ConfigChange]:
        """检测配置变更"""
        changes = []
        
        # 检测新增和修改
        for key, new_config in new_configs.items():
            if key in old_configs:
                old_config = old_configs[key]
                if old_config.value != new_config.value or old_config.version != new_config.version:
                    changes.append(ConfigChange(
                        change_type=ConfigChangeType.MODIFIED,
                        key=key,
                        old_value=old_config.value,
                        new_value=new_config.value
                    ))
            else:
                changes.append(ConfigChange(
                    change_type=ConfigChangeType.ADDED,
                    key=key,
                    new_value=new_config.value
                ))
        
        # 检测删除
        for key, old_config in old_configs.items():
            if key not in new_configs:
                changes.append(ConfigChange(
                    change_type=ConfigChangeType.DELETED,
                    key=key,
                    old_value=old_config.value
                ))
        
        return changes
    
    async def _notify_listeners(self, change: ConfigChange):
        """通知监听器"""
        for listener in self.listeners:
            try:
                await listener.on_config_change(change)
            except Exception as e:
                print(f"Error notifying listener: {e}")
    
    def get(self, key: str, default: Any = None) -> Any:
        """获取配置值"""
        if key in self.configs:
            return self.configs[key].value
        return default
    
    def get_all(self) -> Dict[str, Any]:
        """获取所有配置"""
        return {key: config.value for key, config in self.configs.items()}
    
    def get_config_item(self, key: str) -> Optional[ConfigItem]:
        """获取配置项"""
        return self.configs.get(key)
    
    async def set(self, key: str, value: Any, version: str = "1.0"):
        """设置配置"""
        async with self._lock:
            old_value = self.configs.get(key).value if key in self.configs else None
            
            config_item = ConfigItem(
                key=key,
                value=value,
                version=version,
                source=ConfigSource.FILE,
                metadata={}
            )
            
            self.configs[key] = config_item
            
            if old_value != value:
                change = ConfigChange(
                    change_type=ConfigChangeType.MODIFIED if old_value is not None else ConfigChangeType.ADDED,
                    key=key,
                    old_value=old_value,
                    new_value=value
                )
                await self._notify_listeners(change)
    
    async def delete(self, key: str):
        """删除配置"""
        async with self._lock:
            if key in self.configs:
                old_value = self.configs[key].value
                del self.configs[key]
                
                change = ConfigChange(
                    change_type=ConfigChangeType.DELETED,
                    key=key,
                    old_value=old_value
                )
                await self._notify_listeners(change)
    
    def watch_config(self, key: str) -> ConfigItem:
        """监听配置变化（简化实现）"""
        # 实际实现应该使用异步事件或回调
        return self.configs.get(key)

# 配置客户端
class ConfigClient:
    """配置客户端"""
    
    def __init__(self, config_manager: ConfigManager):
        self.config_manager = config_manager
        self.cache: Dict[str, Any] = {}
        self.cache_timestamps: Dict[str, float] = {}
        self.cache_ttl = 300  # 5分钟缓存
    
    async def get_config(self, key: str, force_refresh: bool = False) -> Any:
        """获取配置（带缓存）"""
        cache_key = key
        
        if not force_refresh and cache_key in self.cache:
            timestamp = self.cache_timestamps[cache_key]
            if time.time() - timestamp < self.cache_ttl:
                return self.cache[cache_key]
        
        # 刷新缓存
        value = self.config_manager.get(key)
        if value is not None:
            self.cache[cache_key] = value
            self.cache_timestamps[cache_key] = time.time()
        
        return value
    
    async def watch_config(self, key: str, callback: Callable):
        """监听配置变化"""
        while True:
            try:
                current_value = self.config_manager.get(key)
                cached_value = self.cache.get(key)
                
                if current_value != cached_value:
                    self.cache[key] = current_value
                    await callback(key, current_value, cached_value)
                
                await asyncio.sleep(1)  # 每秒检查一次
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Error watching config {key}: {e}")
                await asyncio.sleep(5)

# 使用示例
async def example_config_management():
    """配置管理使用示例"""
    
    # 创建配置管理器
    config_manager = ConfigManager()
    
    # 添加配置源
    config_manager.add_source(FileConfigSource("./config"))
    config_manager.add_source(EnvironmentConfigSource())
    
    # 创建监听器
    class ConfigChangeListenerImpl(ConfigChangeListener):
        async def on_config_change(self, change: ConfigChange):
            print(f"Config change: {change.change_type.value} - {change.key}")
            if change.old_value is not None:
                print(f"  Old value: {change.old_value}")
            if change.new_value is not None:
                print(f"  New value: {change.new_value}")
    
    config_manager.add_listener(ConfigChangeListenerImpl())
    
    # 加载配置
    await config_manager.load_configurations()
    
    # 获取配置
    database_url = config_manager.get("database.url")
    print(f"Database URL: {database_url}")
    
    # 更新配置
    await config_manager.set("feature.enabled", True)
    
    # 创建客户端
    client = ConfigClient(config_manager)
    
    # 获取配置
    feature_enabled = await client.get_config("feature.enabled")
    print(f"Feature enabled: {feature_enabled}")
    
    # 监听配置变化
    async def config_callback(key: str, new_value: Any, old_value: Any):
        print(f"Configuration updated: {key} = {new_value}")
    
    await client.watch_config("feature.enabled", config_callback)
```

## 服务监控与观测

### 6. 监控指标体系
```python
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import asyncio
from collections import defaultdict, deque

class MetricType(Enum):
    """指标类型"""
    COUNTER = "counter"        # 累加型指标
    GAUGE = "gauge"           # 瞬时型指标
    HISTOGRAM = "histogram"   # 直方图指标
    SUMMARY = "summary"       # 摘要指标

class MetricUnit(Enum):
    """指标单位"""
    COUNT = "count"
    MS = "ms"
    SECONDS = "s"
    PERCENT = "percent"
    BYTES = "bytes"
    RATE = "rate"

@dataclass
class MetricPoint:
    """指标数据点"""
    timestamp: float
    value: Union[int, float]
    labels: Dict[str, str] = field(default_factory=dict)

@dataclass
class Metric:
    """指标定义"""
    name: str
    type: MetricType
    description: str = ""
    unit: MetricUnit = MetricUnit.COUNT
    labels: Dict[str, str] = field(default_factory=dict)

class MetricsCollector:
    """指标收集器"""
    
    def __init__(self, max_points_per_metric: int = 1000):
        self.max_points_per_metric = max_points_per_metric
        self.metrics: Dict[str, Metric] = {}
        self.data: Dict[str, List[MetricPoint]] = defaultdict(list)
        self._lock = threading.Lock()
    
    def register_metric(self, metric: Metric):
        """注册指标"""
        with self._lock:
            self.metrics[metric.name] = metric
    
    def record_counter(self, name: str, value: int = 1, labels: Dict[str, str] = None):
        """记录计数器指标"""
        self._record_point(name, value, labels or {})
    
    def record_gauge(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录仪表盘指标"""
        self._record_point(name, value, labels or {})
    
    def record_histogram(self, name: str, value: float, labels: Dict[str, str] = None):
        """记录直方图指标"""
        self._record_point(name, value, labels or {})
    
    def _record_point(self, name: str, value: Union[int, float], labels: Dict[str, str]):
        """记录数据点"""
        with self._lock:
            if name not in self.metrics:
                # 自动注册未知的指标
                metric = Metric(
                    name=name,
                    type=MetricType.GAUGE,
                    description=f"Auto-registered metric: {name}"
                )
                self.metrics[name] = metric
            
            point = MetricPoint(
                timestamp=time.time(),
                value=value,
                labels=labels
            )
            
            # 合并相同标签的数据
            existing_points = self.data[name]
            existing_points.append(point)
            
            # 保持数据点数量限制
            if len(existing_points) > self.max_points_per_metric:
                self.data[name] = existing_points[-self.max_points_per_metric:]
    
    def get_metric_data(self, name: str) -> List[MetricPoint]:
        """获取指标数据"""
        with self._lock:
            return self.data.get(name, []).copy()
    
    def get_latest_value(self, name: str, labels: Dict[str, str] = None) -> Optional[Union[int, float]]:
        """获取最新指标值"""
        with self._lock:
            points = self.data.get(name, [])
            if not points:
                return None
            
            if labels:
                # 查找指定标签的最新数据点
                for point in reversed(points):
                    if point.labels == labels:
                        return point.value
                return None
            
            return points[-1].value
    
    def get_all_metrics(self) -> Dict[str, List[MetricPoint]]:
        """获取所有指标数据"""
        with self._lock:
            return {name: points.copy() for name, points in self.data.items()}

class ServiceMonitor:
    """服务监控"""
    
    def __init__(self, collector: MetricsCollector, service_name: str):
        self.collector = collector
        self.service_name = service_name
        
        # 注册基础指标
        self._register_base_metrics()
    
    def _register_base_metrics(self):
        """注册基础指标"""
        base_metrics = [
            Metric("service_requests_total", MetricType.COUNTER, "Total requests", MetricUnit.COUNT),
            Metric("service_requests_duration", MetricType.HISTOGRAM, "Request duration", MetricUnit.MS),
            Metric("service_errors_total", MetricType.COUNTER, "Total errors", MetricUnit.COUNT),
            Metric("service_active_connections", MetricType.GAUGE, "Active connections", MetricUnit.COUNT),
            Metric("service_cpu_usage", MetricType.GAUGE, "CPU usage", MetricUnit.PERCENT),
            Metric("service_memory_usage", MetricType.GAUGE, "Memory usage", MetricUnit.PERCENT),
            Metric("service_heap_size", MetricType.GAUGE, "Heap size", MetricUnit.BYTES)
        ]
        
        for metric in base_metrics:
            self.collector.register_metric(metric)
    
    def record_request(self, method: str, status_code: int, duration_ms: float, endpoint: str = ""):
        """记录请求指标"""
        labels = {
            'service': self.service_name,
            'method': method,
            'status_code': str(status_code),
            'endpoint': endpoint
        }
        
        self.collector.record_counter("service_requests_total", 1, labels)
        self.collector.record_histogram("service_requests_duration", duration_ms, labels)
        
        if status_code >= 400:
            self.collector.record_counter("service_errors_total", 1, labels)
    
    def record_connection(self, action: str, connection_count: int):
        """记录连接指标"""
        labels = {'service': self.service_name, 'action': action}
        
        self.collector.record_gauge("service_active_connections", connection_count, labels)
    
    def record_resource_usage(self, cpu_percent: float, memory_percent: float, heap_bytes: int):
        """记录资源使用情况"""
        labels = {'service': self.service_name}
        
        self.collector.record_gauge("service_cpu_usage", cpu_percent, labels)
        self.collector.record_gauge("service_memory_usage", memory_percent, labels)
        self.collector.record_gauge("service_heap_size", heap_bytes, labels)

# 性能指标分析
class PerformanceAnalyzer:
    """性能分析器"""
    
    def __init__(self, collector: MetricsCollector):
        self.collector = collector
    
    def analyze_response_time(self, metric_name: str = "service_requests_duration") -> Dict[str, float]:
        """分析响应时间"""
        points = self.collector.get_metric_data(metric_name)
        
        if not points:
            return {}
        
        values = [point.value for point in points]
        values.sort()
        
        count = len(values)
        
        return {
            'count': count,
            'mean': sum(values) / count,
            'min': values[0],
            'max': values[-1],
            'p50': self._percentile(values, 50),
            'p95': self._percentile(values, 95),
            'p99': self._percentile(values, 99),
            'std_dev': self._standard_deviation(values)
        }
    
    def analyze_error_rate(self, window_minutes: int = 5) -> Dict[str, float]:
        """分析错误率"""
        now = time.time()
        window_start = now - (window_minutes * 60)
        
        # 获取请求和错误数据
        request_points = self.collector.get_metric_data("service_requests_total")
        error_points = self.collector.get_metric_data("service_errors_total")
        
        # 过滤窗口内的数据
        window_requests = [p for p in request_points if p.timestamp >= window_start]
        window_errors = [p for p in error_points if p.timestamp >= window_start]
        
        total_requests = sum(p.value for p in window_requests)
        total_errors = sum(p.value for p in window_errors)
        
        error_rate = (total_errors / total_requests) if total_requests > 0 else 0
        
        return {
            'total_requests': total_requests,
            'total_errors': total_errors,
            'error_rate': error_rate,
            'error_percentage': error_rate * 100
        }
    
    def _percentile(self, sorted_values: List[float], percentile: int) -> float:
        """计算百分位数"""
        if not sorted_values:
            return 0
        
        index = (percentile / 100) * (len(sorted_values) - 1)
        
        if index.is_integer():
            return sorted_values[int(index)]
        else:
            lower = sorted_values[int(index)]
            upper = sorted_values[int(index) + 1]
            return lower + (upper - lower) * (index - int(index))
    
    def _standard_deviation(self, values: List[float]) -> float:
        """计算标准差"""
        if len(values) < 2:
            return 0
        
        mean = sum(values) / len(values)
        variance = sum((x - mean) ** 2 for x in values) / (len(values) - 1)
        return variance ** 0.5

# 健康检查器
class HealthChecker:
    """健康检查器"""
    
    def __init__(self):
        self.checks: Dict[str, Callable] = {}
    
    def register_check(self, name: str, check_func: Callable):
        """注册健康检查"""
        self.checks[name] = check_func
    
    async def check_health(self) -> Dict[str, Any]:
        """执行健康检查"""
        results = {}
        overall_status = "healthy"
        
        for name, check_func in self.checks.items():
            try:
                result = await check_func()
                results[name] = {
                    'status': 'healthy' if result else 'unhealthy',
                    'result': result
                }
                
                if not result:
                    overall_status = "unhealthy"
                    
            except Exception as e:
                results[name] = {
                    'status': 'error',
                    'error': str(e)
                }
                overall_status = "error"
        
        return {
            'status': overall_status,
            'checks': results,
            'timestamp': time.time()
        }

# 监控仪表板数据
class MonitoringDashboard:
    """监控仪表板"""
    
    def __init__(self, collector: MetricsCollector, analyzer: PerformanceAnalyzer):
        self.collector = collector
        self.analyzer = analyzer
    
    def get_dashboard_data(self) -> Dict[str, Any]:
        """获取仪表板数据"""
        
        # 获取基础指标
        latest_requests = self.collector.get_latest_value("service_requests_total")
        latest_errors = self.collector.get_latest_value("service_errors_total")
        latest_cpu = self.collector.get_latest_value("service_cpu_usage")
        latest_memory = self.collector.get_latest_value("service_memory_usage")
        
        # 分析性能
        response_time_analysis = self.analyzer.analyze_response_time()
        error_rate_analysis = self.analyzer.analyze_error_rate()
        
        return {
            'overview': {
                'total_requests': latest_requests or 0,
                'total_errors': latest_errors or 0,
                'cpu_usage': latest_cpu or 0,
                'memory_usage': latest_memory or 0,
                'error_rate': error_rate_analysis.get('error_percentage', 0)
            },
            'performance': response_time_analysis,
            'error_analysis': error_rate_analysis,
            'metrics': {
                'request_rate': self._calculate_request_rate(),
                'avg_response_time': response_time_analysis.get('mean', 0),
                'p95_response_time': response_time_analysis.get('p95', 0),
                'success_rate': 100 - error_rate_analysis.get('error_percentage', 0)
            },
            'timestamp': time.time()
        }
    
    def _calculate_request_rate(self) -> float:
        """计算请求速率（请求/秒）"""
        points = self.collector.get_metric_data("service_requests_total")
        
        if len(points) < 2:
            return 0
        
        # 计算最近时间窗口的请求速率
        time_diff = points[-1].timestamp - points[0].timestamp
        if time_diff > 0:
            request_diff = points[-1].value - points[0].value
            return request_diff / time_diff
        
        return 0

# 使用示例
async def example_monitoring():
    """监控使用示例"""
    
    # 创建监控组件
    collector = MetricsCollector()
    monitor = ServiceMonitor(collector, "user-service")
    analyzer = PerformanceAnalyzer(collector)
    dashboard = MonitoringDashboard(collector, analyzer)
    
    # 模拟请求
    import random
    
    for i in range(100):
        duration = random.uniform(50, 500)  # 50-500ms
        status_code = 200 if random.random() > 0.1 else 500
        method = random.choice(['GET', 'POST', 'PUT', 'DELETE'])
        
        monitor.record_request(method, status_code, duration, f"/api/users/{i}")
    
    # 记录资源使用
    monitor.record_resource_usage(
        cpu_percent=random.uniform(10, 80),
        memory_percent=random.uniform(20, 90),
        heap_bytes=random.randint(1000000, 10000000)
    )
    
    # 获取仪表板数据
    data = dashboard.get_dashboard_data()
    print(json.dumps(data, indent=2, default=str))
    
    # 性能分析
    response_analysis = analyzer.analyze_response_time()
    print(f"Response time analysis: {response_analysis}")
    
    error_analysis = analyzer.analyze_error_rate()
    print(f"Error rate analysis: {error_analysis}")
```

## 服务安全治理

### 7. 身份认证与授权
```python
import jwt
import hashlib
import secrets
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import time

class Permission(Enum):
    """权限枚举"""
    READ = "read"
    WRITE = "write"
    DELETE = "delete"
    ADMIN = "admin"
    EXECUTE = "execute"

@dataclass
class User:
    """用户"""
    user_id: str
    username: str
    password_hash: str
    email: str
    roles: List[str]
    permissions: List[Permission]
    is_active: bool = True
    created_at: float = field(default_factory=time.time)
    last_login: Optional[float] = None

@dataclass
class Role:
    """角色"""
    role_id: str
    name: str
    description: str
    permissions: List[Permission]

@dataclass
class AuthToken:
    """认证令牌"""
    token: str
    user_id: str
    expires_at: float
    permissions: List[Permission]

class PasswordHasher:
    """密码哈希器"""
    
    @staticmethod
    def hash_password(password: str, salt: str = None) -> str:
        """哈希密码"""
        if salt is None:
            salt = secrets.token_hex(16)
        
        hash_object = hashlib.pbkdf2_hmac('sha256', 
                                         password.encode('utf-8'), 
                                         salt.encode('utf-8'), 
                                         100000)
        return f"{salt}:{hash_object.hex()}"
    
    @staticmethod
    def verify_password(password: str, hashed_password: str) -> bool:
        """验证密码"""
        try:
            salt, hash_value = hashed_password.split(':')
            calculated_hash = hashlib.pbkdf2_hmac('sha256',
                                                password.encode('utf-8'),
                                                salt.encode('utf-8'),
                                                100000)
            return calculated_hash.hex() == hash_value
        except ValueError:
            return False

class AuthenticationService:
    """认证服务"""
    
    def __init__(self, jwt_secret: str, jwt_expiry: int = 3600):
        self.jwt_secret = jwt_secret
        self.jwt_expiry = jwt_expiry
        self.users: Dict[str, User] = {}
        self.roles: Dict[str, Role] = {}
        self.active_sessions: Dict[str, AuthToken] = {}
    
    def create_role(self, role: Role):
        """创建角色"""
        self.roles[role.role_id] = role
    
    def create_user(self, user: User):
        """创建用户"""
        self.users[user.user_id] = user
    
    async def authenticate(self, username: str, password: str) -> Optional[AuthToken]:
        """用户认证"""
        # 查找用户
        user = None
        for u in self.users.values():
            if u.username == username:
                user = u
                break
        
        if not user or not user.is_active:
            return None
        
        # 验证密码
        if not PasswordHasher.verify_password(password, user.password_hash):
            return None
        
        # 更新最后登录时间
        user.last_login = time.time()
        
        # 生成JWT令牌
        payload = {
            'user_id': user.user_id,
            'username': user.username,
            'exp': time.time() + self.jwt_expiry
        }
        
        token = jwt.encode(payload, self.jwt_secret, algorithm='HS256')
        
        auth_token = AuthToken(
            token=token,
            user_id=user.user_id,
            expires_at=payload['exp'],
            permissions=user.permissions
        )
        
        self.active_sessions[token] = auth_token
        return auth_token
    
    async def validate_token(self, token: str) -> Optional[AuthToken]:
        """验证令牌"""
        try:
            payload = jwt.decode(token, self.jwt_secret, algorithms=['HS256'])
            user_id = payload['user_id']
            
            if token in self.active_sessions:
                return self.active_sessions[token]
            
            # 检查用户是否存在且激活
            user = self.users.get(user_id)
            if user and user.is_active:
                auth_token = AuthToken(
                    token=token,
                    user_id=user_id,
                    expires_at=payload['exp'],
                    permissions=user.permissions
                )
                return auth_token
            
            return None
            
        except jwt.ExpiredSignatureError:
            # 令牌已过期，移除会话
            if token in self.active_sessions:
                del self.active_sessions[token]
            return None
        
        except jwt.InvalidTokenError:
            return None
    
    async def logout(self, token: str):
        """用户登出"""
        if token in self.active_sessions:
            del self.active_sessions[token]
    
    def has_permission(self, auth_token: AuthToken, permission: Permission) -> bool:
        """检查权限"""
        return permission in auth_token.permissions
    
    def has_role(self, user: User, role_name: str) -> bool:
        """检查角色"""
        return role_name in user.roles

class AuthorizationService:
    """授权服务"""
    
    def __init__(self, auth_service: AuthenticationService):
        self.auth_service = auth_service
    
    async def authorize(self, token: str, required_permission: Permission, 
                       resource: str = None) -> bool:
        """授权检查"""
        auth_token = await self.auth_service.validate_token(token)
        
        if not auth_token:
            return False
        
        # 检查权限
        if not self.auth_service.has_permission(auth_token, required_permission):
            return False
        
        # 资源级权限检查（这里可以扩展更复杂的授权逻辑）
        if resource:
            return await self._check_resource_permission(auth_token, required_permission, resource)
        
        return True
    
    async def _check_resource_permission(self, auth_token: AuthToken, 
                                       permission: Permission, resource: str) -> bool:
        """检查资源权限"""
        # 简化的资源权限检查
        # 实际实现应该根据资源类型和权限进行更复杂的检查
        user = self.auth_service.users.get(auth_token.user_id)
        if not user:
            return False
        
        # 管理员拥有所有权限
        if Permission.ADMIN in user.permissions:
            return True
        
        # 根据权限和资源进行具体检查
        if permission == Permission.READ:
            return True  # 简化：读权限总是允许
        elif permission == Permission.WRITE:
            return auth_token.user_id in resource  # 简化：只能写自己的资源
        elif permission == Permission.DELETE:
            return auth_token.user_id in resource  # 简化：只能删除自己的资源
        
        return False

# API网关认证
class APIKeyManager:
    """API密钥管理"""
    
    def __init__(self):
        self.api_keys: Dict[str, Dict] = {}  # API密钥 -> 配置信息
        self.key_prefix = "ak_"
    
    def generate_api_key(self, user_id: str, permissions: List[str], 
                        expiry_days: int = 365) -> str:
        """生成API密钥"""
        # 生成随机密钥
        raw_key = secrets.token_urlsafe(32)
        api_key = f"{self.key_prefix}{raw_key