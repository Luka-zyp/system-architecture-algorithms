# 数据加密系统设计与实现

## 目录
1. [数据加密概述](#数据加密概述)
2. [对称加密](#对称加密)
3. [非对称加密](#非对称加密)
4. [哈希算法](#哈希算法)
5. [数字签名](#数字签名)
6. [密钥管理](#密钥管理)
7. [加密最佳实践](#加密最佳实践)

## 数据加密概述

数据加密是保护敏感信息不被未授权访问的重要手段。通过加密，即使数据被窃取，也无法被轻易解读。

### 加密目标
- **机密性**: 确保数据只能被授权者访问
- **完整性**: 检测数据是否被篡改
- **身份验证**: 验证数据的来源和接收者
- **不可否认性**: 发送者不能否认已发送的数据

### 加密类型
- **对称加密**: 使用相同密钥加密和解密
- **非对称加密**: 使用公钥加密，私钥解密
- **哈希加密**: 单向转换，不可逆

## 对称加密

对称加密使用相同的密钥进行加密和解密，速度快，适合大量数据加密。

```python
import base64
import os
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import hashlib
from typing import Union, Tuple, Optional

class SymmetricEncryption:
    """对称加密管理器"""
    
    def __init__(self):
        self.backend = default_backend()
    
    def generate_key(self, length: int = 32) -> bytes:
        """生成随机密钥"""
        return os.urandom(length)
    
    def derive_key_from_password(self, password: str, salt: bytes = None, 
                                iterations: int = 100000) -> Tuple[bytes, bytes]:
        """从密码派生密钥"""
        if salt is None:
            salt = os.urandom(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=iterations,
            backend=self.backend
        )
        
        key = kdf.derive(password.encode())
        return key, salt
    
    def encrypt_aes_256_gcm(self, plaintext: str, key: bytes) -> str:
        """AES-256-GCM加密"""
        # 生成随机IV
        iv = os.urandom(12)
        
        # 创建加密器
        cipher = Cipher(
            algorithms.AES(key),
            modes.GCM(iv),
            backend=self.backend
        )
        encryptor = cipher.encryptor()
        
        # 加密
        ciphertext = encryptor.update(plaintext.encode()) + encryptor.finalize()
        
        # 获取认证标签
        tag = encryptor.tag
        
        # 组合结果: IV + 标签 + 密文
        result = iv + tag + ciphertext
        return base64.b64encode(result).decode()
    
    def decrypt_aes_256_gcm(self, encrypted_data: str, key: bytes) -> Optional[str]:
        """AES-256-GCM解密"""
        try:
            # 解码base64
            data = base64.b64decode(encrypted_data.encode())
            
            # 提取IV、标签和密文
            iv = data[:12]
            tag = data[12:28]
            ciphertext = data[28:]
            
            # 创建解密器
            cipher = Cipher(
                algorithms.AES(key),
                modes.GCM(iv, tag),
                backend=self.backend
            )
            decryptor = cipher.decryptor()
            
            # 解密
            plaintext = decryptor.update(ciphertext) + decryptor.finalize()
            return plaintext.decode()
        
        except Exception:
            return None
    
    def encrypt_fernet(self, plaintext: str, key: bytes) -> str:
        """Fernet加密"""
        f = Fernet(key)
        return f.encrypt(plaintext.encode()).decode()
    
    def decrypt_fernet(self, encrypted_data: str, key: bytes) -> Optional[str]:
        """Fernet解密"""
        try:
            f = Fernet(key)
            return f.decrypt(encrypted_data.encode()).decode()
        except Exception:
            return None
    
    def encrypt_file(self, file_path: str, key: bytes, output_path: str = None) -> str:
        """加密文件"""
        if output_path is None:
            output_path = file_path + '.encrypted'
        
        with open(file_path, 'rb') as f:
            data = f.read()
        
        encrypted = self.encrypt_aes_256_gcm(data.decode('latin1'), key)
        
        with open(output_path, 'w') as f:
            f.write(encrypted)
        
        return output_path
    
    def decrypt_file(self, encrypted_file_path: str, key: bytes, 
                    output_path: str = None) -> Optional[str]:
        """解密文件"""
        if output_path is None:
            output_path = encrypted_file_path.replace('.encrypted', '')
        
        try:
            with open(encrypted_file_path, 'r') as f:
                encrypted_data = f.read()
            
            decrypted = self.decrypt_aes_256_gcm(encrypted_data, key)
            if decrypted is None:
                return None
            
            with open(output_path, 'wb') as f:
                f.write(decrypted.encode('latin1'))
            
            return output_path
        
        except Exception:
            return None

class FileEncryption:
    """文件加密工具"""
    def __init__(self):
        self.encryptor = SymmetricEncryption()
    
    def encrypt_directory(self, directory_path: str, key: bytes, 
                         exclude_extensions: list = None) -> Dict[str, str]:
        """递归加密目录"""
        if exclude_extensions is None:
            exclude_extensions = ['.encrypted', '.key', '.pyc', '__pycache__']
        
        encrypted_files = {}
        
        for root, dirs, files in os.walk(directory_path):
            # 跳过加密文件和缓存目录
            files = [f for f in files if not any(f.endswith(ext) for ext in exclude_extensions)]
            
            for file in files:
                file_path = os.path.join(root, file)
                
                try:
                    encrypted_path = self.encryptor.encrypt_file(file_path, key)
                    encrypted_files[file_path] = encrypted_path
                    print(f"Encrypted: {file_path}")
                except Exception as e:
                    print(f"Failed to encrypt {file_path}: {e}")
        
        return encrypted_files
    
    def decrypt_directory(self, directory_path: str, key: bytes) -> Dict[str, str]:
        """递归解密目录"""
        decrypted_files = {}
        
        for root, dirs, files in os.walk(directory_path):
            encrypted_files = [f for f in files if f.endswith('.encrypted')]
            
            for file in encrypted_files:
                encrypted_path = os.path.join(root, file)
                
                try:
                    decrypted_path = self.encryptor.decrypt_file(encrypted_path, key)
                    if decrypted_path:
                        decrypted_files[encrypted_path] = decrypted_path
                        print(f"Decrypted: {encrypted_path}")
                except Exception as e:
                    print(f"Failed to decrypt {encrypted_path}: {e}")
        
        return decrypted_files
```

## 非对称加密

非对称加密使用一对密钥：公钥加密，私钥解密。安全性高，适合密钥交换和数字签名。

```python
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric.utils import encode_dss_signature, decode_dss_signature
from cryptography.hazmat.primitives.asymmetric import utils
import base64

class AsymmetricEncryption:
    """非对称加密管理器"""
    
    def __init__(self):
        pass
    
    def generate_keypair(self, key_size: int = 2048) -> Tuple[bytes, bytes]:
        """生成RSA密钥对"""
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=key_size,
            backend=default_backend()
        )
        
        # 序列化私钥
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        # 获取公钥
        public_key = private_key.public_key()
        
        # 序列化公钥
        public_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        return private_pem, public_pem
    
    def encrypt_with_public_key(self, plaintext: str, public_key_pem: bytes) -> str:
        """使用公钥加密"""
        public_key = serialization.load_pem_public_key(
            public_key_pem,
            backend=default_backend()
        )
        
        ciphertext = public_key.encrypt(
            plaintext.encode(),
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        return base64.b64encode(ciphertext).decode()
    
    def decrypt_with_private_key(self, encrypted_data: str, private_key_pem: bytes) -> Optional[str]:
        """使用私钥解密"""
        try:
            private_key = serialization.load_pem_private_key(
                private_key_pem,
                password=None,
                backend=default_backend()
            )
            
            ciphertext = base64.b64decode(encrypted_data.encode())
            
            plaintext = private_key.decrypt(
                ciphertext,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            
            return plaintext.decode()
        
        except Exception:
            return None
    
    def save_keys_to_files(self, private_key: bytes, public_key: bytes, 
                          private_file: str, public_file: str):
        """保存密钥到文件"""
        with open(private_file, 'wb') as f:
            f.write(private_key)
        
        with open(public_file, 'wb') as f:
            f.write(public_key)
    
    def load_keys_from_files(self, private_file: str, public_file: str) -> Tuple[bytes, bytes]:
        """从文件加载密钥"""
        with open(private_file, 'rb') as f:
            private_key = f.read()
        
        with open(public_file, 'rb') as f:
            public_key = f.read()
        
        return private_key, public_key
```

## 哈希算法

哈希算法将任意长度的输入转换为固定长度的输出，具有单向性和唯一性。

```python
import hashlib
import hmac
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from typing import Union

class HashManager:
    """哈希算法管理器"""
    
    def __init__(self):
        pass
    
    def hash_md5(self, data: Union[str, bytes]) -> str:
        """MD5哈希（仅用于兼容性，不推荐用于安全用途）"""
        if isinstance(data, str):
            data = data.encode()
        
        return hashlib.md5(data).hexdigest()
    
    def hash_sha256(self, data: Union[str, bytes]) -> str:
        """SHA-256哈希"""
        if isinstance(data, str):
            data = data.encode()
        
        return hashlib.sha256(data).hexdigest()
    
    def hash_sha512(self, data: Union[str, bytes]) -> str:
        """SHA-512哈希"""
        if isinstance(data, str):
            data = data.encode()
        
        return hashlib.sha512(data).hexdigest()
    
    def hash_file(self, file_path: str, algorithm: str = 'sha256') -> str:
        """计算文件哈希"""
        hash_func = getattr(hashlib, algorithm)()
        
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_func.update(chunk)
        
        return hash_func.hexdigest()
    
    def hmac_sha256(self, data: Union[str, bytes], key: Union[str, bytes]) -> str:
        """HMAC-SHA256"""
        if isinstance(data, str):
            data = data.encode()
        
        if isinstance(key, str):
            key = key.encode()
        
        return hmac.new(key, data, hashlib.sha256).hexdigest()
    
    def derive_key_hkdf(self, master_key: bytes, salt: bytes, 
                        info: bytes, length: int = 32) -> bytes:
        """使用HKDF派生密钥"""
        hkdf = HKDF(
            algorithm=hashes.SHA256(),
            length=length,
            salt=salt,
            info=info,
            backend=default_backend()
        )
        
        return hkdf.derive(master_key)
    
    def verify_password(self, password: str, stored_hash: str, salt: str = None) -> bool:
        """验证密码"""
        if salt:
            password_with_salt = password + salt
            calculated_hash = self.hash_sha256(password_with_salt)
        else:
            calculated_hash = self.hash_sha256(password)
        
        return calculated_hash == stored_hash

class PasswordHasher:
    """密码哈希工具"""
    def __init__(self):
        self.hash_manager = HashManager()
    
    def hash_password(self, password: str, salt: str = None) -> Tuple[str, str]:
        """安全地哈希密码"""
        if salt is None:
            salt = os.urandom(16).hex()
        
        # 使用PBKDF2进行密码哈希
        password_bytes = password.encode()
        salt_bytes = bytes.fromhex(salt)
        
       dk = hashlib.pbkdf2_hmac('sha256', password_bytes, salt_bytes, 100000)
        hash_hex = dk.hex()
        
        return hash_hex, salt
    
    def verify_password(self, password: str, stored_hash: str, salt: str) -> bool:
        """验证密码"""
        calculated_hash, _ = self.hash_password(password, salt)
        return calculated_hash == stored_hash
    
    def generate_random_password(self, length: int = 12) -> str:
        """生成随机密码"""
        import string
        import secrets
        
        characters = string.ascii_letters + string.digits + "!@#$%^&*"
        return ''.join(secrets.choice(characters) for _ in range(length))
```

## 数字签名

数字签名使用私钥对数据签名，使用公钥验证签名，确保数据的完整性和不可否认性。

```python
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import utils
from cryptography.hazmat.primitives import hashes, serialization
import base64

class DigitalSignature:
    """数字签名管理器"""
    
    def __init__(self):
        pass
    
    def sign_data(self, data: Union[str, bytes], private_key_pem: bytes) -> str:
        """使用私钥签名数据"""
        private_key = serialization.load_pem_private_key(
            private_key_pem,
            password=None,
            backend=default_backend()
        )
        
        if isinstance(data, str):
            data = data.encode()
        
        signature = private_key.sign(
            data,
            padding.PSS(
                mgf=padding.MGF1(hashes.SHA256()),
                salt_length=padding.PSS.MAX_LENGTH
            ),
            hashes.SHA256()
        )
        
        return base64.b64encode(signature).decode()
    
    def verify_signature(self, data: Union[str, bytes], signature_b64: str, 
                        public_key_pem: bytes) -> bool:
        """验证数字签名"""
        try:
            public_key = serialization.load_pem_public_key(
                public_key_pem,
                backend=default_backend()
            )
            
            if isinstance(data, str):
                data = data.encode()
            
            signature = base64.b64decode(signature_b64.encode())
            
            public_key.verify(
                signature,
                data,
                padding.PSS(
                    mgf=padding.MGF1(hashes.SHA256()),
                    salt_length=padding.PSS.MAX_LENGTH
                ),
                hashes.SHA256()
            )
            
            return True
        
        except Exception:
            return False
    
    def sign_file(self, file_path: str, private_key_pem: bytes) -> str:
        """签名文件"""
        with open(file_path, 'rb') as f:
            file_data = f.read()
        
        # 计算文件哈希
        hash_manager = HashManager()
        file_hash = hash_manager.hash_sha256(file_data)
        
        # 签名哈希
        signature = self.sign_data(file_hash, private_key_pem)
        
        return signature
    
    def verify_file_signature(self, file_path: str, signature_b64: str, 
                             public_key_pem: bytes) -> bool:
        """验证文件签名"""
        with open(file_path, 'rb') as f:
            file_data = f.read()
        
        # 计算文件哈希
        hash_manager = HashManager()
        file_hash = hash_manager.hash_sha256(file_data)
        
        # 验证签名
        return self.verify_signature(file_hash, signature_b64, public_key_pem)
```

## 密钥管理

密钥管理是加密系统的重要组成部分，涉及密钥的生成、存储、分发和销毁。

```python
import json
import time
from typing import Dict, List, Optional
from datetime import datetime, timedelta

class KeyMetadata:
    """密钥元数据"""
    def __init__(self, key_id: str, key_type: str, algorithm: str, 
                 created_at: datetime, expires_at: datetime = None):
        self.key_id = key_id
        self.key_type = key_type  # symmetric, asymmetric, hmac
        self.algorithm = algorithm  # aes-256-gcm, rsa-2048, sha-256
        self.created_at = created_at
        self.expires_at = expires_at
        self.is_active = True
        self.usage_count = 0
        self.last_used = None
    
    def to_dict(self) -> Dict:
        return {
            'key_id': self.key_id,
            'key_type': self.key_type,
            'algorithm': self.algorithm,
            'created_at': self.created_at.isoformat(),
            'expires_at': self.expires_at.isoformat() if self.expires_at else None,
            'is_active': self.is_active,
            'usage_count': self.usage_count,
            'last_used': self.last_used.isoformat() if self.last_used else None
        }

class KeyManager:
    """密钥管理器"""
    def __init__(self, storage_path: str = "keys.json"):
        self.storage_path = storage_path
        self.keys: Dict[str, bytes] = {}  # key_id -> encrypted_key
        self.metadata: Dict[str, KeyMetadata] = {}  # key_id -> metadata
        self.encryption_key = None  # 用于加密存储密钥的密钥
        self.symmetric_encryptor = SymmetricEncryption()
        
    def initialize(self, master_password: str):
        """初始化密钥管理器"""
        # 生成或加载主密钥
        if os.path.exists(self.storage_path):
            self._load_keys()
        else:
            # 创建新的主密钥
            self._create_master_key(master_password)
    
    def _create_master_key(self, password: str):
        """创建主密钥"""
        key, salt = self.symmetric_encryptor.derive_key_from_password(password)
        self.encryption_key = key
        
        # 保存盐值和加密的主密钥
        master_key_data = {
            'salt': base64.b64encode(salt).decode(),
            'encrypted_master_key': self.symmetric_encryptor.encrypt_aes_256_gcm(
                base64.b64encode(key).decode(), key
            )
        }
        
        with open(self.storage_path, 'w') as f:
            json.dump(master_key_data, f)
    
    def _load_keys(self):
        """从文件加载密钥"""
        with open(self.storage_path, 'r') as f:
            data = json.load(f)
        
        salt = base64.b64decode(data['salt'])
        encrypted_master_key = data['encrypted_master_key']
        
        # 这里简化处理，实际应用中需要解密
        # self.encryption_key = ...
    
    def generate_key(self, key_type: str = 'symmetric', algorithm: str = 'aes-256-gcm',
                    key_id: str = None, expires_in_days: int = 365) -> str:
        """生成新密钥"""
        if not key_id:
            key_id = f"{key_type}_{algorithm}_{int(time.time())}"
        
        if key_type == 'symmetric':
            if algorithm == 'aes-256-gcm':
                key = self.symmetric_encryptor.generate_key(32)
            else:
                raise ValueError(f"Unsupported symmetric algorithm: {algorithm}")
        
        elif key_type == 'asymmetric':
            if algorithm.startswith('rsa'):
                key_size = int(algorithm.split('-')[1])
                private_key, public_key = AsymmetricEncryption().generate_keypair(key_size)
                key = private_key  # 存储私钥
            else:
                raise ValueError(f"Unsupported asymmetric algorithm: {algorithm}")
        
        else:
            raise ValueError(f"Unsupported key type: {key_type}")
        
        # 创建元数据
        expires_at = datetime.now() + timedelta(days=expires_in_days)
        metadata = KeyMetadata(key_id, key_type, algorithm, datetime.now(), expires_at)
        
        # 存储密钥和元数据
        self.keys[key_id] = key
        self.metadata[key_id] = metadata
        
        return key_id
    
    def get_key(self, key_id: str) -> Optional[bytes]:
        """获取密钥"""
        if key_id not in self.keys:
            return None
        
        metadata = self.metadata[key_id]
        if not metadata.is_active or (metadata.expires_at and metadata.expires_at < datetime.now()):
            return None
        
        metadata.usage_count += 1
        metadata.last_used = datetime.now()
        
        return self.keys[key_id]
    
    def revoke_key(self, key_id: str):
        """撤销密钥"""
        if key_id in self.metadata:
            self.metadata[key_id].is_active = False
    
    def delete_key(self, key_id: str):
        """删除密钥"""
        if key_id in self.keys:
            del self.keys[key_id]
        if key_id in self.metadata:
            del self.metadata[key_id]
    
    def list_keys(self, key_type: str = None) -> List[Dict]:
        """列出所有密钥"""
        result = []
        for key_id, metadata in self.metadata.items():
            if key_type and metadata.key_type != key_type:
                continue
            
            result.append({
                'key_id': key_id,
                'metadata': metadata.to_dict()
            })
        
        return result
    
    def get_key_info(self, key_id: str) -> Optional[Dict]:
        """获取密钥信息"""
        if key_id not in self.metadata:
            return None
        
        return self.metadata[key_id].to_dict()
    
    def rotate_keys(self, old_key_id: str, new_key_id: str = None) -> str:
        """密钥轮换"""
        if old_key_id not in self.keys:
            raise ValueError(f"Key {old_key_id} not found")
        
        old_metadata = self.metadata[old_key_id]
        
        # 生成新密钥
        if not new_key_id:
            new_key_id = f"{old_metadata.key_type}_{old_metadata.algorithm}_{int(time.time())}"
        
        new_metadata = KeyMetadata(
            new_key_id,
            old_metadata.key_type,
            old_metadata.algorithm,
            datetime.now(),
            old_metadata.expires_at
        )
        
        # 生成新密钥
        if old_metadata.key_type == 'symmetric':
            if old_metadata.algorithm == 'aes-256-gcm':
                new_key = self.symmetric_encryptor.generate_key(32)
            else:
                raise ValueError(f"Unsupported algorithm: {old_metadata.algorithm}")
        elif old_metadata.key_type == 'asymmetric':
            if old_metadata.algorithm.startswith('rsa'):
                key_size = int(old_metadata.algorithm.split('-')[1])
                private_key, _ = AsymmetricEncryption().generate_keypair(key_size)
                new_key = private_key
            else:
                raise ValueError(f"Unsupported algorithm: {old_metadata.algorithm}")
        else:
            raise ValueError(f"Unsupported key type: {old_metadata.key_type}")
        
        # 存储新密钥
        self.keys[new_key_id] = new_key
        self.metadata[new_key_id] = new_metadata
        
        # 撤销旧密钥
        self.revoke_key(old_key_id)
        
        return new_key_id
    
    def backup_keys(self, backup_path: str, password: str):
        """备份密钥"""
        backup_data = {
            'metadata': {kid: meta.to_dict() for kid, meta in self.metadata.items()},
            'created_at': datetime.now().isoformat()
        }
        
        with open(backup_path, 'w') as f:
            json.dump(backup_data, f, indent=2)
        
        print(f"Key backup created at: {backup_path}")
    
    def restore_keys(self, backup_path: str):
        """恢复密钥"""
        with open(backup_path, 'r') as f:
            backup_data = json.load(f)
        
        # 恢复元数据
        for key_id, meta_dict in backup_data['metadata'].items():
            expires_at = datetime.fromisoformat(meta_dict['expires_at']) if meta_dict['expires_at'] else None
            metadata = KeyMetadata(
                key_id, meta_dict['key_type'], meta_dict['algorithm'],
                datetime.fromisoformat(meta_dict['created_at']), expires_at
            )
            metadata.is_active = meta_dict['is_active']
            metadata.usage_count = meta_dict['usage_count']
            metadata.last_used = datetime.fromisoformat(meta_dict['last_used']) if meta_dict['last_used'] else None
            
            self.metadata[key_id] = metadata
        
        print(f"Key metadata restored from: {backup_path}")
```

## 加密最佳实践

```python
class EncryptionBestPractices:
    """加密最佳实践工具"""
    
    @staticmethod
    def validate_encryption_setup() -> Dict[str, bool]:
        """验证加密设置"""
        checks = {
            'cryptography_library_available': False,
            'secure_random_generator': False,
            'key_length_adequate': False,
            'modern_algorithms': False
        }
        
        try:
            import cryptography
            checks['cryptography_library_available'] = True
            
            # 检查安全随机数生成器
            random_bytes = os.urandom(32)
            checks['secure_random_generator'] = len(random_bytes) == 32
            
            # 检查密钥长度
            checks['key_length_adequate'] = True  # AES-256, RSA-2048+
            
            # 检查算法
            checks['modern_algorithms'] = True  # 使用AES-256-GCM, SHA-256等
        
        except Exception:
            pass
        
        return checks
    
    @staticmethod
    def security_audit_encrypted_data(data: str, key: bytes) -> Dict[str, Any]:
        """安全审计加密数据"""
        audit_results = {
            'data_entropy': 0,
            'key_strength': 0,
            'encryption_quality': 'unknown',
            'recommendations': []
        }
        
        # 计算数据熵
        from collections import Counter
        import math
        
        byte_data = data.encode() if isinstance(data, str) else data
        byte_counts = Counter(byte_data)
        byte_probabilities = [count / len(byte_data) for count in byte_counts.values()]
        entropy = -sum(p * math.log2(p) for p in byte_probabilities if p > 0)
        
        audit_results['data_entropy'] = entropy
        
        # 评估密钥强度
        audit_results['key_strength'] = len(key) * 8  # 比特数
        
        # 评估加密质量
        if entropy > 7.5:
            audit_results['encryption_quality'] = 'excellent'
        elif entropy > 6.0:
            audit_results['encryption_quality'] = 'good'
        elif entropy > 4.0:
            audit_results['encryption_quality'] = 'fair'
        else:
            audit_results['encryption_quality'] = 'poor'
            audit_results['recommendations'].append('Consider using a different encryption method')
        
        # 生成建议
        if audit_results['key_strength'] < 128:
            audit_results['recommendations'].append('Use longer encryption keys')
        
        if audit_results['encryption_quality'] == 'poor':
            audit_results['recommendations'].append('Verify encryption implementation')
        
        return audit_results
    
    @staticmethod
    def create_encrypted_backup(source_path: str, backup_dir: str, 
                               password: str) -> str:
        """创建加密备份"""
        encryptor = SymmetricEncryption()
        
        # 生成备份文件名
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_filename = f"backup_{timestamp}.encrypted"
        backup_path = os.path.join(backup_dir, backup_filename)
        
        # 派生密钥
        key, salt = encryptor.derive_key_from_password(password)
        
        # 读取源数据
        with open(source_path, 'rb') as f:
            data = f.read()
        
        # 加密数据
        encrypted_data = encryptor.encrypt_aes_256_gcm(data.decode('latin1'), key)
        
        # 创建备份元数据
        backup_metadata = {
            'source_file': source_path,
            'backup_time': datetime.now().isoformat(),
            'algorithm': 'AES-256-GCM',
            'salt': base64.b64encode(salt).decode(),
            'original_size': len(data),
            'encrypted_data': encrypted_data
        }
        
        # 保存备份
        with open(backup_path, 'w') as f:
            json.dump(backup_metadata, f, indent=2)
        
        return backup_path
    
    @staticmethod
    def restore_encrypted_backup(backup_path: str, password: str, 
                                restore_path: str) -> bool:
        """恢复加密备份"""
        encryptor = SymmetricEncryption()
        
        try:
            # 读取备份元数据
            with open(backup_path, 'r') as f:
                backup_metadata = json.load(f)
            
            # 重建密钥
            salt = base64.b64decode(backup_metadata['salt'])
            key, _ = encryptor.derive_key_from_password(password, salt)
            
            # 解密数据
            encrypted_data = backup_metadata['encrypted_data']
            decrypted_data = encryptor.decrypt_aes_256_gcm(encrypted_data, key)
            
            if decrypted_data is None:
                return False
            
            # 恢复文件
            with open(restore_path, 'wb') as f:
                f.write(decrypted_data.encode('latin1'))
            
            return True
        
        except Exception as e:
            print(f"Restore failed: {e}")
            return False
```

## 总结

数据加密系统设计需要考虑：
1. **选择合适的加密算法**: 根据数据敏感度和性能要求选择
2. **密钥管理**: 安全地生成、存储、分发和销毁密钥
3. **性能优化**: 平衡安全性与性能需求
4. **合规性**: 满足行业标准和法规要求
5. **密钥轮换**: 定期更新加密密钥
6. **审计跟踪**: 记录所有加密操作

良好的加密系统应该提供强大的安全保护，同时保持良好的性能和易用性。

---
*文档更新时间: 2024年12月*