# Weighted Round Robin 负载均衡算法详解

## 目录
1. [算法概述](#算法概述)
2. [算法原理](#算法原理)
3. [Python实现](#python实现)
4. [Go语言实现](#go-language实现)
5. [算法变种](#算法变种)
6. [动态权重调整](#动态权重调整)
7. [性能分析](#性能分析)
8. [适用场景](#适用场景)
9. [故障处理](#故障处理)
10. [监控指标](#监控指标)
11. [实战案例](#实战案例)

## 算法概述

### 什么是Weighted Round Robin

Weighted Round Robin（加权轮询）是Round Robin算法的增强版本，通过为每个服务器分配权重值来实现更智能的负载均衡。该算法在保持简单性的同时，能够根据服务器的性能差异进行比例分配。

### 核心特性

```python
from typing import List, Dict, Optional, Any, Callable, Tuple
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import random
import statistics
import json
import logging
import heapq
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor, as_completed
import copy
from abc import ABC, abstractmethod
import math

@dataclass
class WeightedServer:
    """加权服务器节点"""
    id: str
    hostname: str
    port: int
    weight: float = 1.0
    
    # 当前权重状态
    current_weight: float = 0.0
    effective_weight: float = 1.0
    running_weight: float = 1.0
    
    # 动态权重管理
    base_weight: float = 1.0  # 基础权重
    dynamic_weight: float = 1.0  # 动态权重
    last_weight_update: float = field(default_factory=time.time)
    
    # 健康状态
    is_healthy: bool = True
    last_health_check: float = field(default_factory=time.time)
    failure_count: int = 0
    health_score: float = 1.0
    
    # 性能指标
    response_times: deque = field(default_factory=lambda: deque(maxlen=100))
    avg_response_time: float = 0.0
    total_requests: int = 0
    success_requests: int = 0
    failure_requests: int = 0
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    
    # 统计信息
    round_robin_counter: int = 0  # 轮询计数
    weight_sum: float = 0.0  # 当前轮询周期权重和
    
    def __post_init__(self):
        """初始化后处理"""
        self.current_weight = 0.0
        self.effective_weight = self.weight * self.health_score
        self.running_weight = self.effective_weight
        self.base_weight = self.weight
        self.dynamic_weight = 1.0
    
    def update_health_score(self, new_score: float):
        """更新健康分数"""
        self.health_score = max(0.0, min(1.0, new_score))
        self.update_effective_weight()
        
        if self.health_score < 0.3:  # 健康分数过低
            self.is_healthy = False
        elif self.health_score > 0.7:  # 健康分数恢复
            self.is_healthy = True
    
    def update_effective_weight(self):
        """更新有效权重"""
        old_effective = self.effective_weight
        self.effective_weight = self.base_weight * self.dynamic_weight * self.health_score
        
        if abs(old_effective - self.effective_weight) > 0.01:
            self.last_weight_update = time.time()
    
    def calculate_dynamic_weight(self):
        """计算动态权重"""
        now = time.time()
        
        # 基于响应时间的权重调整
        if self.avg_response_time > 0:
            # 响应时间越慢，权重越低
            time_factor = max(0.5, min(1.5, 1000.0 / (self.avg_response_time + 100)))
        else:
            time_factor = 1.0
        
        # 基于成功率的权重调整
        total_requests = self.success_requests + self.failure_requests
        if total_requests > 0:
            success_rate = self.success_requests / total_requests
            success_factor = max(0.3, success_rate)
        else:
            success_factor = 1.0
        
        # 基于系统负载的权重调整
        system_load = (self.cpu_usage + self.memory_usage) / 2.0 / 100.0
        load_factor = max(0.3, 1.0 - system_load)
        
        # 综合动态权重
        new_dynamic_weight = time_factor * success_factor * load_factor
        
        # 平滑权重变化
        smoothing_factor = 0.1
        self.dynamic_weight = self.dynamic_weight * (1 - smoothing_factor) + new_dynamic_weight * smoothing_factor
        
        self.update_effective_weight()
    
    def increment_round_robin(self, weight_used: float):
        """轮询计数增加"""
        self.round_robin_counter += 1
        self.weight_sum += weight_used
    
    def reset_round_robin_cycle(self):
        """重置轮询周期"""
        self.round_robin_counter = 0
        self.weight_sum = 0.0
        self.current_weight = 0.0

class WeightedRoundRobinStrategy(Enum):
    """加权轮询策略"""
    BASIC_WEIGHTED_RR = "basic"
    SMOOTH_WEIGHTED_RR = "smooth"  # Nginx算法
    ADAPTIVE_WEIGHTED_RR = "adaptive"
    CONSISTENT_HASH_WEIGHTED_RR = "consistent_hash"

@dataclass
class WeightAdjustment:
    """权重调整配置"""
    base_weight: float
    min_weight: float = 0.1
    max_weight: float = 10.0
    adjustment_interval: float = 30.0  # 秒
    response_time_threshold: float = 2000.0  # 毫秒
    success_rate_threshold: float = 0.95
    health_check_interval: float = 10.0  # 秒

class WeightedRoundRobinLoadBalancer:
    """加权轮询负载均衡器"""
    
    def __init__(self, strategy: WeightedRoundRobinStrategy = WeightedRoundRobinStrategy.SMOOTH_WEIGHTED_RR):
        self.strategy = strategy
        self.servers: List[WeightedServer] = []
        self.weight_config = WeightAdjustment(base_weight=1.0)
        self.metrics = {}
        self.mutex = threading.RLock()
        self.last_weight_adjustment = time.time()
        
        # 轮询状态
        self.current_weight = 0.0
        self.total_weight = 0.0
        self.round_robin_sequence = 0
        self.weighted_sequence = {}
        
        # 设置日志
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("WeightedRR")
    
    def add_server(self, server: WeightedServer):
        """添加服务器"""
        with self.mutex:
            server.effective_weight = server.weight * server.health_score
            self.servers.append(server)
            self.weighted_sequence[server.id] = 0
            self.total_weight += server.effective_weight
        
        self.logger.info(f"Added weighted server: {server.hostname}:{server.port} (weight: {server.weight})")
    
    def remove_server(self, server_id: str):
        """移除服务器"""
        with self.mutex:
            self.servers = [s for s in self.servers if s.id != server_id]
            
            if server_id in self.weighted_sequence:
                self.total_weight -= self.weighted_sequence[server_id]
                del self.weighted_sequence[server_id]
        
        self.logger.info(f"Removed weighted server: {server_id}")
    
    def get_next_server(self) -> Optional[WeightedServer]:
        """获取下一个服务器"""
        with self.mutex:
            # 定期调整权重
            self._adjust_weights_if_needed()
            
            healthy_servers = [s for s in self.servers if s.is_healthy]
            
            if not healthy_servers:
                self.logger.warning("No healthy servers available")
                return None
            
            if self.strategy == WeightedRoundRobinStrategy.BASIC_WEIGHTED_RR:
                return self._basic_weighted_round_robin(healthy_servers)
            elif self.strategy == WeightedRoundRobinStrategy.SMOOTH_WEIGHTED_RR:
                return self._smooth_weighted_round_robin(healthy_servers)
            elif self.strategy == WeightedRoundRobinStrategy.ADAPTIVE_WEIGHTED_RR:
                return self._adaptive_weighted_round_robin(healthy_servers)
            else:
                return self._smooth_weighted_round_robin(healthy_servers)
    
    def _basic_weighted_round_robin(self, healthy_servers: List[WeightedServer]) -> WeightedServer:
        """基础加权轮询"""
        # 计算每个服务器的理论分配次数
        total_weight = sum(server.weight for server in healthy_servers)
        
        if total_weight == 0:
            return random.choice(healthy_servers)
        
        # 基于权重选择服务器
        cumulative_weights = []
        current_sum = 0
        
        for server in healthy_servers:
            current_sum += server.weight
            cumulative_weights.append((current_sum, server))
        
        # 随机选择权重位置
        random_weight = random.uniform(0, total_weight)
        
        for cumulative_weight, server in cumulative_weights:
            if random_weight <= cumulative_weight:
                return server
        
        return cumulative_weights[-1][1]  # 兜底
    
    def _smooth_weighted_round_robin(self, healthy_servers: List[WeightedServer]) -> WeightedServer:
        """平滑加权轮询（Nginx算法）"""
        if not healthy_servers:
            return None
        
        # 找到权重最大的服务器
        selected_server = None
        max_current_weight = float('-inf')
        
        for server in healthy_servers:
            server.current_weight += server.effective_weight
            
            if server.current_weight > max_current_weight:
                max_current_weight = server.current_weight
                selected_server = server
        
        if selected_server:
            # 选中服务器权重减少总和
            selected_server.current_weight -= self.total_weight
        
        return selected_server
    
    def _adaptive_weighted_round_robin(self, healthy_servers: List[WeightedServer]) -> WeightedServer:
        """自适应加权轮询"""
        # 更新所有服务器的动态权重
        for server in healthy_servers:
            server.calculate_dynamic_weight()
            self.total_weight += server.effective_weight - server.last_total_weight if hasattr(server, 'last_total_weight') else server.effective_weight
            if not hasattr(server, 'last_total_weight'):
                server.last_total_weight = 0
            server.last_total_weight = server.effective_weight
        
        # 应用平滑加权轮询
        return self._smooth_weighted_round_robin(healthy_servers)
    
    def _adjust_weights_if_needed(self):
        """必要时调整权重"""
        now = time.time()
        
        if now - self.last_weight_adjustment < self.weight_config.adjustment_interval:
            return
        
        self.last_weight_adjustment = now
        
        # 更新服务器权重
        for server in self.servers:
            if hasattr(server, 'last_health_check'):
                health_age = now - server.last_health_check
                if health_age > self.weight_config.health_check_interval:
                    self._perform_health_check(server)
            
            server.calculate_dynamic_weight()
    
    def _perform_health_check(self, server: WeightedServer):
        """执行健康检查"""
        try:
            # 模拟健康检查过程
            time.sleep(0.1)
            
            # 基于性能指标计算健康分数
            health_factors = []
            
            # 响应时间健康度
            if server.avg_response_time > 0:
                response_health = max(0.0, min(1.0, 1.0 - (server.avg_response_time / 5000.0)))
                health_factors.append(response_health)
            
            # 成功率健康度
            total_requests = server.success_requests + server.failure_requests
            if total_requests > 0:
                success_rate = server.success_requests / total_requests
                success_health = max(0.0, min(1.0, success_rate))
                health_factors.append(success_health)
            
            # 系统负载健康度
            system_health = max(0.0, min(1.0, 1.0 - ((server.cpu_usage + server.memory_usage) / 2.0 / 100.0)))
            health_factors.append(system_health)
            
            # 综合健康分数
            if health_factors:
                new_health_score = sum(health_factors) / len(health_factors)
                server.update_health_score(new_health_score)
            
            server.last_health_check = now
            
        except Exception as e:
            self.logger.error(f"Health check failed for {server.hostname}: {str(e)}")
            server.update_health_score(0.0)
    
    def distribute_request(self, client_id: str, request_type: str = "normal") -> Dict[str, Any]:
        """分发请求"""
        start_time = time.time()
        
        # 选择服务器
        selected_server = self.get_next_server()
        
        if not selected_server:
            return {
                "success": False,
                "error": "No available servers",
                "response_time": 0.0
            }
        
        try:
            # 模拟请求处理
            processing_time = self._simulate_processing_time(request_type, selected_server)
            time.sleep(processing_time)
            
            # 模拟请求结果
            success = random.random() < selected_server.health_score
            response_time = time.time() - start_time
            
            # 更新服务器统计
            self._update_server_stats(selected_server, response_time, success)
            
            return {
                "success": True,
                "server": selected_server.hostname,
                "weight": selected_server.effective_weight,
                "response_time": response_time,
                "processing_time": processing_time,
                "request_type": request_type
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "server": selected_server.hostname,
                "response_time": time.time() - start_time
            }
    
    def _simulate_processing_time(self, request_type: str, server: WeightedServer) -> float:
        """模拟处理时间"""
        base_time = {
            "normal": 0.1,
            "api": 0.05,
            "file_upload": 0.5,
            "database": 0.2,
            "computation": 1.0
        }.get(request_type, 0.1)
        
        # 基于服务器性能调整
        performance_factor = server.health_score
        noise_factor = random.uniform(0.8, 1.2)
        
        return base_time * (2.0 - performance_factor) * noise_factor
    
    def _update_server_stats(self, server: WeightedServer, response_time: float, success: bool):
        """更新服务器统计"""
        # 更新响应时间
        server.response_times.append(response_time)
        server.avg_response_time = statistics.mean(server.response_times)
        
        # 更新请求计数
        server.total_requests += 1
        
        if success:
            server.success_requests += 1
        else:
            server.failure_requests += 1
        
        # 更新轮询计数
        server.increment_round_robin(server.effective_weight)
    
    def update_server_weight(self, server_id: str, new_weight: float):
        """更新服务器权重"""
        server = self._get_server_by_id(server_id)
        if server:
            old_weight = server.base_weight
            server.base_weight = max(self.weight_config.min_weight, 
                                   min(self.weight_config.max_weight, new_weight))
            server.update_effective_weight()
            
            self.logger.info(f"Updated weight for {server_id}: {old_weight:.2f} -> {server.base_weight:.2f}")
    
    def _get_server_by_id(self, server_id: str) -> Optional[WeightedServer]:
        """根据ID获取服务器"""
        for server in self.servers:
            if server.id == server_id:
                return server
        return None
    
    def get_weight_distribution(self) -> Dict[str, Any]:
        """获取权重分布信息"""
        with self.mutex:
            if not self.servers:
                return {}
            
            total_weight = sum(server.effective_weight for server in self.servers)
            
            distribution = {}
            for server in self.servers:
                percentage = (server.effective_weight / total_weight * 100) if total_weight > 0 else 0
                
                distribution[server.id] = {
                    "hostname": server.hostname,
                    "base_weight": server.base_weight,
                    "dynamic_weight": server.dynamic_weight,
                    "health_score": server.health_score,
                    "effective_weight": server.effective_weight,
                    "percentage": percentage,
                    "is_healthy": server.is_healthy,
                    "round_robin_count": server.round_robin_counter,
                    "weight_sum": server.weight_sum
                }
            
            return {
                "total_weight": total_weight,
                "strategy": self.strategy.value,
                "distribution": distribution
            }
    
    def simulate_weighted_traffic(self, num_requests: int = 1000) -> Dict[str, Any]:
        """仿真加权流量分配"""
        print(f"Simulating {num_requests} requests with {self.strategy.value}...")
        
        request_distribution = defaultdict(int)
        response_times = defaultdict(list)
        server_weights_over_time = defaultdict(list)
        
        start_time = time.time()
        
        for i in range(num_requests):
            request_type = random.choices(
                ["normal", "api", "file_upload", "database", "computation"],
                weights=[0.4, 0.3, 0.15, 0.1, 0.05]
            )[0]
            
            result = self.distribute_request(f"client_{i}", request_type)
            
            if result["success"]:
                server_id = result["server"]
                request_distribution[server_id] += 1
                response_times[server_id].append(result["response_time"])
            
            # 定期记录权重状态
            if i % 100 == 0:
                for server in self.servers:
                    server_weights_over_time[server.id].append(server.effective_weight)
        
        end_time = time.time()
        
        # 分析结果
        total_requests = sum(request_distribution.values())
        expected_distribution = self.get_weight_distribution()
        
        # 计算实际分布与期望分布的偏差
        distribution_accuracy = self._calculate_distribution_accuracy(
            request_distribution, expected_distribution
        )
        
        # 计算负载均衡质量
        load_balance_quality = self._calculate_load_balance_quality(request_distribution)
        
        results = {
            "total_requests": total_requests,
            "simulation_duration": end_time - start_time,
            "requests_per_second": total_requests / (end_time - start_time),
            "actual_distribution": dict(request_distribution),
            "expected_distribution": expected_distribution,
            "distribution_accuracy": distribution_accuracy,
            "load_balance_quality": load_balance_quality,
            "response_time_stats": {
                server: {
                    "avg": statistics.mean(times),
                    "min": min(times),
                    "max": max(times),
                    "count": len(times)
                } for server, times in response_times.items() if times
            },
            "server_weights_over_time": dict(server_weights_over_time)
        }
        
        return results
    
    def _calculate_distribution_accuracy(self, actual: Dict[str, int], expected: Dict[str, Any]) -> float:
        """计算分布准确性"""
        if not expected or "distribution" not in expected:
            return 0.0
        
        expected_dist = expected["distribution"]
        total_requests = sum(actual.values())
        
        if total_requests == 0:
            return 0.0
        
        accuracy_scores = []
        
        for server_id, expected_info in expected_dist.items():
            expected_percentage = expected_info["percentage"]
            actual_count = actual.get(server_id, 0)
            actual_percentage = (actual_count / total_requests) * 100
            
            # 计算偏差
            deviation = abs(expected_percentage - actual_percentage)
            accuracy = max(0.0, 1.0 - (deviation / 100.0))
            accuracy_scores.append(accuracy)
        
        return sum(accuracy_scores) / len(accuracy_scores) if accuracy_scores else 0.0
    
    def _calculate_load_balance_quality(self, distribution: Dict[str, int]) -> float:
        """计算负载均衡质量"""
        if not distribution:
            return 0.0
        
        requests = list(distribution.values())
        if len(requests) <= 1:
            return 100.0
        
        # 计算变异系数（标准差/均值）
        mean_requests = statistics.mean(requests)
        std_requests = statistics.stdev(requests)
        
        coefficient_of_variation = std_requests / mean_requests if mean_requests > 0 else 0
        
        # 转换为质量分数（越小越好）
        quality = max(0.0, 100.0 - (coefficient_of_variation * 100))
        
        return quality
    
    def benchmark_strategies(self) -> Dict[str, Any]:
        """基准测试不同策略"""
        strategies = list(WeightedRoundRobinStrategy)
        benchmark_results = {}
        
        for strategy in strategies:
            print(f"Benchmarking {strategy.value}...")
            
            # 临时创建负载均衡器
            temp_lb = WeightedRoundRobinLoadBalancer(strategy=strategy)
            
            # 复制服务器
            for server in self.servers:
                temp_lb.add_server(copy.deepcopy(server))
            
            # 运行仿真
            results = temp_lb.simulate_weighted_traffic(num_requests=1000)
            benchmark_results[strategy.value] = results
        
        return benchmark_results

class GoStyleWeightedRoundRobin:
    """Go风格的加权轮询实现"""
    
    def __init__(self, servers: List[Dict[str, Any]]):
        self.servers = []
        for server_data in servers:
            self.servers.append({
                "id": server_data["id"],
                "host": server_data["host"],
                "port": server_data["port"],
                "weight": server_data.get("weight", 1.0),
                "current_weight": 0.0,
                "effective_weight": server_data.get("weight", 1.0),
                "total_weight": sum(s.get("weight", 1.0) for s in servers)
            })
        
        self.total_weight = sum(server["weight"] for server in servers)
    
    def SelectServer(self) -> Optional[Dict[str, Any]]:
        """选择服务器（Nginx平滑加权轮询算法）"""
        if not self.servers:
            return None
        
        total_current_weight = 0
        selected_server = None
        max_current_weight = 0
        
        # 第一轮：为每个服务器增加当前权重
        for server in self.servers:
            server["current_weight"] += server["effective_weight"]
            total_current_weight += server["current_weight"]
            
            if server["current_weight"] > max_current_weight:
                max_current_weight = server["current_weight"]
                selected_server = server
        
        if not selected_server:
            return None
        
        # 第二轮：选中的服务器权重减少总权重
        selected_server["current_weight"] -= self.total_weight
        
        return selected_server
    
    def SelectWithWeight(self) -> Optional[Dict[str, Any]]:
        """基于权重的选择"""
        if not self.servers:
            return None
        
        # 计算累积权重
        cumulative_weights = []
        current_sum = 0
        
        for server in self.servers:
            current_sum += server["weight"]
            cumulative_weights.append((current_sum, server))
        
        # 随机选择
        random_weight = random.uniform(0, current_sum)
        
        for cumulative_weight, server in cumulative_weights:
            if random_weight <= cumulative_weight:
                return server
        
        return cumulative_weights[-1][1]  # 兜底
    
    def SimulateRequests(self, num_requests: int = 1000) -> Dict[str, Any]:
        """仿真请求"""
        distribution = defaultdict(int)
        response_times = defaultdict(list)
        
        for i in range(num_requests):
            server = self.SelectServer()
            
            if server:
                server_id = server["id"]
                distribution[server_id] += 1
                
                # 模拟响应时间
                response_time = random.uniform(0.1, 2.0) / server["weight"]  # 高权重服务器响应更快
                response_times[server_id].append(response_time)
        
        # 计算统计信息
        total_requests = sum(distribution.values())
        
        distribution_stats = {}
        for server_id, count in distribution.items():
            percentage = (count / total_requests * 100) if total_requests > 0 else 0
            avg_response_time = statistics.mean(response_times[server_id]) if response_times[server_id] else 0
            
            distribution_stats[server_id] = {
                "count": count,
                "percentage": percentage,
                "avg_response_time": avg_response_time
            }
        
        return {
            "total_requests": total_requests,
            "distribution": distribution_stats,
            "algorithm": "smooth_weighted_rr"
        }

class WeightAdjustmentStrategy:
    """权重调整策略"""
    
    def __init__(self, config: WeightAdjustment):
        self.config = config
    
    def adjust_based_on_response_time(self, server: WeightedServer) -> float:
        """基于响应时间调整权重"""
        if server.avg_response_time == 0:
            return server.base_weight
        
        # 响应时间与权重的反比关系
        if server.avg_response_time > self.config.response_time_threshold:
            # 响应时间过长，降低权重
            reduction_factor = min(0.5, (server.avg_response_time - self.config.response_time_threshold) / self.config.response_time_threshold)
            return max(self.config.min_weight, server.base_weight * (1.0 - reduction_factor))
        else:
            # 响应时间良好，可以增加权重
            improvement_factor = min(0.2, (self.config.response_time_threshold - server.avg_response_time) / self.config.response_time_threshold * 0.2)
            return min(self.config.max_weight, server.base_weight * (1.0 + improvement_factor))
    
    def adjust_based_on_success_rate(self, server: WeightedServer) -> float:
        """基于成功率调整权重"""
        total_requests = server.success_requests + server.failure_requests
        if total_requests < 10:  # 样本不足
            return server.base_weight
        
        success_rate = server.success_requests / total_requests
        
        if success_rate < self.config.success_rate_threshold:
            # 成功率过低，降低权重
            penalty_factor = (self.config.success_rate_threshold - success_rate) / self.config.success_rate_threshold
            return max(self.config.min_weight, server.base_weight * (1.0 - penalty_factor))
        else:
            # 成功率良好，保持或微调权重
            return server.base_weight
    
    def adjust_based_on_load(self, server: WeightedServer) -> float:
        """基于系统负载调整权重"""
        # 计算系统负载指标
        cpu_factor = server.cpu_usage / 100.0
        memory_factor = server.memory_usage / 100.0
        overall_load = (cpu_factor + memory_factor) / 2.0
        
        # 负载过高时降低权重
        if overall_load > 0.8:
            penalty = min(0.5, (overall_load - 0.8) / 0.2 * 0.5)
            return max(self.config.min_weight, server.base_weight * (1.0 - penalty))
        else:
            return server.base_weight

# 主演示函数
def demo_weighted_round_robin():
    """主演示函数"""
    
    print("=== Weighted Round Robin Load Balancer Demo ===\n")
    
    # 1. 创建测试服务器
    print("1. Setting up Weighted Servers")
    print("="*50)
    
    servers = [
        WeightedServer("server1", "webserver1.com", 8080, weight=1.0),
        WeightedServer("server2", "webserver2.com", 8080, weight=2.0),
        WeightedServer("server3", "webserver3.com", 8080, weight=3.0),
        WeightedServer("server4", "webserver4.com", 8080, weight=1.5)
    ]
    
    print("Server weights:")
    for server in servers:
        print(f"  {server.hostname}: {server.weight}")
    
    # 2. 测试不同策略
    print("\n2. Testing Different Strategies")
    print("="*50)
    
    strategies = [
        WeightedRoundRobinStrategy.BASIC_WEIGHTED_RR,
        WeightedRoundRobinStrategy.SMOOTH_WEIGHTED_RR,
        WeightedRoundRobinStrategy.ADAPTIVE_WEIGHTED_RR
    ]
    
    strategy_results = {}
    
    for strategy in strategies:
        print(f"\n--- Testing {strategy.value} ---")
        
        lb = WeightedRoundRobinLoadBalancer(strategy=strategy)
        
        for server in servers:
            lb.add_server(copy.deepcopy(server))
        
        results = lb.simulate_weighted_traffic(num_requests=1000)
        strategy_results[strategy.value] = results
        
        print(f"Distribution accuracy: {results['distribution_accuracy']:.2f}%")
        print(f"Load balance quality: {results['load_balance_quality']:.2f}")
        print(f"Actual distribution: {results['actual_distribution']}")
    
    # 3. 权重分布分析
    print("\n3. Weight Distribution Analysis")
    print("="*50)
    
    smooth_lb = WeightedRoundRobinLoadBalancer(WeightedRoundRobinStrategy.SMOOTH_WEIGHTED_RR)
    
    for server in servers:
        smooth_lb.add_server(server)
    
    weight_dist = smooth_lb.get_weight_distribution()
    
    print(f"Total weight: {weight_dist['total_weight']:.2f}")
    print("Weight distribution:")
    for server_id, info in weight_dist["distribution"].items():
        print(f"  {info['hostname']}: {info['effective_weight']:.2f} ({info['percentage']:.1f}%)")
    
    # 4. 动态权重调整演示
    print("\n4. Dynamic Weight Adjustment")
    print("="*50)
    
    # 模拟服务器性能变化
    test_server = servers[0]
    test_server.avg_response_time = 500  # 初始良好
    test_server.success_requests = 100
    test_server.failure_requests = 2
    test_server.cpu_usage = 30
    test_server.memory_usage = 40
    
    print(f"Initial state - Weight: {test_server.base_weight:.2f}, Response time: {test_server.avg_response_time:.1f}ms")
    
    # 模拟性能下降
    test_server.avg_response_time = 2000  # 响应变慢
    test_server.failure_requests = 20
    test_server.cpu_usage = 90
    test_server.memory_usage = 85
    
    test_server.calculate_dynamic_weight()
    print(f"After degradation - Weight: {test_server.base_weight:.2f}, Response time: {test_server.avg_response_time:.1f}ms")
    
    # 模拟性能恢复
    test_server.avg_response_time = 300
    test_server.failure_requests = 3
    test_server.cpu_usage = 25
    test_server.memory_usage = 35
    
    test_server.calculate_dynamic_weight()
    print(f"After recovery - Weight: {test_server.base_weight:.2f}, Response time: {test_server.avg_response_time:.1f}ms")
    
    # 5. Go风格实现演示
    print("\n5. Go-Style Implementation")
    print("="*50)
    
    go_servers = [
        {"id": "go1", "host": "go-server1", "port": 8080, "weight": 1.0},
        {"id": "go2", "host": "go-server2", "port": 8080, "weight": 3.0},
        {"id": "go3", "host": "go-server3", "port": 8080, "weight": 2.0}
    ]
    
    go_lb = GoStyleWeightedRoundRobin(go_servers)
    
    print("Go-style request distribution (first 20 requests):")
    go_distribution = defaultdict(int)
    
    for i in range(20):
        server = go_lb.SelectServer()
        if server:
            go_distribution[server["id"]] += 1
            print(f"  Request {i+1}: {server['host']} (weight: {server['effective_weight']:.1f})")
    
    print(f"\nFinal distribution: {dict(go_distribution)}")
    
    # 6. 性能基准测试
    print("\n6. Performance Benchmark")
    print("="*50)
    
    print(f"{'Strategy':<20} {'Accuracy':<10} {'Quality':<10} {'RPS':<12}")
    print("-" * 55)
    
    for strategy, results in strategy_results.items():
        accuracy = results['distribution_accuracy']
        quality = results['load_balance_quality']
        rps = results['requests_per_second']
        
        print(f"{strategy:<20} {accuracy:<10.2f} {quality:<10.2f} {rps:<12.1f}")
    
    # 7. 权重策略对比
    print("\n7. Weight Strategy Comparison")
    print("="*50)
    
    weight_strategies = []
    
    for server in servers:
        # 基础权重
        weight_strategies.append(("Base Weight", server.base_weight))
        
        # 基于响应时间
        adjustment = WeightAdjustmentStrategy(WeightAdjustment(base_weight=1.0))
        response_weight = adjustment.adjust_based_on_response_time(server)
        weight_strategies.append(("Response Time", response_weight))
        
        # 基于成功率
        success_weight = adjustment.adjust_based_on_success_rate(server)
        weight_strategies.append(("Success Rate", success_weight))
    
    strategy_comparison = defaultdict(list)
    for strategy_name, weight in weight_strategies:
        strategy_comparison[strategy_name].append(weight)
    
    print(f"{'Strategy':<15} {'Average Weight':<15} {'Min Weight':<12} {'Max Weight':<12}")
    print("-" * 60)
    
    for strategy, weights in strategy_comparison.items():
        avg_weight = statistics.mean(weights)
        min_weight = min(weights)
        max_weight = max(weights)
        
        print(f"{strategy:<15} {avg_weight:<15.2f} {min_weight:<12.2f} {max_weight:<12.2f}")
    
    print("\n=== Weighted Round Robin Summary ===")
    print("Weighted Round Robin Algorithm provides:")
    print("• Intelligent distribution based on server capacity")
    print("• Multiple strategy variations for different scenarios")
    print("• Dynamic weight adjustment capabilities")
    print("• Smooth distribution (Nginx-style)")
    print("\nStrategy Types:")
    print("• Basic: Simple weighted selection")
    print("• Smooth: Nginx平滑加权算法")
    print("• Adaptive: 自动调整权重")
    print("\nKey Advantages:")
    print("• Fair distribution based on server weights")
    print("• Handles heterogeneous server environments")
    print("• Supports real-time weight adjustments")
    print("• Predictable traffic distribution")
    print("\nUse Cases:")
    print("• Microservices with varying capacities")
    print("• CDN content distribution")
    print("• Database load balancing")
    print("• API gateway routing")
    print("\nWeight Adjustment Factors:")
    print("• Server performance metrics")
    print("• Response time patterns")
    print("• Success/failure rates")
    print("• System resource utilization")

if __name__ == "__main__":
    demo_weighted_round_robin()