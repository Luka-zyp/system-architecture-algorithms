# 数据一致性概述

## 目录
1. [一致性概述](#一致性概述)
2. [CAP定理](#cap定理)
3. [一致性模型](#一致性模型)
4. [分布式事务](#分布式事务)
5. [Saga模式](#saga模式)
6. [最终一致性](#最终一致性)
7. [数据同步策略](#数据同步策略)
8. [冲突解决机制](#冲突解决机制)
9. [幂等性设计](#幂等性设计)
10. [缓存一致性](#缓存一致性)
11. [消息队列一致性](#消息队列一致性)
12. [实际应用案例](#实际应用案例)
13. [最佳实践](#最佳实践)

## 一致性概述

数据一致性是分布式系统中的核心挑战之一。在分布式系统中，数据分布在多个节点上，如何保证这些数据在不同节点间保持一致是系统设计的关键问题。

### 分布式一致性的挑战
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Client A   │────▶│ Service A   │────▶│  Database A │
└─────────────┘     └─────────────┘     └─────────────┘
       │                   │                   │
       ▼                   ▼                   ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Client B   │────▶│ Service B   │────▶│  Database B │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 一致性问题的类型
- **同步写入**：如何确保多个副本的数据同步
- **并发控制**：如何处理并发访问和数据冲突
- **网络分区**：如何在网络分区时保持一致性
- **故障恢复**：如何在节点故障时恢复一致性

## CAP定理

### CAP理论详解
CAP定理指出，一个分布式系统不可能同时满足以下三个特性：

- **Consistency（一致性）**：所有节点在同一时间看到相同的数据
- **Availability（可用性）**：每个请求都能在合理时间内得到响应
- **Partition tolerance（分区容错性）**：系统能够继续运行，即使网络分区发生

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, List, Any, Optional
from enum import Enum
import asyncio
import time

class ConsistencyLevel(Enum):
    """一致性级别"""
    STRONG = "strong"        # 强一致性
    EVENTUAL = "eventual"    # 最终一致性
    WEAK = "weak"           # 弱一致性
    QUORUM = "quorum"       # 仲裁一致性

@dataclass
class DataNode:
    """数据节点"""
    node_id: str
    data: Dict[str, Any]
    last_updated: float
    version: int

class ConsistencyModel(ABC):
    """一致性模型抽象"""
    
    def __init__(self, nodes: List[DataNode]):
        self.nodes = nodes
        self.leader_node = None  # 主节点
    
    @abstractmethod
    async def read(self, key: str) -> Any:
        """读取数据"""
        pass
    
    @abstractmethod
    async def write(self, key: str, value: Any) -> bool:
        """写入数据"""
        pass
    
    def set_leader(self, node_id: str):
        """设置主节点"""
        self.leader_node = node_id
    
    def get_node(self, node_id: str) -> Optional[DataNode]:
        """获取节点"""
        for node in self.nodes:
            if node.node_id == node_id:
                return node
        return None

class StrongConsistencyModel(ConsistencyModel):
    """强一致性模型"""
    
    async def read(self, key: str) -> Any:
        """强一致性读取 - 读取主节点数据"""
        if not self.leader_node:
            # 如果没有主节点，选择第一个节点
            if not self.nodes:
                raise Exception("No nodes available")
            leader_node = self.nodes[0]
        else:
            leader_node = self.get_node(self.leader_node)
            if not leader_node:
                raise Exception(f"Leader node {self.leader_node} not found")
        
        # 读取主节点数据
        return leader_node.data.get(key)
    
    async def write(self, key: str, value: Any) -> bool:
        """强一致性写入 - 写入主节点，然后同步到所有从节点"""
        if not self.leader_node:
            if not self.nodes:
                return False
            self.leader_node = self.nodes[0].node_id
        
        leader_node = self.get_node(self.leader_node)
        if not leader_node:
            return False
        
        # 更新主节点
        leader_node.data[key] = value
        leader_node.version += 1
        leader_node.last_updated = time.time()
        
        # 同步到所有从节点
        await self._sync_to_followers(key, value, leader_node.version)
        
        return True
    
    async def _sync_to_followers(self, key: str, value: Any, version: int):
        """同步数据到从节点"""
        sync_tasks = []
        
        for node in self.nodes:
            if node.node_id != self.leader_node:
                # 异步同步到每个从节点
                sync_tasks.append(self._sync_to_node(node, key, value, version))
        
        # 等待所有同步完成
        await asyncio.gather(*sync_tasks, return_exceptions=True)
    
    async def _sync_to_node(self, node: DataNode, key: str, value: Any, version: int):
        """同步数据到单个节点"""
        try:
            # 模拟网络延迟和同步过程
            await asyncio.sleep(0.1)
            
            node.data[key] = value
            node.version = version
            node.last_updated = time.time()
            
            print(f"Synced {key} to node {node.node_id}")
        except Exception as e:
            print(f"Failed to sync to node {node.node_id}: {e}")

class EventualConsistencyModel(ConsistencyModel):
    """最终一致性模型"""
    
    def __init__(self, nodes: List[DataNode]):
        super().__init__(nodes)
        self.sync_tasks: Dict[str, asyncio.Task] = {}
    
    async def read(self, key: str) -> Any:
        """最终一致性读取 - 读取任意节点数据"""
        if not self.nodes:
            raise Exception("No nodes available")
        
        # 随机选择一个节点读取（提高可用性）
        import random
        node = random.choice(self.nodes)
        
        return node.data.get(key)
    
    async def write(self, key: str, value: Any) -> bool:
        """最终一致性写入 - 写入任意节点，然后异步同步"""
        if not self.nodes:
            return False
        
        # 选择一个节点进行写入
        import random
        write_node = random.choice(self.nodes)
        
        # 异步更新本地数据
        write_node.data[key] = value
        write_node.version += 1
        write_node.last_updated = time.time()
        
        # 异步同步到其他节点
        if key not in self.sync_tasks or self.sync_tasks[key].done():
            self.sync_tasks[key] = asyncio.create_task(
                self._async_sync(key, value, write_node.version)
            )
        
        return True
    
    async def _async_sync(self, key: str, value: Any, version: int):
        """异步同步数据到其他节点"""
        await asyncio.sleep(1)  # 模拟网络延迟
        
        sync_count = 0
        for node in self.nodes:
            if node.data.get(key) != value:  # 只同步需要更新的节点
                node.data[key] = value
                node.version = version
                node.last_updated = time.time()
                sync_count += 1
        
        print(f"Async synced {key} to {sync_count} nodes")

class QuorumConsistencyModel(ConsistencyModel):
    """仲裁一致性模型"""
    
    def __init__(self, nodes: List[DataNode], read_quorum: int = None, write_quorum: int = None):
        super().__init__(nodes)
        self.total_nodes = len(nodes)
        self.read_quorum = read_quorum or (self.total_nodes // 2 + 1)
        self.write_quorum = write_quorum or (self.total_nodes // 2 + 1)
    
    async def read(self, key: str) -> Any:
        """仲裁读取 - 读取多个节点，返回最新版本"""
        if not self.nodes:
            raise Exception("No nodes available")
        
        # 随机选择足够的节点进行读取
        import random
        read_nodes = random.sample(self.nodes, min(self.read_quorum, len(self.nodes)))
        
        # 读取数据
        read_results = []
        for node in read_nodes:
            data = node.data.get(key)
            read_results.append({
                'value': data,
                'version': node.version,
                'node_id': node.node_id
            })
        
        # 选择版本最高的数据
        if read_results:
            latest = max(read_results, key=lambda x: x['version'])
            return latest['value']
        
        return None
    
    async def write(self, key: str, value: Any) -> bool:
        """仲裁写入 - 写入到足够的节点"""
        if not self.nodes:
            return False
        
        # 选择足够的节点进行写入
        import random
        write_nodes = random.sample(self.nodes, min(self.write_quorum, len(self.nodes)))
        
        success_count = 0
        new_version = int(time.time())  # 使用时间戳作为版本号
        
        for node in write_nodes:
            try:
                node.data[key] = value
                node.version = new_version
                node.last_updated = time.time()
                success_count += 1
            except Exception as e:
                print(f"Write failed to node {node.node_id}: {e}")
        
        # 检查是否达到写入仲裁
        return success_count >= self.write_quorum

# CAP定理演示
class CAPDemo:
    """CAP定理演示"""
    
    def __init__(self):
        # 创建示例节点
        self.nodes = [
            DataNode("node1", {}, time.time(), 1),
            DataNode("node2", {}, time.time(), 1),
            DataNode("node3", {}, time.time(), 1)
        ]
        
        # 创建不同的一致性模型
        self.strong_consistency = StrongConsistencyModel(self.nodes)
        self.eventual_consistency = EventualConsistencyModel(self.nodes)
        self.quorum_consistency = QuorumConsistencyModel(self.nodes)
        
        self.strong_consistency.set_leader("node1")
    
    async def demo_strong_consistency(self):
        """演示强一致性"""
        print("\n=== 强一致性演示 ===")
        
        # 写入数据
        await self.strong_consistency.write("balance", 1000)
        
        # 读取数据（总是返回最新值）
        value = await self.strong_consistency.read("balance")
        print(f"读取余额: {value}")
        
        # 模拟网络分区 - 禁用同步
        print("模拟网络分区...")
        
        # 再次写入
        await self.strong_consistency.write("balance", 500)
        
        # 读取数据（可能会失败）
        try:
            value = await self.strong_consistency.read("balance")
            print(f"分区后读取余额: {value}")
        except Exception as e:
            print(f"读取失败: {e}")
    
    async def demo_eventual_consistency(self):
        """演示最终一致性"""
        print("\n=== 最终一致性演示 ===")
        
        # 写入数据
        await self.eventual_consistency.write("balance", 1000)
        
        # 立即读取（可能不是最新值）
        value = await self.eventual_consistency.read("balance")
        print(f"立即读取余额: {value}")
        
        # 等待同步完成
        await asyncio.sleep(2)
        
        # 再次读取（应该是最新值）
        value = await self.eventual_consistency.read("balance")
        print(f"同步后读取余额: {value}")
    
    async def demo_quorum_consistency(self):
        """演示仲裁一致性"""
        print("\n=== 仲裁一致性演示 ===")
        
        # 写入数据
        await self.quorum_consistency.write("balance", 1000)
        
        # 读取数据
        value = await self.quorum_consistency.read("balance")
        print(f"仲裁读取余额: {value}")
        
        # 模拟节点故障
        print("模拟节点故障...")
        
        # 只在一个节点上写入
        self.nodes[0].data["balance"] = 500
        self.nodes[0].version += 1
        
        # 仲裁读取（可能读取到旧值）
        value = await self.quorum_consistency.read("balance")
        print(f"故障后仲裁读取余额: {value}")
```

## 一致性模型

### 1. 线性一致性（Linearizability）
```python
class LinearizableKVStore:
    """线性化键值存储"""
    
    def __init__(self):
        self.data = {}
        self.timestamps = {}  # 操作时间戳
        self.global_clock = 0
    
    def get_timestamp(self) -> float:
        """获取全局时间戳"""
        self.global_clock = max(self.global_clock + 1, time.time())
        return self.global_clock
    
    async def set(self, key: str, value: Any) -> bool:
        """原子性设置"""
        timestamp = self.get_timestamp()
        
        # 获取锁保证原子性
        async with self._get_lock(key):
            self.data[key] = value
            self.timestamps[key] = timestamp
        
        return True
    
    async def get(self, key: str) -> Any:
        """线性化读取"""
        async with self._get_lock(key):
            # 返回当前值和操作时间
            return {
                'value': self.data.get(key),
                'timestamp': self.timestamps.get(key, 0)
            }
    
    async def _get_lock(self, key: str):
        """获取锁（简化实现）"""
        return LinearizableLock()
    
    def verify_linearizability(self, operations: List[Dict]) -> bool:
        """验证线性一致性"""
        # 检查操作序列是否满足线性一致性
        sorted_ops = sorted(operations, key=lambda x: x['timestamp'])
        
        for i, op in enumerate(sorted_ops):
            if op['type'] == 'set' and i > 0:
                # 检查后续的get操作是否能看到这个set的值
                for j in range(i + 1, len(sorted_ops)):
                    later_op = sorted_ops[j]
                    if later_op['type'] == 'get' and later_op['key'] == op['key']:
                        # 如果get操作的时间戳在set之后，但值不匹配
                        if (later_op['timestamp'] > op['timestamp'] and 
                            later_op['value'] != op['value']):
                            return False
        
        return True

class LinearizableLock:
    """线性化锁（简化实现）"""
    
    def __init__(self):
        self._acquired = False
    
    async def __aenter__(self):
        while self._acquired:
            await asyncio.sleep(0.001)  # 等待
        self._acquired = True
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self._acquired = False
```

### 2. 顺序一致性（Sequential Consistency）
```python
class SequentialConsistentKVStore:
    """顺序一致性键值存储"""
    
    def __init__(self, client_id: str):
        self.client_id = client_id
        self.data = {}
        self.client_operations = []  # 客户端操作序列
        self.server_operation_log = []  # 服务器操作日志
    
    async def set(self, key: str, value: Any) -> bool:
        """设置值"""
        operation = {
            'type': 'set',
            'key': key,
            'value': value,
            'client_id': self.client_id,
            'timestamp': time.time()
        }
        
        # 记录客户端操作
        self.client_operations.append(operation)
        
        # 应用到服务器状态
        self.data[key] = value
        
        # 记录服务器操作日志
        self.server_operation_log.append(operation)
        
        return True
    
    async def get(self, key: str) -> Any:
        """获取值"""
        operation = {
            'type': 'get',
            'key': key,
            'value': self.data.get(key),
            'client_id': self.client_id,
            'timestamp': time.time()
        }
        
        # 记录操作
        self.client_operations.append(operation)
        
        return self.data.get(key)
    
    def get_consistent_view(self) -> Dict[str, Any]:
        """获取一致视图"""
        # 按照客户端操作序列顺序执行，返回最终状态
        view = self.data.copy()
        
        for op in self.client_operations:
            if op['type'] == 'set':
                view[op['key']] = op['value']
        
        return view
    
    def verify_sequential_consistency(self) -> bool:
        """验证顺序一致性"""
        # 检查每个客户端的操作顺序是否被保持
        for client_id in set(op['client_id'] for op in self.client_operations):
            client_ops = [op for op in self.client_operations 
                         if op['client_id'] == client_id]
            
            # 检查每个客户端的操作在服务器日志中是否按顺序出现
            client_op_indices = []
            for client_op in client_ops:
                # 在服务器日志中找到对应操作的位置
                for i, server_op in enumerate(self.server_operation_log):
                    if (server_op['client_id'] == client_op['client_id'] and
                        server_op['type'] == client_op['type'] and
                        server_op['key'] == client_op['key']):
                        client_op_indices.append(i)
                        break
            
            # 检查索引是否递增（保持顺序）
            for i in range(1, len(client_op_indices)):
                if client_op_indices[i] < client_op_indices[i-1]:
                    return False
        
        return True
```

### 3. 因果一致性（Causal Consistency）
```python
class CausalConsistentKVStore:
    """因果一致性键值存储"""
    
    def __init__(self, node_id: str):
        self.node_id = node_id
        self.data = {}
        self.vector_clock = {node_id: 0}  # 向量时钟
        self.causal_history = {}  # 因果历史记录
        self.pending_operations = []  # 待处理操作
    
    def update_vector_clock(self, received_clock: Dict[str, int] = None):
        """更新向量时钟"""
        # 增加当前节点的计数器
        self.vector_clock[self.node_id] = self.vector_clock.get(self.node_id, 0) + 1
        
        # 合并接收到的向量时钟
        if received_clock:
            for node, counter in received_clock.items():
                self.vector_clock[node] = max(
                    self.vector_clock.get(node, 0),
                    counter
                )
    
    def happens_before(self, op1: Dict, op2: Dict) -> bool:
        """判断操作op1是否在操作op2之前发生（因果关系）"""
        # 如果两个操作来自同一节点，按时间戳判断
        if op1['node_id'] == op2['node_id']:
            return op1['timestamp'] < op2['timestamp']
        
        # 检查向量时钟
        op1_clock = op1.get('vector_clock', {})
        op2_clock = op2.get('vector_clock', {})
        
        # op1在op2之前发生当且仅当：
        # 1. op1的向量时钟中对应op2节点的计数器 < op2的向量时钟
        # 2. op1的向量时钟中其他节点的计数器 ≤ op2的向量时钟
        for node in op2_clock:
            if op1_clock.get(node, 0) > op2_clock[node]:
                return False
        
        return True
    
    async def set(self, key: str, value: Any) -> Dict[str, Any]:
        """设置值并返回操作信息"""
        operation = {
            'type': 'set',
            'key': key,
            'value': value,
            'node_id': self.node_id,
            'timestamp': time.time(),
            'vector_clock': self.vector_clock.copy()
        }
        
        # 更新向量时钟
        self.update_vector_clock()
        
        # 更新本地数据
        self.data[key] = {
            'value': value,
            'operation': operation
        }
        
        # 记录因果历史
        if key not in self.causal_history:
            self.causal_history[key] = []
        self.causal_history[key].append(operation)
        
        return operation
    
    async def get(self, key: str) -> Any:
        """获取值（考虑因果关系）"""
        if key in self.data:
            return self.data[key]['value']
        
        return None
    
    def can_read_causally(self, operation: Dict) -> bool:
        """判断是否可以因果一致地读取这个操作"""
        if key not in self.causal_history:
            return True
        
        # 检查是否有因果关系的操作
        for existing_op in self.causal_history[key]:
            # 如果现有操作在这个操作之后发生，则不能读取
            if self.happens_before(operation, existing_op):
                return False
        
        return True
    
    async def receive_operation(self, operation: Dict) -> bool:
        """接收来自其他节点的操作"""
        # 检查因果关系
        if operation['type'] == 'set':
            if not self.can_read_causally(operation):
                self.pending_operations.append(operation)
                return False
            
            # 更新向量时钟
            self.update_vector_clock(operation['vector_clock'])
            
            # 应用操作
            self.data[operation['key']] = {
                'value': operation['value'],
                'operation': operation
            }
            
            # 记录因果历史
            if operation['key'] not in self.causal_history:
                self.causal_history[operation['key']] = []
            self.causal_history[operation['key']].append(operation)
            
            # 处理等待队列中的操作
            await self._process_pending_operations()
            
            return True
        
        return False
    
    async def _process_pending_operations(self):
        """处理等待队列中的操作"""
        processed = []
        
        for pending_op in self.pending_operations:
            if self.can_read_causally(pending_op):
                await self.receive_operation(pending_op)
                processed.append(pending_op)
        
        # 移除已处理的操作
        for op in processed:
            self.pending_operations.remove(op)
```

## 分布式事务

### 4. 两阶段提交（2PC）实现
```python
class TwoPhaseCommit:
    """两阶段提交协议实现"""
    
    def __init__(self, coordinator_id: str):
        self.coordinator_id = coordinator_id
        self.participants = {}
        self.transaction_id = None
        self.state = "INIT"  # INIT, PREPARING, COMMITTED, ABORTED
        self.votes = {}  # participant_id -> vote
    
    def add_participant(self, participant_id: str, endpoint: str):
        """添加参与者"""
        self.participants[participant_id] = {
            'id': participant_id,
            'endpoint': endpoint,
            'state': 'INIT'
        }
    
    async def begin_transaction(self) -> str:
        """开始事务"""
        self.transaction_id = f"tx_{time.time()}_{self.coordinator_id}"
        self.state = "INIT"
        self.votes.clear()
        
        print(f"开始事务: {self.transaction_id}")
        return self.transaction_id
    
    async def phase1_prepare(self) -> bool:
        """阶段1：准备阶段"""
        if not self.participants:
            return False
        
        self.state = "PREPARING"
        
        # 发送准备请求到所有参与者
        prepare_tasks = []
        for participant_id, participant_info in self.participants.items():
            task = self._send_prepare_request(participant_id, participant_info)
            prepare_tasks.append(task)
        
        # 等待所有参与者的响应
        results = await asyncio.gather(*prepare_tasks, return_exceptions=True)
        
        # 统计投票结果
        yes_votes = 0
        for i, (participant_id, _) in enumerate(self.participants.items()):
            if isinstance(results[i], Exception):
                print(f"参与者 {participant_id} 准备失败: {results[i]}")
                self.votes[participant_id] = "NO"
            else:
                self.votes[participant_id] = results[i]
                if results[i] == "YES":
                    yes_votes += 1
        
        # 判断是否所有参与者都同意
        return yes_votes == len(self.participants)
    
    async def phase2_commit(self) -> bool:
        """阶段2：提交阶段"""
        if self.state != "PREPARING":
            return False
        
        # 决定提交或中止
        all_yes = all(vote == "YES" for vote in self.votes.values())
        
        if all_yes:
            self.state = "COMMITTED"
            decision = "COMMIT"
        else:
            self.state = "ABORTED"
            decision = "ABORT"
        
        # 发送决策到所有参与者
        commit_tasks = []
        for participant_id, participant_info in self.participants.items():
            task = self._send_commit_request(participant_id, participant_info, decision)
            commit_tasks.append(task)
        
        await asyncio.gather(*commit_tasks, return_exceptions=True)
        
        print(f"事务决策: {decision}")
        return all_yes
    
    async def _send_prepare_request(self, participant_id: str, participant_info: Dict) -> str:
        """发送准备请求到参与者"""
        try:
            # 模拟网络调用
            await asyncio.sleep(0.1)
            
            # 在实际实现中，这里会发送HTTP/gRPC请求
            print(f"发送准备请求到 {participant_id}")
            
            # 模拟参与者的决策（随机决定）
            import random
            if random.random() > 0.1:  # 90%的概率同意
                return "YES"
            else:
                return "NO"
        except Exception as e:
            return "NO"
    
    async def _send_commit_request(self, participant_id: str, 
                                 participant_info: Dict, decision: str):
        """发送提交请求到参与者"""
        try:
            # 模拟网络调用
            await asyncio.sleep(0.1)
            
            print(f"发送{decision}请求到 {participant_id}")
            
            # 实际实现中会更新参与者状态
            self.participants[participant_id]['state'] = decision
            
        except Exception as e:
            print(f"发送{decision}请求失败: {e}")

class TransactionParticipant:
    """事务参与者"""
    
    def __init__(self, participant_id: str):
        self.participant_id = participant_id
        self.transaction_states = {}  # transaction_id -> state
        self.data = {}
    
    async def prepare(self, transaction_id: str, operations: List[Dict]) -> str:
        """准备阶段"""
        try:
            # 检查是否可以执行所有操作
            for operation in operations:
                if operation['type'] == 'set':
                    # 检查数据是否存在冲突
                    key = operation['key']
                    if key in self.data:
                        # 简化：假设如果数据已存在则拒绝
                        return "NO"
            
            # 记录事务状态
            self.transaction_states[transaction_id] = {
                'state': 'PREPARED',
                'operations': operations,
                'timestamp': time.time()
            }
            
            print(f"参与者 {self.participant_id} 准备成功")
            return "YES"
            
        except Exception as e:
            print(f"参与者 {self.participant_id} 准备失败: {e}")
            return "NO"
    
    async def commit(self, transaction_id: str, decision: str):
        """提交阶段"""
        if transaction_id not in self.transaction_states:
            print(f"参与者 {self.participant_id} 找不到事务 {transaction_id}")
            return
        
        tx_state = self.transaction_states[transaction_id]
        
        if decision == "COMMIT":
            # 执行所有操作
            for operation in tx_state['operations']:
                if operation['type'] == 'set':
                    self.data[operation['key']] = operation['value']
            
            tx_state['state'] = 'COMMITTED'
            print(f"参与者 {self.participant_id} 提交成功")
            
        else:  # ABORT
            tx_state['state'] = 'ABORTED'
            print(f"参与者 {self.participant_id} 中止事务")
        
        # 清理事务状态（可选）
        # del self.transaction_states[transaction_id]
    
    def get_data(self) -> Dict[str, Any]:
        """获取当前数据"""
        return self.data.copy()
```

### 5. 三阶段提交（3PC）实现
```python
class ThreePhaseCommit:
    """三阶段提交协议实现"""
    
    def __init__(self, coordinator_id: str):
        self.coordinator_id = coordinator_id
        self.participants = {}
        self.transaction_id = None
        self.state = "INIT"
        self.precommit_votes = {}  # 预提交投票
    
    async def begin_transaction(self) -> str:
        """开始事务"""
        self.transaction_id = f"3pc_tx_{time.time()}"
        self.state = "INIT"
        self.precommit_votes.clear()
        
        print(f"开始三阶段提交事务: {self.transaction_id}")
        return self.transaction_id
    
    async def phase1_vote(self) -> bool:
        """阶段1：投票阶段"""
        self.state = "VOTING"
        
        # 发送投票请求到所有参与者
        vote_tasks = []
        for participant_id, participant_info in self.participants.items():
            task = self._send_vote_request(participant_id, participant_info)
            vote_tasks.append(task)
        
        results = await asyncio.gather(*vote_tasks, return_exceptions=True)
        
        # 统计投票结果
        yes_votes = 0
        for i, (participant_id, _) in enumerate(self.participants.items()):
            if isinstance(results[i], Exception):
                print(f"参与者 {participant_id} 投票失败")
                self.precommit_votes[participant_id] = "NO"
            else:
                self.precommit_votes[participant_id] = results[i]
                if results[i] == "YES":
                    yes_votes += 1
        
        return yes_votes == len(self.participants)
    
    async def phase2_precommit(self) -> bool:
        """阶段2：预提交阶段"""
        if self.state != "VOTING":
            return False
        
        all_yes = all(vote == "YES" for vote in self.precommit_votes.values())
        
        if all_yes:
            self.state = "PRECOMMITTED"
            decision = "PRECOMMIT"
        else:
            self.state = "ABORTED"
            decision = "ABORT"
        
        # 发送预提交决策
        precommit_tasks = []
        for participant_id, participant_info in self.participants.items():
            task = self._send_precommit_request(participant_id, participant_info, decision)
            precommit_tasks.append(task)
        
        await asyncio.gather(*precommit_tasks, return_exceptions=True)
        
        return all_yes
    
    async def phase3_commit(self) -> bool:
        """阶段3：提交阶段"""
        if self.state != "PRECOMMITTED":
            return False
        
        self.state = "COMMITTED"
        
        # 发送最终提交决策
        commit_tasks = []
        for participant_id, participant_info in self.participants.items():
            task = self._send_commit_request(participant_id, participant_info, "COMMIT")
            commit_tasks.append(task)
        
        await asyncio.gather(*commit_tasks, return_exceptions=True)
        
        return True
    
    async def _send_vote_request(self, participant_id: str, participant_info: Dict) -> str:
        """发送投票请求"""
        await asyncio.sleep(0.1)
        print(f"发送投票请求到 {participant_id}")
        
        import random
        if random.random() > 0.05:  # 95%概率同意
            return "YES"
        return "NO"
    
    async def _send_precommit_request(self, participant_id: str, 
                                    participant_info: Dict, decision: str):
        """发送预提交请求"""
        await asyncio.sleep(0.1)
        print(f"发送预提交请求到 {participant_id}: {decision}")
    
    async def _send_commit_request(self, participant_id: str, 
                                 participant_info: Dict, decision: str):
        """发送提交请求"""
        await asyncio.sleep(0.1)
        print(f"发送提交请求到 {participant_id}: {decision}")

class ThreePhaseCommitParticipant:
    """三阶段提交参与者"""
    
    def __init__(self, participant_id: str):
        self.participant_id = participant_id
        self.transaction_states = {}
        self.data = {}
    
    async def vote(self, transaction_id: str, operations: List[Dict]) -> str:
        """投票阶段"""
        try:
            # 检查操作可行性
            for operation in operations:
                if operation['type'] == 'set':
                    if operation['key'] in self.data:
                        # 简化：检查是否有可能死锁
                        if await self._check_potential_deadlock(operation):
                            return "NO"
            
            # 记录事务状态
            self.transaction_states[transaction_id] = {
                'state': 'VOTED',
                'operations': operations,
                'voted_yes': True,
                'timestamp': time.time()
            }
            
            print(f"参与者 {self.participant_id} 投票 YES")
            return "YES"
            
        except Exception as e:
            print(f"参与者 {self.participant_id} 投票失败: {e}")
            return "NO"
    
    async def precommit(self, transaction_id: str, decision: str) -> bool:
        """预提交阶段"""
        if transaction_id not in self.transaction_states:
            return False
        
        tx_state = self.transaction_states[transaction_id]
        
        if decision == "PRECOMMIT" and tx_state['voted_yes']:
            tx_state['state'] = 'PRECOMMITTED'
            print(f"参与者 {self.participant_id} 预提交成功")
            return True
        elif decision == "ABORT":
            tx_state['state'] = 'ABORTED'
            print(f"参与者 {self.participant_id} 中止事务")
            return True
        
        return False
    
    async def commit(self, transaction_id: str, decision: str):
        """提交阶段"""
        if transaction_id not in self.transaction_states:
            return
        
        tx_state = self.transaction_states[transaction_id]
        
        if decision == "COMMIT" and tx_state['state'] == 'PRECOMMITTED':
            # 执行所有操作
            for operation in tx_state['operations']:
                if operation['type'] == 'set':
                    self.data[operation['key']] = operation['value']
            
            tx_state['state'] = 'COMMITTED'
            print(f"参与者 {self.participant_id} 提交成功")
    
    async def _check_potential_deadlock(self, operation: Dict) -> bool:
        """检查潜在死锁（简化实现）"""
        # 简化的死锁检查：检查是否与现有事务冲突
        key = operation['key']
        
        # 检查是否有其他事务也在操作这个键
        for tx_id, tx_state in self.transaction_states.items():
            if tx_state['state'] in ['VOTED', 'PRECOMMITTED']:
                for existing_op in tx_state['operations']:
                    if (existing_op['type'] == 'set' and 
                        existing_op['key'] == key):
                        return True  # 潜在冲突
        
        return False
```

## Saga模式

### 6. Saga事务管理器
```python
from enum import Enum
import uuid

class SagaState(Enum):
    """Saga状态"""
    NOT_STARTED = "not_started"
    RUNNING = "running"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    COMPENSATING = "compensating"
    COMPENSATED = "compensated"

class SagaStep:
    """Saga步骤"""
    
    def __init__(self, step_id: str, forward_action: callable, 
                 compensate_action: callable, step_data: Dict = None):
        self.step_id = step_id
        self.forward_action = forward_action
        self.compensate_action = compensate_action
        self.step_data = step_data or {}
        self.status = "pending"  # pending, completed, failed, compensated
        self.result = None
        self.error = None
    
    async def execute_forward(self) -> bool:
        """执行正向操作"""
        try:
            self.result = await self.forward_action(self.step_data)
            self.status = "completed"
            return True
        except Exception as e:
            self.status = "failed"
            self.error = str(e)
            return False
    
    async def execute_compensate(self) -> bool:
        """执行补偿操作"""
        try:
            if self.compensate_action:
                await self.compensate_action(self.step_data, self.result)
            self.status = "compensated"
            return True
        except Exception as e:
            self.status = "compensation_failed"
            self.error = str(e)
            return False

class SagaOrchestrator:
    """Saga编排器"""
    
    def __init__(self, saga_id: str):
        self.saga_id = saga_id
        self.steps = []
        self.current_step = 0
        self.state = SagaState.NOT_STARTED
        self.completed_steps = []
        self.failed_steps = []
    
    def add_step(self, step: SagaStep):
        """添加步骤"""
        self.steps.append(step)
    
    async def execute(self) -> bool:
        """执行Saga事务"""
        if self.state != SagaState.NOT_STARTED:
            raise Exception("Saga already started")
        
        self.state = SagaState.RUNNING
        
        try:
            # 按顺序执行所有步骤
            for i, step in enumerate(self.steps):
                self.current_step = i
                
                success = await step.execute_forward()
                
                if success:
                    self.completed_steps.append(step)
                else:
                    self.failed_steps.append(step)
                    
                    # 开始补偿流程
                    await self._compensate()
                    return False
            
            self.state = SagaState.SUCCEEDED
            return True
            
        except Exception as e:
            self.state = SagaState.FAILED
            raise e
    
    async def _compensate(self):
        """补偿流程"""
        self.state = SagaState.COMPENSATING
        
        try:
            # 从最后一个成功的步骤开始补偿
            for step in reversed(self.completed_steps):
                if step.status == "completed":
                    success = await step.execute_compensate()
                    if not success:
                        print(f"补偿步骤 {step.step_id} 失败")
            
            self.state = SagaState.COMPENSATED
            
        except Exception as e:
            self.state = SagaState.FAILED
            print(f"补偿过程失败: {e}")

class SagaChoreography:
    """Saga编舞（事件驱动）"""
    
    def __init__(self):
        self.event_handlers = {}
        self.pending_events = []
        self.saga_instances = {}  # saga_id -> saga_state
        self.compensation_handlers = {}
    
    def register_event_handler(self, event_type: str, handler: callable):
        """注册事件处理器"""
        self.event_handlers[event_type] = handler
    
    def register_compensation_handler(self, event_type: str, handler: callable):
        """注册补偿处理器"""
        self.compensation_handlers[event_type] = handler
    
    async def publish_event(self, event_type: str, event_data: Dict, 
                          saga_id: str = None):
        """发布事件"""
        event = {
            'type': event_type,
            'data': event_data,
            'saga_id': saga_id,
            'timestamp': time.time(),
            'id': str(uuid.uuid4())
        }
        
        self.pending_events.append(event)
        await self._process_events()
    
    async def _process_events(self):
        """处理待处理事件"""
        while self.pending_events:
            event = self.pending_events.pop(0)
            
            try:
                await self._handle_event(event)
            except Exception as e:
                print(f"处理事件失败: {e}")
                # 可以将事件重新加入队列或记录失败
    
    async def _handle_event(self, event: Dict):
        """处理单个事件"""
        event_type = event['type']
        event_data = event['data']
        saga_id = event.get('saga_id')
        
        if event_type in self.event_handlers:
            handler = self.event_handlers[event_type]
            
            # 处理正向事件
            if event_type.startswith('order_'):
                await handler(event_data)
            elif event_type.startswith('payment_'):
                if event_type == 'payment_failed':
                    # 处理支付失败，启动补偿
                    await self._trigger_compensation(saga_id, event_data)
                else:
                    await handler(event_data)
            elif event_type.startswith('inventory_'):
                if event_type == 'inventory_failed':
                    # 处理库存不足，启动补偿
                    await self._trigger_compensation(saga_id, event_data)
                else:
                    await handler(event_data)
    
    async def _trigger_compensation(self, saga_id: str, failed_event_data: Dict):
        """触发补偿流程"""
        print(f"触发Saga {saga_id} 的补偿流程")
        
        # 模拟补偿流程
        compensation_event = {
            'type': 'compensation_start',
            'data': failed_event_data,
            'saga_id': saga_id,
            'timestamp': time.time(),
            'id': str(uuid.uuid4())
        }
        
        self.pending_events.append(compensation_event)

# Saga示例：电商订单处理
class ECommerceSaga:
    """电商订单Saga示例"""
    
    def __init__(self):
        self.orchestrator = SagaOrchestrator(str(uuid.uuid4()))
        self.setup_saga_steps()
    
    def setup_saga_steps(self):
        """设置Saga步骤"""
        # 步骤1：创建订单
        create_order_step = SagaStep(
            "create_order",
            self.create_order,
            self.cancel_order,
            {'service': 'order-service'}
        )
        
        # 步骤2：支付处理
        payment_step = SagaStep(
            "process_payment",
            self.process_payment,
            self.refund_payment,
            {'service': 'payment-service', 'amount': 100}
        )
        
        # 步骤3：库存扣减
        inventory_step = SagaStep(
            "reserve_inventory",
            self.reserve_inventory,
            self.release_inventory,
            {'service': 'inventory-service', 'product_id': 'product-123', 'quantity': 1}
        )
        
        # 步骤4：发货
        shipping_step = SagaStep(
            "ship_order",
            self.ship_order,
            self.cancel_shipment,
            {'service': 'shipping-service'}
        )
        
        self.orchestrator.add_step(create_order_step)
        self.orchestrator.add_step(payment_step)
        self.orchestrator.add_step(inventory_step)
        self.orchestrator.add_step(shipping_step)
    
    async def create_order(self, step_data: Dict) -> Dict[str, Any]:
        """创建订单"""
        print(f"正在创建订单...")
        await asyncio.sleep(0.5)
        
        order_id = f"order-{uuid.uuid4()}"
        return {
            'order_id': order_id,
            'status': 'created',
            'timestamp': time.time()
        }
    
    async def cancel_order(self, step_data: Dict, result: Dict):
        """取消订单"""
        print(f"正在取消订单 {result['order_id']}...")
        await asyncio.sleep(0.2)
        print("订单已取消")
    
    async def process_payment(self, step_data: Dict) -> Dict[str, Any]:
        """处理支付"""
        print(f"正在处理支付，金额: ${step_data['amount']}")
        await asyncio.sleep(1.0)
        
        # 模拟支付失败（10%概率）
        import random
        if random.random() < 0.1:
            raise Exception("支付处理失败")
        
        payment_id = f"payment-{uuid.uuid4()}"
        return {
            'payment_id': payment_id,
            'status': 'completed',
            'amount': step_data['amount']
        }
    
    async def refund_payment(self, step_data: Dict, result: Dict):
        """退款"""
        print(f"正在退款 {result['payment_id']}...")
        await asyncio.sleep(0.3)
        print("退款完成")
    
    async def reserve_inventory(self, step_data: Dict) -> Dict[str, Any]:
        """预留库存"""
        print(f"正在预留库存，产品: {step_data['product_id']}, 数量: {step_data['quantity']}")
        await asyncio.sleep(0.8)
        
        # 模拟库存不足（15%概率）
        import random
        if random.random() < 0.15:
            raise Exception("库存不足")
        
        return {
            'reservation_id': f"res-{uuid.uuid4()}",
            'product_id': step_data['product_id'],
            'quantity': step_data['quantity']
        }
    
    async def release_inventory(self, step_data: Dict, result: Dict):
        """释放库存"""
        print(f"正在释放库存预留 {result['reservation_id']}...")
        await asyncio.sleep(0.2)
        print("库存已释放")
    
    async def ship_order(self, step_data: Dict) -> Dict[str, Any]:
        """发货"""
        print("正在准备发货...")
        await asyncio.sleep(0.6)
        
        shipping_id = f"ship-{uuid.uuid4()}"
        return {
            'shipping_id': shipping_id,
            'status': 'shipped'
        }
    
    async def cancel_shipment(self, step_data: Dict, result: Dict):
        """取消发货"""
        print(f"正在取消发货 {result['shipping_id']}...")
        await asyncio.sleep(0.3)
        print("发货已取消")
    
    async def execute_order_saga(self) -> bool:
        """执行订单Saga"""
        print(f"开始执行订单Saga: {self.orchestrator.saga_id}")
        
        try:
            success = await self.orchestrator.execute()
            
            if success:
                print("订单处理成功！")
            else:
                print("订单处理失败，已启动补偿流程")
            
            return success
            
        except Exception as e:
            print(f"Saga执行异常: {e}")
            return False

# 使用示例
async def demo_ecommerce_saga():
    """演示电商订单Saga"""
    saga = ECommerceSaga()
    await saga.execute_order_saga()
```

## 最终一致性

### 7. 事件溯源与CQRS
```python
from typing import List, Dict, Any
from dataclasses import dataclass, field
from datetime import datetime
import json

@dataclass
class Event:
    """领域事件"""
    event_id: str
    event_type: str
    aggregate_id: str
    event_data: Dict[str, Any]
    timestamp: datetime
    version: int
    metadata: Dict[str, Any] = field(default_factory=dict)

class EventStore:
    """事件存储"""
    
    def __init__(self):
        self.events: List[Event] = []
        self.event_streams: Dict[str, List[Event]] = {}  # aggregate_id -> events
    
    def append_event(self, event: Event):
        """追加事件"""
        # 按聚合ID分组
        if event.aggregate_id not in self.event_streams:
            self.event_streams[event.aggregate_id] = []
        
        # 检查版本冲突
        stream = self.event_streams[event.aggregate_id]
        if stream and stream[-1].version + 1 != event.version:
            raise Exception(f"版本冲突: 期望版本 {stream[-1].version + 1}, 实际版本 {event.version}")
        
        # 追加事件
        self.events.append(event)
        stream.append(event)
    
    def get_events_for_aggregate(self, aggregate_id: str, 
                               from_version: int = 0) -> List[Event]:
        """获取聚合的事件"""
        if aggregate_id not in self.event_streams:
            return []
        
        stream = self.event_streams[aggregate_id]
        return [event for event in stream if event.version > from_version]
    
    def get_all_events(self) -> List[Event]:
        """获取所有事件"""
        return self.events.copy()

class Aggregate:
    """聚合根"""
    
    def __init__(self, aggregate_id: str, event_store: EventStore):
        self.aggregate_id = aggregate_id
        self.event_store = event_store
        self.version = 0
        self.uncommitted_events: List[Event] = []
    
    def load_from_events(self):
        """从事件流中重建聚合状态"""
        events = self.event_store.get_events_for_aggregate(self.aggregate_id)
        
        for event in events:
            self.handle_event(event)
            self.version = event.version
    
    def handle_event(self, event: Event):
        """处理事件（子类实现）"""
        pass
    
    def create_event(self, event_type: str, event_data: Dict[str, Any], 
                    metadata: Dict[str, Any] = None) -> Event:
        """创建事件"""
        self.version += 1
        
        event = Event(
            event_id=str(uuid.uuid4()),
            event_type=event_type,
            aggregate_id=self.aggregate_id,
            event_data=event_data,
            timestamp=datetime.now(),
            version=self.version,
            metadata=metadata or {}
        )
        
        self.uncommitted_events.append(event)
        return event
    
    def commit_events(self):
        """提交事件"""
        for event in self.uncommitted_events:
            self.event_store.append_event(event)
        
        self.uncommitted_events.clear()
    
    def get_uncommitted_events(self) -> List[Event]:
        """获取未提交的事件"""
        return self.uncommitted_events.copy()

class OrderAggregate(Aggregate):
    """订单聚合"""
    
    def __init__(self, order_id: str, event_store: EventStore):
        super().__init__(order_id, event_store)
        self.order_status = None
        self.items = []
        self.total_amount = 0
    
    def handle_event(self, event: Event):
        """处理事件"""
        if event.event_type == 'OrderCreated':
            self._handle_order_created(event)
        elif event.event_type == 'OrderItemAdded':
            self._handle_order_item_added(event)
        elif event.event_type == 'OrderPaid':
            self._handle_order_paid(event)
        elif event.event_type == 'OrderCancelled':
            self._handle_order_cancelled(event)
    
    def _handle_order_created(self, event: Event):
        """处理订单创建事件"""
        self.order_status = 'created'
        self.total_amount = event.event_data.get('total_amount', 0)
    
    def _handle_order_item_added(self, event: Event):
        """处理订单项添加事件"""
        self.items.append(event.event_data['item'])
    
    def _handle_order_paid(self, event: Event):
        """处理订单支付事件"""
        self.order_status = 'paid'
    
    def _handle_order_cancelled(self, event: Event):
        """处理订单取消事件"""
        self.order_status = 'cancelled'
    
    def create_order(self, total_amount: float) -> Event:
        """创建订单"""
        if self.order_status is not None:
            raise Exception("订单已存在")
        
        return self.create_event(
            'OrderCreated',
            {'total_amount': total_amount}
        )
    
    def add_order_item(self, item: Dict[str, Any]) -> Event:
        """添加订单项"""
        if self.order_status != 'created':
            raise Exception("只能向创建状态的订单添加商品")
        
        return self.create_event(
            'OrderItemAdded',
            {'item': item}
        )
    
    def pay_order(self) -> Event:
        """支付订单"""
        if self.order_status != 'created':
            raise Exception("只能支付创建状态的订单")
        
        return self.create_event(
            'OrderPaid',
            {'paid_amount': self.total_amount}
        )
    
    def cancel_order(self) -> Event:
        """取消订单"""
        if self.order_status in ['paid', 'shipped', 'delivered']:
            raise Exception("已支付或后续状态的订单不能取消")
        
        return self.create_event(
            'OrderCancelled',
            {'reason': 'user_cancelled'}
        )

class CQRSProjection:
    """CQRS投影"""
    
    def __init__(self, projection_name: str):
        self.projection_name = projection_name
        self.state: Dict[str, Any] = {}
        self.last_processed_version = 0
    
    async def handle_event(self, event: Event):
        """处理事件"""
        if event.version <= self.last_processed_version:
            return
        
        if event.event_type == 'OrderCreated':
            self._handle_order_created(event)
        elif event.event_type == 'OrderPaid':
            self._handle_order_paid(event)
        elif event.event_type == 'OrderCancelled':
            self._handle_order_cancelled(event)
        
        self.last_processed_version = event.version
    
    def _handle_order_created(self, event: Event):
        """处理订单创建"""
        order_id = event.aggregate_id
        self.state[order_id] = {
            'order_id': order_id,
            'status': 'created',
            'total_amount': event.event_data['total_amount'],
            'items': [],
            'created_at': event.timestamp
        }
    
    def _handle_order_paid(self, event: Event):
        """处理订单支付"""
        order_id = event.aggregate_id
        if order_id in self.state:
            self.state[order_id]['status'] = 'paid'
            self.state[order_id]['paid_at'] = event.timestamp
    
    def _handle_order_cancelled(self, event: Event):
        """处理订单取消"""
        order_id = event.aggregate_id
        if order_id in self.state:
            self.state[order_id]['status'] = 'cancelled'
            self.state[order_id]['cancelled_at'] = event.timestamp
            self.state[order_id]['cancellation_reason'] = event.event_data.get('reason')

class EventualConsistencyManager:
    """最终一致性管理器"""
    
    def __init__(self):
        self.event_store = EventStore()
        self.projections = {}
        self.retry_policies = {}
    
    def register_projection(self, projection_name: str, projection: CQRSProjection):
        """注册投影"""
        self.projections[projection_name] = projection
    
    async def publish_event(self, event: Event):
        """发布事件"""
        # 提交到事件存储
        self.event_store.append_event(event)
        
        # 异步分发到所有投影
        tasks = []
        for projection_name, projection in self.projections.items():
            tasks.append(self._deliver_to_projection(projection_name, projection, event))
        
        await asyncio.gather(*tasks, return_exceptions=True)
    
    async def _deliver_to_projection(self, projection_name: str, 
                                   projection: CQRSProjection, event: Event):
        """分发事件到投影"""
        try:
            await projection.handle_event(event)
        except Exception as e:
            print(f"投影 {projection_name} 处理事件失败: {e}")
            
            # 启动重试策略
            retry_policy = self.retry_policies.get(projection_name)
            if retry_policy:
                await self._retry_delivery(projection_name, projection, event, retry_policy)
    
    def _retry_policies(self, projection_name: str, policy: Dict[str, Any]):
        """设置重试策略"""
        self.retry_policies[projection_name] = policy
    
    async def _retry_delivery(self, projection_name: str, projection: CQRSProjection, 
                            event: Event, policy: Dict[str, Any]):
        """重试投递"""
        max_retries = policy.get('max_retries', 3)
        retry_delay = policy.get('retry_delay', 1.0)
        
        for attempt in range(max_retries):
            try:
                await asyncio.sleep(retry_delay * (2 ** attempt))  # 指数退避
                await projection.handle_event(event)
                print(f"重试成功: 投影 {projection_name}")
                break
            except Exception as e:
                print(f"重试失败 {attempt + 1}/{max_retries}: {e}")
    
    def get_projection_state(self, projection_name: str) -> Dict[str, Any]:
        """获取投影状态"""
        if projection_name in self.projections:
            return self.projections[projection_name].state
        return {}
    
    def replay_events(self, from_version: int = 0):
        """重放事件（用于重建投影）"""
        all_events = self.event_store.get_all_events()
        
        # 重置所有投影状态
        for projection in self.projections.values():
            projection.state = {}
            projection.last_processed_version = 0
        
        # 按版本顺序重放事件
        for event in sorted(all_events, key=lambda x: x.version):
            if event.version > from_version:
                for projection in self.projections.values():
                    try:
                        projection.handle_event(event)
                    except Exception as e:
                        print(f"重放事件失败: {e}")

# 使用示例
async def demo_eventual_consistency():
    """演示最终一致性"""
    print("\n=== 事件溯源与CQRS演示 ===")
    
    # 创建一致性管理器
    consistency_manager = EventualConsistencyManager()
    
    # 创建投影
    order_list_projection = CQRSProjection("order_list")
    order_summary_projection = CQRSProjection("order_summary")
    
    consistency_manager.register_projection("order_list", order_list_projection)
    consistency_manager.register_projection("order_summary", order_summary_projection)
    
    # 设置重试策略
    consistency_manager.retry_policies["order_list"] = {
        "max_retries": 3,
        "retry_delay": 1.0
    }
    
    # 创建订单聚合
    order_aggregate = OrderAggregate("order-123", consistency_manager.event_store)
    
    # 创建订单
    create_event = order_aggregate.create_order(100.0)
    await consistency_manager.publish_event(create_event)
    order_aggregate.commit_events()
    
    print("订单创建完成")
    
    # 添加订单项
    add_item_event = order_aggregate.add_order_item({
        "product_id": "product-1",
        "quantity": 2,
        "price": 50.0
    })
    await consistency_manager.publish_event(add_item_event)
    order_aggregate.commit_events()
    
    print("订单项添加完成")
    
    # 支付订单
    pay_event = order_aggregate.pay_order()
    await consistency_manager.publish_event(pay_event)
    order_aggregate.commit_events()
    
    print("订单支付完成")
    
    # 等待最终一致性同步
    await asyncio.sleep(1)
    
    # 查看投影状态
    print("\n=== 投影状态 ===")
    print("订单列表投影:")
    print(json.dumps(consistency_manager.get_projection_state("order_list"), indent=2))
    print("\n订单摘要投影:")
    print(json.dumps(consistency_manager.get_projection_state("order_summary"), indent=2))
```

这个数据一致性概述文档详细介绍了分布式系统中各种一致性问题的解决方案，包括：

1. **CAP定理** - 强一致性、最终一致性、仲裁一致性模型
2. **一致性模型** - 线性一致性、顺序一致性、因果一致性
3. **分布式事务** - 两阶段提交（2PC）和三阶段提交（3PC）的完整实现
4. **Saga模式** - 编排式和编舞式Saga实现，包括电商订单处理示例
5. **最终一致性** - 事件溯源、CQRS模式的实现

每个概念都配有详细的Python代码实现，展示了如何在实际项目中处理数据一致性问题。通过这些实现，可以更好地理解和应用不同的一致性策略。