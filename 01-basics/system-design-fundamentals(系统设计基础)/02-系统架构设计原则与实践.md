# 系统架构设计原则与实践

## 概述

系统架构设计是构建大规模分布式系统的核心环节，决定了系统的可扩展性、可维护性、高可用性和性能。本文档探讨系统架构设计的基本原则、设计模式及实践方法，帮助开发者构建健壮、高效的软件系统。

## 架构设计原则

### SOLID原则

SOLID是面向对象设计中的五项基本原则，通过遵循这些原则可以设计出更易维护、可扩展的系统架构。

| 原则名称 | 英文全称 | 核心思想 | 优势 |
|---------|---------|---------|------|
| 单一职责原则 | Single Responsibility Principle | 一个类/模块只负责一个功能领域 | 降低复杂性，提高内聚性 |
| 开闭原则 | Open-Closed Principle | 对扩展开放，对修改关闭 | 系统更稳定，便于扩展 |
| 里氏替换原则 | Liskov Substitution Principle | 子类可以替换父类而不改变程序正确性 | 提高代码复用性和可扩展性 |
| 接口隔离原则 | Interface Segregation Principle | 不强迫客户端实现不需要的接口 | 减少耦合，提高灵活性 |
| 依赖倒置原则 | Dependency Inversion Principle | 依赖抽象而非具体实现 | 提高系统灵活性和可测试性 |

#### 单一职责原则示例

单一职责原则要求一个类只负责一个功能领域，当类的职责过多时，应该拆分为多个职责单一的类。

```python
# 单一职责原则示例 - 将用户管理拆分为多个职责单一的类

class UserRepository:
    """用户数据仓储 - 单一职责：只负责用户数据的CRUD操作"""
    
    def __init__(self):
        self.users = {}
    
    def save(self, user: dict) -> str:
        """保存用户"""
        if 'id' not in user:
            user['id'] = str(time.time())
        self.users[user['id']] = user.copy()
        return user['id']
    
    def find_by_id(self, user_id: str):
        """根据ID查找用户"""
        return self.users.get(user_id)
    
    def find_by_email(self, email: str):
        """根据邮箱查找用户"""
        for user in self.users.values():
            if user.get('email') == email:
                return user
        return None

class EmailValidator:
    """邮箱验证器 - 单一职责：验证邮箱格式"""
    
    def is_valid(self, email: str) -> bool:
        import re
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, email))

class PasswordHasher:
    """密码哈希器 - 单一职责：处理密码哈希和验证"""
    
    def hash(self, password: str) -> str:
        """哈希密码"""
        import hashlib, secrets
        salt = secrets.token_hex(16)
        hashed = hashlib.sha256((password + salt).encode()).hexdigest()
        return f"{salt}:{hashed}"
    
    def verify(self, password: str, hashed_password: str) -> bool:
        """验证密码"""
        try:
            salt, stored_hash = hashed_password.split(':')
            computed_hash = hashlib.sha256((password + salt).encode()).hexdigest()
            return computed_hash == stored_hash
        except ValueError:
            return False

class UserService:
    """用户服务 - 单一职责：处理用户相关的业务逻辑"""
    
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository
        self.email_validator = EmailValidator()
        self.password_hasher = PasswordHasher()
    
    def create_user(self, user_data: dict) -> dict:
        """创建用户"""
        # 验证数据
        if not self.email_validator.is_valid(user_data.get('email', '')):
            raise ValueError("无效的邮箱地址")
        
        # 哈希密码
        user_data['password'] = self.password_hasher.hash(user_data['password'])
        
        # 保存用户
        user_id = self.user_repository.save(user_data)
        return self.user_repository.find_by_id(user_id)

#### 开闭原则示例

开闭原则要求系统对扩展开放，对修改关闭。通过抽象接口和多态性，可以在不修改现有代码的情况下扩展系统功能。

```python
# 开闭原则示例 - 通知系统的可扩展设计
from abc import ABC, abstractmethod

class NotificationChannel(ABC):
    """通知渠道抽象接口"""
    
    @abstractmethod
    def send(self, message: str, recipient: str) -> bool:
        """发送通知"""
        pass

# 具体实现类 - 通过扩展而非修改来添加新功能
class EmailNotificationChannel(NotificationChannel):
    """邮件通知渠道"""
    
    def send(self, message: str, recipient: str) -> bool:
        print(f"发送邮件到 {recipient}: {message}")
        return True

class SMSNotificationChannel(NotificationChannel):
    """短信通知渠道"""
    
    def send(self, message: str, recipient: str) -> bool:
        print(f"发送短信到 {recipient}: {message}")
        return True

class NotificationService:
    """通知服务 - 对扩展开放，对修改关闭"""
    
    def __init__(self):
        self.channels = {}
    
    def register_channel(self, channel_type: str, channel: NotificationChannel):
        """注册通知渠道"""
        self.channels[channel_type] = channel
    
    def send_notification(self, channel_type: str, message: str, recipient: str) -> bool:
        """发送通知"""
        channel = self.channels.get(channel_type)
        if not channel:
            raise ValueError(f"未知的通知渠道: {channel_type}")
        
        return channel.send(message, recipient)
```

#### 依赖倒置原则示例

依赖倒置原则要求高层模块依赖抽象，而不是依赖具体实现。这提高了系统的灵活性和可测试性。

```python
# 依赖倒置原则示例 - 缓存服务的灵活设计
from abc import ABC, abstractmethod

class DataStorage(ABC):
    """数据存储抽象接口"""
    
    @abstractmethod
    def store(self, key: str, data) -> bool:
        """存储数据"""
        pass
    
    @abstractmethod
    def retrieve(self, key: str):
        """检索数据"""
        pass
    
    @abstractmethod
    def delete(self, key: str) -> bool:
        """删除数据"""
        pass

# 具体实现 - 内存存储
class MemoryDataStorage(DataStorage):
    """内存数据存储实现"""
    
    def __init__(self):
        self.data = {}
    
    def store(self, key: str, data) -> bool:
        self.data[key] = data
        return True
    
    def retrieve(self, key: str):
        return self.data.get(key)
    
    def delete(self, key: str) -> bool:
        return self.data.pop(key, None) is not None

# 缓存服务依赖抽象接口而非具体实现
class CacheService:
    """缓存服务 - 依赖于抽象而非具体实现"""
    
    def __init__(self, storage: DataStorage):  # 依赖倒置
        self.storage = storage
        self.hits = 0
        self.misses = 0
    
    def get(self, key: str):
        """获取缓存数据"""
        data = self.storage.retrieve(key)
        if data is not None:
            self.hits += 1
            return data
        else:
            self.misses += 1
            return None
    
    def set(self, key: str, data) -> bool:
        """设置缓存数据"""
        return self.storage.store(key, data)
```
```

## 架构设计模式

### 分层架构模式

分层架构将系统分为不同的层次，每一层负责特定的职责，通过明确的接口与其他层交互。这种设计提供了良好的关注点分离和可维护性。

```python
# 分层架构模式示例 - 精简版
from abc import ABC, abstractmethod
from typing import Optional, Callable

class Layer(ABC):
    """层抽象基类 - 定义所有层必须实现的接口"""
    
    def __init__(self, name: str):
        self.name = name
        self.next_layer: Optional[Layer] = None
    
    def set_next_layer(self, layer: Layer):
        """设置下一层 - 构建层间调用链"""
        self.next_layer = layer
    
    @abstractmethod
    def process(self, request) -> object:
        """处理请求 - 每层必须实现的核心方法"""
        pass
    
    def handle_request(self, request) -> object:
        """处理请求并传递到下一层"""
        result = self.process(request)
        
        # 如果有下一层，则继续传递请求
        if self.next_layer:
            return self.next_layer.handle_request(result)
        
        return result

# 表现层 - 处理用户界面和交互
class PresentationLayer(Layer):
    """表现层 - 负责请求验证和格式转换"""
    
    def __init__(self):
        super().__init__("Presentation")
        self.validators = []
    
    def add_validator(self, validator: Callable):
        """添加请求验证器"""
        self.validators.append(validator)
    
    def process(self, request) -> object:
        """处理请求 - 验证并转换格式"""
        # 验证请求
        for validator in self.validators:
            if not validator(request):
                raise ValueError("请求验证失败")
        
        # 转换请求格式
        if isinstance(request, dict) and 'data' in request:
            return request['data']
        return request

# 业务逻辑层 - 包含核心业务逻辑
class BusinessLogicLayer(Layer):
    """业务逻辑层 - 负责核心业务规则处理"""
    
    def __init__(self):
        super().__init__("BusinessLogic")
        self.business_rules = []
    
    def add_rule(self, rule: Callable):
        """添加业务规则"""
        self.business_rules.append(rule)
    
    def process(self, request) -> object:
        """处理业务逻辑 - 应用业务规则"""
        result = request
        for rule in self.business_rules:
            result = rule(result)
        return result

# 数据访问层 - 负责数据存储和检索
class DataAccessLayer(Layer):
    """数据访问层 - 负责数据持久化操作"""
    
    def __init__(self):
        super().__init__("DataAccess")
        self.storage = {}
    
    def process(self, request) -> object:
        """处理数据操作 - 执行CRUD操作"""
        if isinstance(request, dict) and 'operation' in request:
            op = request['operation']
            
            if op == 'save':
                # 保存数据
                key = request.get('key')
                value = request.get('value')
                if key:
                    self.storage[key] = value
                    return f"数据已保存: {key}"
            
            elif op == 'get':
                # 获取数据
                key = request.get('key')
                return self.storage.get(key)
        
        return "未知操作"

# 分层架构组装器
class LayeredArchitecture:
    """分层架构系统 - 组装和管理各层"""
    
    def __init__(self):
        # 创建各层实例
        self.presentation = PresentationLayer()
        self.business = BusinessLogicLayer()
        self.data = DataAccessLayer()
        
        # 建立层间连接
        self.presentation.set_next_layer(self.business)
        self.business.set_next_layer(self.data)
    
    def handle_request(self, request) -> object:
        """处理请求 - 从表现层开始"""
        return self.presentation.handle_request(request)
```

分层架构的核心优势在于：

1. **关注点分离** - 每层只关注自己的职责
2. **易于维护** - 变更局限在特定层内
3. **灵活性** - 可以替换特定层的实现而不影响其他层
4. **可测试性** - 各层可以独立测试

实际应用中，分层架构通常包括表现层(UI)、业务逻辑层、数据访问层，大型应用可能会有更多细分层次。

### 微服务架构模式

```python
import asyncio
import aiohttp
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import time
import uuid

class ServiceStatus(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    STARTING = "starting"
    STOPPED = "stopped"

@dataclass
class ServiceConfig:
    """服务配置"""
    name: str
    version: str
    port: int
    health_check_url: str
    dependencies: List[str]
    max_instances: int = 1
    auto_scale: bool = False

class ServiceInstance:
    """服务实例"""
    
    def __init__(self, instance_id: str, config: ServiceConfig, host: str = "localhost"):
        self.instance_id = instance_id
        self.config = config
        self.host = host
        self.status = ServiceStatus.STARTING
        self.created_at = time.time()
        self.last_health_check = time.time()
        self.request_count = 0
        self.error_count = 0
        self.avg_response_time = 0.0
    
    def update_health(self, is_healthy: bool):
        """更新健康状态"""
        self.status = ServiceStatus.HEALTHY if is_healthy else ServiceStatus.UNHEALTHY
        self.last_health_check = time.time()
    
    def increment_request_count(self, response_time: float):
        """增加请求计数"""
        self.request_count += 1
        # 更新平均响应时间
        self.avg_response_time = (self.avg_response_time * (self.request_count - 1) + response_time) / self.request_count
    
    def increment_error_count(self):
        """增加错误计数"""
        self.error_count += 1
    
    def get_health_score(self) -> float:
        """获取健康分数"""
        if self.status == ServiceStatus.UNHEALTHY:
            return 0.0
        elif self.status == ServiceStatus.HEALTHY:
            error_rate = self.error_count / max(self.request_count, 1)
            return max(0.0, 1.0 - error_rate)
        else:
            return 0.5

class ServiceRegistry:
    """服务注册中心"""
    
    def __init__(self):
        self.services: Dict[str, List[ServiceInstance]] = {}
        self.service_configs: Dict[str, ServiceConfig] = {}
        self._lock = asyncio.Lock()
    
    async def register_service(self, config: ServiceConfig, instance_id: str = None):
        """注册服务"""
        async with self._lock:
            if instance_id is None:
                instance_id = f"{config.name}-{str(uuid.uuid4())[:8]}"
            
            instance = ServiceInstance(instance_id, config)
            
            if config.name not in self.services:
                self.services[config.name] = []
            
            self.services[config.name].append(instance)
            self.service_configs[config.name] = config
            
            print(f"服务已注册: {config.name} ({instance_id})")
    
    async def deregister_service(self, service_name: str, instance_id: str):
        """注销服务"""
        async with self._lock:
            if service_name in self.services:
                self.services[service_name] = [
                    inst for inst in self.services[service_name]
                    if inst.instance_id != instance_id
                ]
                
                if not self.services[service_name]:
                    del self.services[service_name]
                    if service_name in self.service_configs:
                        del self.service_configs[service_name]
    
    async def discover_service(self, service_name: str, healthy_only: bool = True) -> List[ServiceInstance]:
        """发现服务"""
        async with self._lock:
            instances = self.services.get(service_name, [])
            
            if healthy_only:
                instances = [inst for inst in instances if inst.status == ServiceStatus.HEALTHY]
            
            return instances
    
    async def health_check(self):
        """健康检查"""
        async with self._lock:
            for service_name, instances in self.services.items():
                for instance in instances:
                    try:
                        async with aiohttp.ClientSession() as session:
                            async with session.get(f"http://{instance.host}:{instance.config.port}/{instance.config.health_check_url}") as response:
                                is_healthy = response.status == 200
                                instance.update_health(is_healthy)
                    except Exception as e:
                        print(f"健康检查失败 {service_name}/{instance.instance_id}: {e}")
                        instance.update_health(False)
    
    def get_service_stats(self) -> Dict:
        """获取服务统计"""
        stats = {}
        for service_name, instances in self.services.items():
            healthy_count = sum(1 for inst in instances if inst.status == ServiceStatus.HEALTHY)
            total_requests = sum(inst.request_count for inst in instances)
            total_errors = sum(inst.error_count for inst in instances)
            
            stats[service_name] = {
                'total_instances': len(instances),
                'healthy_instances': healthy_count,
                'unhealthy_instances': len(instances) - healthy_count,
                'total_requests': total_requests,
                'total_errors': total_errors,
                'error_rate': total_errors / max(total_requests, 1)
            }
        
        return stats

class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self, strategy: str = "round_robin"):
        self.strategy = strategy
        self.current_index = {}
    
    async def select_instance(self, instances: List[ServiceInstance]) -> Optional[ServiceInstance]:
        """选择实例"""
        if not instances:
            return None
        
        if self.strategy == "round_robin":
            service_name = instances[0].config.name
            current_idx = self.current_index.get(service_name, 0)
            selected = instances[current_idx % len(instances)]
            self.current_index[service_name] = (current_idx + 1) % len(instances)
            return selected
        
        elif self.strategy == "least_connections":
            return min(instances, key=lambda x: x.request_count)
        
        elif self.strategy == "weighted_response_time":
            # 根据响应时间加权选择
            weights = [(1.0 / max(inst.avg_response_time, 0.001)) for inst in instances]
            import random
            total_weight = sum(weights)
            if total_weight == 0:
                return random.choice(instances)
            
            r = random.uniform(0, total_weight)
            upto = 0
            for i, weight in enumerate(weights):
                if upto + weight >= r:
                    return instances[i]
                upto += weight
            return instances[-1]
        
        else:
            return instances[0]

class APIGateway:
    """API网关"""
    
    def __init__(self, service_registry: ServiceRegistry, load_balancer: LoadBalancer):
        self.service_registry = service_registry
        self.load_balancer = load_balancer
        self.routes: Dict[str, Dict] = {}
        self.middleware: List[Callable] = []
        self.request_stats = {}
    
    def add_route(self, path_pattern: str, service_name: str, methods: List[str] = None):
        """添加路由"""
        if methods is None:
            methods = ["GET", "POST", "PUT", "DELETE"]
        
        self.routes[path_pattern] = {
            'service_name': service_name,
            'methods': methods
        }
    
    def add_middleware(self, middleware: Callable):
        """添加中间件"""
        self.middleware.append(middleware)
    
    async def handle_request(self, method: str, path: str, headers: Dict, body: Any = None) -> Dict:
        """处理请求"""
        # 应用中间件
        for middleware in self.middleware:
            result = await middleware(method, path, headers, body)
            if result is not None:
                return result
        
        # 路由匹配
        service_name = self._match_route(path)
        if not service_name:
            return {
                'status': 404,
                'body': {'error': 'Route not found'},
                'headers': {}
            }
        
        # 获取服务实例
        instances = await self.service_registry.discover_service(service_name)
        if not instances:
            return {
                'status': 503,
                'body': {'error': 'Service unavailable'},
                'headers': {}
            }
        
        # 负载均衡选择实例
        instance = await self.load_balancer.select_instance(instances)
        if not instance:
            return {
                'status': 503,
                'body': {'error': 'No healthy instances'},
                'headers': {}
            }
        
        # 转发请求
        start_time = time.time()
        try:
            async with aiohttp.ClientSession() as session:
                url = f"http://{instance.host}:{instance.config.port}{path}"
                async with session.request(method, url, headers=headers, json=body) as response:
                    response_body = await response.text()
                    response_time = time.time() - start_time
                    
                    # 更新实例统计
                    instance.increment_request_count(response_time)
                    if response.status >= 400:
                        instance.increment_error_count()
                    
                    return {
                        'status': response.status,
                        'body': response_body,
                        'headers': dict(response.headers)
                    }
        
        except Exception as e:
            instance.increment_error_count()
            return {
                'status': 500,
                'body': {'error': str(e)},
                'headers': {}
            }
    
    def _match_route(self, path: str) -> Optional[str]:
        """路由匹配"""
        for pattern, route_info in self.routes.items():
            if self._path_matches(pattern, path):
                return route_info['service_name']
        return None
    
    def _path_matches(self, pattern: str, path: str) -> bool:
        """简单路径匹配"""
        # 简化实现，实际应该支持更复杂的匹配规则
        return pattern in path

class Microservice:
    """微服务基类"""
    
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.app = None
        self.is_running = False
        self.request_handlers: Dict[str, Callable] = {}
    
    def add_handler(self, endpoint: str, handler: Callable):
        """添加请求处理器"""
        self.request_handlers[endpoint] = handler
    
    async def start(self):
        """启动微服务"""
        print(f"启动微服务: {self.config.name} v{self.config.version}")
        self.is_running = True
        
        # 这里应该启动实际的web服务器
        # 简化实现
        while self.is_running:
            await asyncio.sleep(1)
    
    async def stop(self):
        """停止微服务"""
        print(f"停止微服务: {self.config.name}")
        self.is_running = False
    
    async def health_check(self) -> bool:
        """健康检查"""
        return self.is_running
    
    def get_status(self) -> Dict:
        """获取服务状态"""
        return {
            'name': self.config.name,
            'version': self.config.version,
            'status': 'running' if self.is_running else 'stopped',
            'port': self.config.port,
            'endpoints': list(self.request_handlers.keys())
        }
```

### 事件驱动架构模式

```python
import asyncio
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Callable, Optional
from dataclasses import dataclass, field
import json
import time
from enum import Enum

class EventType(Enum):
    USER_REGISTERED = "user.registered"
    USER_LOGGED_IN = "user.logged_in"
    ORDER_CREATED = "order.created"
    ORDER_PAID = "order.paid"
    PRODUCT_STOCK_LOW = "product.stock_low"
    NOTIFICATION_SENT = "notification.sent"

@dataclass
class Event:
    """事件"""
    event_id: str
    event_type: EventType
    timestamp: float
    data: Dict[str, Any]
    source: str
    correlation_id: Optional[str] = None
    
    def to_dict(self) -> Dict:
        return {
            'event_id': self.event_id,
            'event_type': self.event_type.value,
            'timestamp': self.timestamp,
            'data': self.data,
            'source': self.source,
            'correlation_id': self.correlation_id
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Event':
        return cls(
            event_id=data['event_id'],
            event_type=EventType(data['event_type']),
            timestamp=data['timestamp'],
            data=data['data'],
            source=data['source'],
            correlation_id=data.get('correlation_id')
        )

class EventHandler(ABC):
    """事件处理器抽象"""
    
    @abstractmethod
    async def handle(self, event: Event) -> bool:
        """处理事件"""
        pass
    
    @abstractmethod
    def can_handle(self, event_type: EventType) -> bool:
        """检查是否可以处理该类型事件"""
        pass

class UserRegistrationHandler(EventHandler):
    """用户注册事件处理器"""
    
    def __init__(self, user_service: Any, notification_service: Any):
        self.user_service = user_service
        self.notification_service = notification_service
    
    async def handle(self, event: Event) -> bool:
        """处理用户注册事件"""
        try:
            user_data = event.data
            # 发送欢迎邮件
            await self.notification_service.send_email(
                user_data['email'],
                "欢迎注册",
                f"欢迎 {user_data['name']} 注册我们的服务！"
            )
            
            # 更新用户状态
            await self.user_service.mark_as_registered(user_data['user_id'])
            
            print(f"处理用户注册事件: {event.event_id}")
            return True
        
        except Exception as e:
            print(f"处理用户注册事件失败: {e}")
            return False
    
    def can_handle(self, event_type: EventType) -> bool:
        return event_type == EventType.USER_REGISTERED

class OrderCreatedHandler(EventHandler):
    """订单创建事件处理器"""
    
    def __init__(self, inventory_service: Any, notification_service: Any):
        self.inventory_service = inventory_service
        self.notification_service = notification_service
    
    async def handle(self, event: Event) -> bool:
        """处理订单创建事件"""
        try:
            order_data = event.data
            
            # 检查库存
            for item in order_data['items']:
                stock_level = await self.inventory_service.get_stock_level(item['product_id'])
                if stock_level < item['quantity']:
                    # 发送库存不足通知
                    low_stock_event = Event(
                        event_id=f"{event.event_id}_stock_low",
                        event_type=EventType.PRODUCT_STOCK_LOW,
                        timestamp=time.time(),
                        data={
                            'product_id': item['product_id'],
                            'current_stock': stock_level,
                            'required_quantity': item['quantity']
                        },
                        source="order_service",
                        correlation_id=event.correlation_id
                    )
                    
                    # 这里应该发布库存不足事件
                    print(f"库存不足事件已生成: {low_stock_event.event_id}")
            
            # 发送订单确认邮件
            await self.notification_service.send_email(
                order_data['customer_email'],
                "订单确认",
                f"您的订单 {order_data['order_id']} 已创建"
            )
            
            print(f"处理订单创建事件: {event.event_id}")
            return True
        
        except Exception as e:
            print(f"处理订单创建事件失败: {e}")
            return False
    
    def can_handle(self, event_type: EventType) -> bool:
        return event_type == EventType.ORDER_CREATED

class EventBus:
    """事件总线"""
    
    def __init__(self):
        self.handlers: Dict[EventType, List[EventHandler]] = {}
        self.event_store: List[Event] = []
        self._subscribers: Dict[str, Callable] = {}
    
    def subscribe(self, event_type: EventType, handler: EventHandler):
        """订阅事件"""
        if event_type not in self.handlers:
            self.handlers[event_type] = []
        
        self.handlers[event_type].append(handler)
        print(f"事件处理器已订阅: {event_type.value}")
    
    def subscribe_with_callback(self, event_type: EventType, callback: Callable):
        """使用回调订阅事件"""
        event_type_str = event_type.value
        if event_type_str not in self._subscribers:
            self._subscribers[event_type_str] = []
        
        self._subscribers[event_type_str].append(callback)
    
    async def publish(self, event: Event):
        """发布事件"""
        print(f"发布事件: {event.event_type.value} ({event.event_id})")
        
        # 存储事件
        self.event_store.append(event)
        
        # 分发给处理器
        handlers = self.handlers.get(event.event_type, [])
        
        # 创建处理任务
        tasks = []
        for handler in handlers:
            if handler.can_handle(event.event_type):
                tasks.append(handler.handle(event))
        
        # 并发处理
        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 检查处理结果
            failed_handlers = []
            for i, result in enumerate(results):
                if isinstance(result, Exception) or not result:
                    failed_handlers.append(handlers[i])
            
            if failed_handlers:
                print(f"事件处理失败: {len(failed_handlers)} 个处理器失败")
        
        # 调用订阅回调
        callbacks = self._subscribers.get(event.event_type.value, [])
        for callback in callbacks:
            try:
                await callback(event)
            except Exception as e:
                print(f"回调执行失败: {e}")
    
    async def replay_events(self, event_type: EventType = None, start_time: float = None):
        """重放事件"""
        events_to_replay = self.event_store
        
        if event_type:
            events_to_replay = [e for e in events_to_replay if e.event_type == event_type]
        
        if start_time:
            events_to_replay = [e for e in events_to_replay if e.timestamp >= start_time]
        
        print(f"重放 {len(events_to_replay)} 个事件")
        
        for event in events_to_replay:
            await self.publish(event)
    
    def get_event_history(self, limit: int = 100) -> List[Dict]:
        """获取事件历史"""
        recent_events = self.event_store[-limit:]
        return [event.to_dict() for event in recent_events]

class EventStore:
    """事件存储"""
    
    def __init__(self, storage_path: str = "events.json"):
        self.storage_path = storage_path
        self.events: List[Event] = []
        self._load_events()
    
    def save_event(self, event: Event):
        """保存事件"""
        self.events.append(event)
        self._save_events()
    
    def get_events_by_type(self, event_type: EventType) -> List[Event]:
        """根据类型获取事件"""
        return [e for e in self.events if e.event_type == event_type]
    
    def get_events_by_correlation_id(self, correlation_id: str) -> List[Event]:
        """根据关联ID获取事件"""
        return [e for e in self.events if e.correlation_id == correlation_id]
    
    def _load_events(self):
        """加载事件"""
        try:
            import os
            if os.path.exists(self.storage_path):
                with open(self.storage_path, 'r') as f:
                    events_data = json.load(f)
                    self.events = [Event.from_dict(data) for data in events_data]
        except Exception as e:
            print(f"加载事件失败: {e}")
            self.events = []
    
    def _save_events(self):
        """保存事件"""
        try:
            import os
            os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)
            with open(self.storage_path, 'w') as f:
                events_data = [event.to_dict() for event in self.events]
                json.dump(events_data, f, indent=2)
        except Exception as e:
            print(f"保存事件失败: {e}")

class SAGAOrchestrator:
    """SAGA编排器"""
    
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.sagas: Dict[str, Dict] = {}
    
    async def start_saga(self, saga_id: str, initial_event: Event):
        """启动SAGA"""
        self.sagas[saga_id] = {
            'status': 'running',
            'current_step': 0,
            'steps': [],
            'events': [initial_event],
            'start_time': time.time()
        }
        
        print(f"SAGA已启动: {saga_id}")
        await self._execute_next_step(saga_id)
    
    def add_saga_step(self, saga_id: str, step: Dict):
        """添加SAGA步骤"""
        if saga_id in self.sagas:
            self.sagas[saga_id]['steps'].append(step)
    
    async def _execute_next_step(self, saga_id: str):
        """执行下一步骤"""
        if saga_id not in self.sagas:
            return
        
        saga = self.sagas[saga_id]
        current_step = saga['current_step']
        
        if current_step >= len(saga['steps']):
            # SAGA完成
            saga['status'] = 'completed'
            saga['end_time'] = time.time()
            print(f"SAGA完成: {saga_id}")
            return
        
        step = saga['steps'][current_step]
        
        try:
            # 执行步骤
            if step['type'] == 'event':
                # 发布事件
                event = Event(
                    event_id=f"{saga_id}_step_{current_step}",
                    event_type=EventType(step['event_type']),
                    timestamp=time.time(),
                    data=step['data'],
                    source="saga_orchestrator",
                    correlation_id=saga_id
                )
                
                await self.event_bus.publish(event)
                saga['events'].append(event)
            
            elif step['type'] == 'compensate':
                # 执行补偿操作
                print(f"执行补偿操作: {step['action']}")
                # 这里应该执行实际的补偿逻辑
            
            saga['current_step'] += 1
            
            # 如果不是最后一步，继续执行下一步
            if saga['current_step'] < len(saga['steps']):
                await self._execute_next_step(saga_id)
        
        except Exception as e:
            # SAGA失败，开始补偿
            saga['status'] = 'failed'
            saga['error'] = str(e)
            saga['end_time'] = time.time()
            
            await self._start_compensation(saga_id)
    
    async def _start_compensation(self, saga_id: str):
        """开始补偿"""
        saga = self.sagas[saga_id]
        print(f"SAGA开始补偿: {saga_id}")
        
        # 逆向执行补偿步骤
        for i in range(saga['current_step'] - 1, -1, -1):
            step = saga['steps'][i]
            if step.get('compensate_action'):
                try:
                    # 执行补偿操作
                    print(f"执行补偿: {step['compensate_action']}")
                    # 这里应该执行实际的补偿逻辑
                except Exception as e:
                    print(f"补偿操作失败: {e}")
        
        saga['status'] = 'compensated'
        saga['end_time'] = time.time()
        print(f"SAGA补偿完成: {saga_id}")
    
    def get_saga_status(self, saga_id: str) -> Optional[Dict]:
        """获取SAGA状态"""
        return self.sagas.get(saga_id)
    
    def get_all_sagas(self) -> Dict:
        """获取所有SAGA"""
        return self.sagas
```

## 架构实践案例

### 电商系统架构设计

```python
class EcommerceArchitecture:
    """电商系统架构"""
    
    def __init__(self):
        # 服务注册中心
        self.service_registry = ServiceRegistry()
        
        # API网关
        self.api_gateway = APIGateway(
            self.service_registry,
            LoadBalancer("round_robin")
        )
        
        # 事件总线
        self.event_bus = EventBus()
        
        # SAGA编排器
        self.saga_orchestrator = SAGAOrchestrator(self.event_bus)
        
        # 配置路由
        self._setup_routes()
        
        # 注册事件处理器
        self._register_event_handlers()
    
    def _setup_routes(self):
        """设置API路由"""
        self.api_gateway.add_route("/api/users", "user-service")
        self.api_gateway.add_route("/api/products", "product-service")
        self.api_gateway.add_route("/api/orders", "order-service")
        self.api_gateway.add_route("/api/payments", "payment-service")
        self.api_gateway.add_route("/api/inventory", "inventory-service")
        self.api_gateway.add_route("/api/notifications", "notification-service")
    
    def _register_event_handlers(self):
        """注册事件处理器"""
        # 这里应该创建实际的服务实例
        user_service = None  # 实际应该是UserService实例
        notification_service = None  # 实际应该是NotificationService实例
        inventory_service = None  # 实际应该是InventoryService实例
        
        user_handler = UserRegistrationHandler(user_service, notification_service)
        order_handler = OrderCreatedHandler(inventory_service, notification_service)
        
        self.event_bus.subscribe(EventType.USER_REGISTERED, user_handler)
        self.event_bus.subscribe(EventType.ORDER_CREATED, order_handler)
    
    async def create_order(self, order_data: Dict) -> Dict:
        """创建订单（使用事件驱动）"""
        # 生成订单ID
        order_id = f"order_{int(time.time())}"
        
        # 创建订单创建事件
        order_event = Event(
            event_id=order_id,
            event_type=EventType.ORDER_CREATED,
            timestamp=time.time(),
            data={
                'order_id': order_id,
                'customer_id': order_data['customer_id'],
                'items': order_data['items'],
                'total_amount': order_data['total_amount'],
                'customer_email': order_data['customer_email']
            },
            source="order_api",
            correlation_id=order_id
        )
        
        # 发布事件
        await self.event_bus.publish(order_event)
        
        # 启动SAGA编排（处理订单支付的分布式事务）
        await self._start_order_payment_saga(order_id, order_data)
        
        return {
            'order_id': order_id,
            'status': 'created',
            'message': '订单创建成功，正在处理中'
        }
    
    async def _start_order_payment_saga(self, order_id: str, order_data: Dict):
        """启动订单支付SAGA"""
        saga_id = f"payment_{order_id}"
        
        # 添加SAGA步骤
        steps = [
            {
                'type': 'event',
                'event_type': EventType.ORDER_CREATED.value,
                'data': {'order_id': order_id}
            },
            {
                'type': 'event',
                'event_type': EventType.ORDER_PAID.value,
                'data': {'order_id': order_id, 'payment_method': 'credit_card'},
                'compensate_action': 'cancel_order'
            }
        ]
        
        for step in steps:
            self.saga_orchestrator.add_saga_step(saga_id, step)
        
        # 启动SAGA
        initial_event = Event(
            event_id=f"{saga_id}_start",
            event_type=EventType.ORDER_CREATED,
            timestamp=time.time(),
            data={'order_id': order_id},
            source="saga_orchestrator",
            correlation_id=saga_id
        )
        
        await self.saga_orchestrator.start_saga(saga_id, initial_event)
    
    def get_system_status(self) -> Dict:
        """获取系统状态"""
        service_stats = self.service_registry.get_service_stats()
        event_history = self.event_bus.get_event_history()
        sagas = self.saga_orchestrator.get_all_sagas()
        
        return {
            'services': service_stats,
            'recent_events': len(event_history),
            'active_sagas': len([s for s in sagas.values() if s['status'] == 'running']),
            'completed_sagas': len([s for s in sagas.values() if s['status'] == 'completed']),
            'failed_sagas': len([s for s in sagas.values() if s['status'] == 'failed'])
        }

# 使用示例
async def demo_architecture_principles():
    """架构原则演示"""
    print("=== 系统架构设计原则与实践演示 ===")
    
    # 1. SOLID原则演示
    print("\n1. SOLID原则演示")
    
    # 创建组件
    user_repo = UserRepository()
    user_service = UserService(user_repo)
    
    # 注册通知渠道
    notification_service = NotificationService()
    notification_service.register_channel("email", EmailNotificationChannel())
    notification_service.register_channel("sms", SMSNotificationChannel())
    
    # 使用不同存储方式
    memory_storage = MemoryDataStorage()
    cache_service = CacheService(memory_storage)
    
    # 测试缓存服务
    cache_service.set("user:123", {"name": "Alice", "email": "alice@example.com"})
    user_data = cache_service.get("user:123")
    print(f"缓存数据: {user_data}")
    
    stats = cache_service.get_stats()
    print(f"缓存统计: {stats}")
    
    # 2. 分层架构演示
    print("\n2. 分层架构演示")
    
    layered_arch = LayeredArchitecture()
    
    # 添加验证器
    def validate_user_data(data):
        return isinstance(data, dict) and 'name' in data and 'email' in data
    
    layered_arch.add_presentation_validator(validate_user_data)
    
    # 添加业务规则
    def add_timestamps(data):
        data['created_at'] = time.time()
        return data
    
    layered_arch.add_business_rule(add_timestamps)
    
    # 注册仓储
    layered_arch.register_repository("users", user_repo)
    
    # 处理请求
    request_data = {
        'data': {
            'name': 'John Doe',
            'email': 'john@example.com'
        }
    }
    
    result = layered_arch.handle_request(request_data)
    print(f"分层架构处理结果: {result}")
    
    # 3. 事件驱动架构演示
    print("\n3. 事件驱动架构演示")
    
    event_bus = EventBus()
    event_store = EventStore("demo_events.json")
    
    # 创建并发布事件
    user_registered_event = Event(
        event_id="user_reg_001",
        event_type=EventType.USER_REGISTERED,
        timestamp=time.time(),
        data={
            'user_id': 'user_123',
            'name': 'Alice',
            'email': 'alice@example.com'
        },
        source="user_service"
    )
    
    await event_bus.publish(user_registered_event)
    
    # 显示事件历史
    event_history = event_bus.get_event_history()
    print(f"事件历史: {len(event_history)} 个事件")
    
    # 4. 微服务架构演示
    print("\n4. 微服务架构演示")
    
    service_registry = ServiceRegistry()
    
    # 注册用户服务
    user_service_config = ServiceConfig(
        name="user-service",
        version="1.0.0",
        port=8001,
        health_check_url="health",
        dependencies=[]
    )
    
    await service_registry.register_service(user_service_config)
    
    # 执行健康检查
    await service_registry.health_check()
    
    # 获取服务统计
    service_stats = service_registry.get_service_stats()
    print(f"服务统计: {service_stats}")
    
    # 5. 电商系统架构演示
    print("\n5. 电商系统架构演示")
    
    ecommerce = EcommerceArchitecture()
    
    # 创建订单
    order_data = {
        'customer_id': 'customer_123',
        'items': [
            {'product_id': 'prod_001', 'quantity': 2, 'price': 29.99},
            {'product_id': 'prod_002', 'quantity': 1, 'price': 49.99}
        ],
        'total_amount': 109.97,
        'customer_email': 'customer@example.com'
    }
    
    order_result = await ecommerce.create_order(order_data)
    print(f"订单创建结果: {order_result}")
    
    # 获取系统状态
    system_status = ecommerce.get_system_status()
    print(f"系统状态: {system_status}")
    
    print("\n=== 架构设计演示完成 ===")

if __name__ == "__main__":
    asyncio.run(demo_architecture_principles())
```

## 总结

系统架构设计是一个复杂的工程实践，需要综合考虑多个因素：

### 设计原则应用

1. **SOLID原则**
   - 单一职责原则确保组件功能专一
   - 开闭原则使系统易于扩展
   - 依赖倒置原则提高代码的可测试性和可维护性

2. **架构模式选择**
   - 分层架构适用于单体应用
   - 微服务架构适用于大规模分布式系统
   - 事件驱动架构适用于需要高可扩展性的系统

### 架构实践要点

1. **服务治理**
   - 服务注册与发现
   - 负载均衡策略
   - 健康检查机制

2. **数据管理**
   - 事件溯源模式
   - CQRS模式
   - 分布式事务处理

3. **系统监控**
   - 链路追踪
   - 性能指标
   - 错误监控

4. **安全考虑**
   - 认证授权
   - 数据加密
   - 访问控制

在实际项目中，需要根据业务需求、技术栈、团队能力等因素，选择合适的架构模式和设计原则，并逐步演进和优化系统架构。