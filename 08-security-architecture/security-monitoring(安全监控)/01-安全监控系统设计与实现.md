# å®‰å…¨ç›‘æ§ç³»ç»Ÿè®¾è®¡ä¸å®ç°

## ç›®å½•
1. [å®‰å…¨ç›‘æ§æ¦‚è¿°](#å®‰å…¨ç›‘æ§æ¦‚è¿°)
2. [äº‹ä»¶æ”¶é›†ä¸å¤„ç†](#äº‹ä»¶æ”¶é›†ä¸å¤„ç†)
3. [å¼‚å¸¸æ£€æµ‹ä¸åˆ†æ](#å¼‚å¸¸æ£€æµ‹ä¸åˆ†æ)
4. [å‘Šè­¦ç³»ç»Ÿ](#å‘Šè­¦ç³»ç»Ÿ)
5. [æ—¥å¿—ç®¡ç†ä¸åˆ†æ](#æ—¥å¿—ç®¡ç†ä¸åˆ†æ)
6. [å¨èƒæƒ…æŠ¥](#å¨èƒæƒ…æŠ¥)
7. [å®‰å…¨ä»ªè¡¨æ¿](#å®‰å…¨ä»ªè¡¨æ¿)
8. [å“åº”è‡ªåŠ¨åŒ–](#å“åº”è‡ªåŠ¨åŒ–)

## å®‰å…¨ç›‘æ§æ¦‚è¿°

å®‰å…¨ç›‘æ§æ˜¯ä¿æŠ¤ç³»ç»Ÿå®‰å…¨çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œé€šè¿‡å®æ—¶ç›‘æ§ã€æ£€æµ‹ã€åˆ†æå’Œå“åº”å®‰å…¨äº‹ä»¶ï¼Œç¡®ä¿ç³»ç»Ÿçš„æœºå¯†æ€§ã€å®Œæ•´æ€§å’Œå¯ç”¨æ€§ã€‚

### ç›‘æ§ç›®æ ‡
- **å®æ—¶å¨èƒæ£€æµ‹**: åŠæ—¶å‘ç°æ½œåœ¨çš„å®‰å…¨å¨èƒ
- **äº‹ä»¶å…³è”åˆ†æ**: å°†åˆ†æ•£çš„å®‰å…¨äº‹ä»¶å…³è”æˆå®Œæ•´çš„æ”»å‡»é“¾
- **å¿«é€Ÿå“åº”**: è‡ªåŠ¨æˆ–åŠè‡ªåŠ¨å“åº”å®‰å…¨äº‹ä»¶
- **åˆè§„æŠ¥å‘Š**: ç”Ÿæˆæ»¡è¶³åˆè§„è¦æ±‚çš„å®‰å…¨æŠ¥å‘Š
- **æŒç»­æ”¹è¿›**: åŸºäºç›‘æ§æ•°æ®æ”¹è¿›å®‰å…¨ç­–ç•¥

### ç›‘æ§å±‚çº§
- **ç½‘ç»œå±‚**: ç›‘æ§ç½‘ç»œæµé‡ã€å…¥ä¾µæ£€æµ‹
- **ä¸»æœºå±‚**: ç›‘æ§ç³»ç»Ÿæ—¥å¿—ã€è¿›ç¨‹è¡Œä¸º
- **åº”ç”¨å±‚**: ç›‘æ§åº”ç”¨ç¨‹åºè¡Œä¸ºã€APIè°ƒç”¨
- **æ•°æ®å±‚**: ç›‘æ§æ•°æ®è®¿é—®ã€æ•æ„Ÿæ“ä½œ
- **ç”¨æˆ·å±‚**: ç›‘æ§ç”¨æˆ·è¡Œä¸ºã€æƒé™å¼‚å¸¸

## äº‹ä»¶æ”¶é›†ä¸å¤„ç†

```python
import json
import time
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, asdict
from collections import defaultdict, deque
import queue
from enum import Enum
import re

class EventSeverity(Enum):
    """äº‹ä»¶ä¸¥é‡çº§åˆ«"""
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

class EventType(Enum):
    """äº‹ä»¶ç±»å‹"""
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    NETWORK = "network"
    SYSTEM = "system"
    APPLICATION = "application"
    DATA_ACCESS = "data_access"
    MALWARE = "malware"
    INTRUSION = "intrusion"

@dataclass
class SecurityEvent:
    """å®‰å…¨äº‹ä»¶æ•°æ®ç»“æ„"""
    event_id: str
    timestamp: datetime
    event_type: EventType
    severity: EventSeverity
    source: str  # äº‹ä»¶æ¥æº
    target: str  # ç›®æ ‡
    description: str
    details: Dict[str, Any]
    tags: List[str]
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'event_id': self.event_id,
            'timestamp': self.timestamp.isoformat(),
            'event_type': self.event_type.value,
            'severity': self.severity.value,
            'source': self.source,
            'target': self.target,
            'description': self.description,
            'details': self.details,
            'tags': self.tags
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'SecurityEvent':
        return cls(
            event_id=data['event_id'],
            timestamp=datetime.fromisoformat(data['timestamp']),
            event_type=EventType(data['event_type']),
            severity=EventSeverity(data['severity']),
            source=data['source'],
            target=data['target'],
            description=data['description'],
            details=data['details'],
            tags=data['tags']
        )

class EventCollector:
    """äº‹ä»¶æ”¶é›†å™¨"""
    
    def __init__(self, buffer_size: int = 10000):
        self.event_buffer = deque(maxlen=buffer_size)
        self.event_handlers: List[Callable] = []
        self.is_running = False
        self.collector_thread = None
    
    def register_handler(self, handler: Callable[[SecurityEvent], None]):
        """æ³¨å†Œäº‹ä»¶å¤„ç†å™¨"""
        self.event_handlers.append(handler)
    
    def collect_event(self, event: SecurityEvent):
        """æ”¶é›†äº‹ä»¶"""
        self.event_buffer.append(event)
        
        # è°ƒç”¨æ‰€æœ‰æ³¨å†Œçš„å¤„ç†å™¨
        for handler in self.event_handlers:
            try:
                handler(event)
            except Exception as e:
                print(f"Event handler error: {e}")
    
    def start_collection(self):
        """å¼€å§‹äº‹ä»¶æ”¶é›†"""
        self.is_running = True
        self.collector_thread = threading.Thread(target=self._collection_loop)
        self.collector_thread.start()
    
    def stop_collection(self):
        """åœæ­¢äº‹ä»¶æ”¶é›†"""
        self.is_running = False
        if self.collector_thread:
            self.collector_thread.join()
    
    def _collection_loop(self):
        """äº‹ä»¶æ”¶é›†å¾ªç¯"""
        while self.is_running:
            # å¤„ç†ç¼“å†²é˜Ÿåˆ—ä¸­çš„äº‹ä»¶
            # è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„äº‹ä»¶æ”¶é›†é€»è¾‘
            time.sleep(1)
    
    def get_events(self, hours: int = 1) -> List[SecurityEvent]:
        """è·å–æœ€è¿‘Nå°æ—¶çš„äº‹ä»¶"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        return [event for event in self.event_buffer 
                if event.timestamp >= cutoff_time]
    
    def get_events_by_type(self, event_type: EventType) -> List[SecurityEvent]:
        """è·å–æŒ‡å®šç±»å‹çš„äº‹ä»¶"""
        return [event for event in self.event_buffer 
                if event.event_type == event_type]
    
    def get_events_by_severity(self, severity: EventSeverity) -> List[SecurityEvent]:
        """è·å–æŒ‡å®šä¸¥é‡çº§åˆ«çš„äº‹ä»¶"""
        return [event for event in self.event_buffer 
                if event.severity == severity]

class NetworkEventCollector(EventCollector):
    """ç½‘ç»œäº‹ä»¶æ”¶é›†å™¨"""
    
    def __init__(self, interface: str = "eth0", port: int = 22):
        super().__init__()
        self.interface = interface
        self.port = port
        self.suspicious_patterns = [
            r'failed login from (\d+\.\d+\.\d+\.\d+)',
            r'unusual traffic from (\d+\.\d+\.\d+\.\d+)',
            r'port scan detected from (\d+\.\d+\.\d+\.\d+)'
        ]
    
    def start_network_monitoring(self):
        """å¼€å§‹ç½‘ç»œç›‘æ§"""
        self.start_collection()
        self.collector_thread = threading.Thread(target=self._monitor_network)
        self.collector_thread.start()
    
    def _monitor_network(self):
        """ç›‘æ§ç½‘ç»œæµé‡"""
        # æ¨¡æ‹Ÿç½‘ç»œäº‹ä»¶ç›‘æ§
        while self.is_running:
            # æ¨¡æ‹Ÿæ£€æµ‹åˆ°å¯ç–‘æ´»åŠ¨
            if time.time() % 10 < 1:  # æ¯10ç§’æœ‰10%æ¦‚ç‡æ£€æµ‹åˆ°äº‹ä»¶
                event = SecurityEvent(
                    event_id=f"network_{int(time.time())}",
                    timestamp=datetime.now(),
                    event_type=EventType.NETWORK,
                    severity=EventSeverity.WARNING,
                    source="192.168.1.100",
                    target="192.168.1.1",
                    description="Suspicious network activity detected",
                    details={
                        'connection_count': 150,
                        'bandwidth_usage': '500MB',
                        'protocol': 'TCP'
                    },
                    tags=['network', 'suspicious', 'monitoring']
                )
                self.collect_event(event)
            
            time.sleep(1)

class SystemEventCollector(EventCollector):
    """ç³»ç»Ÿäº‹ä»¶æ”¶é›†å™¨"""
    
    def __init__(self):
        super().__init__()
        self.suspicious_processes = ['nc', 'netcat', 'tcpdump', 'wireshark']
        self.failed_login_threshold = 5
    
    def start_system_monitoring(self):
        """å¼€å§‹ç³»ç»Ÿç›‘æ§"""
        self.start_collection()
        self.collector_thread = threading.Thread(target=self._monitor_system)
        self.collector_thread.start()
    
    def _monitor_system(self):
        """ç›‘æ§ç³»ç»Ÿæ´»åŠ¨"""
        while self.is_running:
            # æ¨¡æ‹Ÿç³»ç»Ÿäº‹ä»¶ç›‘æ§
            if time.time() % 15 < 1:  # æ¯15ç§’æœ‰10%æ¦‚ç‡æ£€æµ‹åˆ°äº‹ä»¶
                event = SecurityEvent(
                    event_id=f"system_{int(time.time())}",
                    timestamp=datetime.now(),
                    event_type=EventType.SYSTEM,
                    severity=EventSeverity.INFO,
                    source="localhost",
                    target="system",
                    description="System process executed",
                    details={
                        'process_name': 'python',
                        'pid': 1234,
                        'user': 'admin',
                        'command_line': 'python3 -c "import socket"'
                    },
                    tags=['system', 'process', 'execution']
                )
                self.collect_event(event)
            
            time.sleep(1)

class ApplicationEventCollector(EventCollector):
    """åº”ç”¨äº‹ä»¶æ”¶é›†å™¨"""
    
    def __init__(self, app_name: str = "web_app"):
        super().__init__()
        self.app_name = app_name
        self.suspicious_queries = [
            r'union\s+select',
            r'drop\s+table',
            r'delete\s+from',
            r'insert\s+into\s+',
            r'xp_cmdshell'
        ]
    
    def start_application_monitoring(self):
        """å¼€å§‹åº”ç”¨ç›‘æ§"""
        self.start_collection()
        self.collector_thread = threading.Thread(target=self._monitor_application)
        self.collector_thread.start()
    
    def _monitor_application(self):
        """ç›‘æ§åº”ç”¨æ´»åŠ¨"""
        while self.is_running:
            # æ¨¡æ‹Ÿåº”ç”¨äº‹ä»¶ç›‘æ§
            if time.time() % 20 < 1:  # æ¯20ç§’æœ‰10%æ¦‚ç‡æ£€æµ‹åˆ°äº‹ä»¶
                event = SecurityEvent(
                    event_id=f"app_{int(time.time())}",
                    timestamp=datetime.now(),
                    event_type=EventType.APPLICATION,
                    severity=EventSeverity.WARNING,
                    source="user123",
                    target=self.app_name,
                    description="Application anomaly detected",
                    details={
                        'request_count': 1000,
                        'error_rate': 0.05,
                        'avg_response_time': 200,
                        'endpoint': '/api/users'
                    },
                    tags=['application', 'anomaly', 'performance']
                )
                self.collect_event(event)
            
            time.sleep(1)
```

## å¼‚å¸¸æ£€æµ‹ä¸åˆ†æ

```python
import statistics
import numpy as np
from typing import Tuple
from sklearn.ensemble import IsolationForest
from sklearn.preprocessing import StandardScaler

class AnomalyDetector:
    """å¼‚å¸¸æ£€æµ‹å™¨"""
    
    def __init__(self, contamination: float = 0.1):
        self.models = {}
        self.scalers = {}
        self.baselines = {}
        self.contamination = contamination
    
    def create_baseline(self, metric_name: str, data: List[float], 
                       window_size: int = 100):
        """åˆ›å»ºåŸºçº¿"""
        if len(data) < window_size:
            return
        
        # è®¡ç®—ç»Ÿè®¡åŸºçº¿
        self.baselines[metric_name] = {
            'mean': statistics.mean(data[-window_size:]),
            'std': statistics.stdev(data[-window_size:]),
            'median': statistics.median(data[-window_size:]),
            'q1': np.percentile(data[-window_size:], 25),
            'q3': np.percentile(data[-window_size:], 75),
            'min': min(data[-window_size:]),
            'max': max(data[-window_size:])
        }
    
    def detect_statistical_anomaly(self, metric_name: str, value: float) -> Tuple[bool, float]:
        """åŸºäºç»Ÿè®¡çš„å¼‚å¸¸æ£€æµ‹"""
        if metric_name not in self.baselines:
            return False, 0.0
        
        baseline = self.baselines[metric_name]
        
        # Z-Scoreå¼‚å¸¸æ£€æµ‹
        z_score = abs(value - baseline['mean']) / baseline['std']
        is_anomaly = z_score > 3  # 3-sigmaè§„åˆ™
        
        return is_anomaly, z_score
    
    def detect_iqr_anomaly(self, metric_name: str, value: float) -> Tuple[bool, float]:
        """åŸºäºå››åˆ†ä½è·çš„å¼‚å¸¸æ£€æµ‹"""
        if metric_name not in self.baselines:
            return False, 0.0
        
        baseline = self.baselines[metric_name]
        iqr = baseline['q3'] - baseline['q1']
        
        # IQRå¼‚å¸¸æ£€æµ‹
        lower_bound = baseline['q1'] - 1.5 * iqr
        upper_bound = baseline['q3'] + 1.5 * iqr
        
        is_anomaly = value < lower_bound or value > upper_bound
        
        # å¼‚å¸¸åˆ†æ•°ï¼šè·ç¦»è¾¹ç•Œçš„æ ‡å‡†åŒ–è·ç¦»
        if value < lower_bound:
            anomaly_score = (lower_bound - value) / iqr
        elif value > upper_bound:
            anomaly_score = (value - upper_bound) / iqr
        else:
            anomaly_score = 0.0
        
        return is_anomaly, anomaly_score
    
    def train_isolation_forest(self, metric_name: str, data: List[List[float]]):
        """è®­ç»ƒå­¤ç«‹æ£®æ—æ¨¡å‹"""
        if len(data) < 10:
            return
        
        # æ ‡å‡†åŒ–æ•°æ®
        scaler = StandardScaler()
        scaled_data = scaler.fit_transform(data)
        self.scalers[metric_name] = scaler
        
        # è®­ç»ƒæ¨¡å‹
        model = IsolationForest(
            contamination=self.contamination,
            random_state=42
        )
        model.fit(scaled_data)
        self.models[metric_name] = model
    
    def detect_isolation_forest_anomaly(self, metric_name: str, 
                                       features: List[float]) -> Tuple[bool, float]:
        """ä½¿ç”¨å­¤ç«‹æ£®æ—æ£€æµ‹å¼‚å¸¸"""
        if metric_name not in self.models or metric_name not in self.scalers:
            return False, 0.0
        
        # æ ‡å‡†åŒ–ç‰¹å¾
        scaled_features = self.scalers[metric_name].transform([features])
        
        # é¢„æµ‹å¼‚å¸¸
        prediction = self.models[metric_name].predict(scaled_features)[0]
        anomaly_score = self.models[metric_name].score_samples(scaled_features)[0]
        
        is_anomaly = prediction == -1
        
        return is_anomaly, abs(anomaly_score)

class SecurityAnalyzer:
    """å®‰å…¨åˆ†æå™¨"""
    
    def __init__(self):
        self.anomaly_detector = AnomalyDetector()
        self.behavior_profiles = {}
        self.correlation_rules = []
    
    def create_user_profile(self, user_id: str, login_times: List[datetime],
                           accessed_resources: List[str], 
                           session_durations: List[int]):
        """åˆ›å»ºç”¨æˆ·è¡Œä¸ºæ¡£æ¡ˆ"""
        self.behavior_profiles[user_id] = {
            'typical_login_hours': self._extract_typical_hours(login_times),
            'common_resources': self._extract_common_resources(accessed_resources),
            'avg_session_duration': statistics.mean(session_durations),
            'login_count': len(login_times),
            'last_updated': datetime.now()
        }
    
    def _extract_typical_hours(self, login_times: List[datetime]) -> Dict[int, int]:
        """æå–å…¸å‹ç™»å½•æ—¶é—´"""
        hour_counts = defaultdict(int)
        for login_time in login_times:
            hour_counts[login_time.hour] += 1
        return dict(hour_counts)
    
    def _extract_common_resources(self, resources: List[str]) -> Dict[str, int]:
        """æå–å¸¸ç”¨èµ„æº"""
        resource_counts = defaultdict(int)
        for resource in resources:
            resource_counts[resource] += 1
        return dict(resource_counts)
    
    def detect_anomalous_login(self, user_id: str, login_time: datetime) -> Tuple[bool, float]:
        """æ£€æµ‹å¼‚å¸¸ç™»å½•è¡Œä¸º"""
        if user_id not in self.behavior_profiles:
            return False, 0.0
        
        profile = self.behavior_profiles[user_id]
        typical_hours = profile['typical_login_hours']
        
        login_hour = login_time.hour
        hour_frequency = typical_hours.get(login_hour, 0)
        
        # å¼‚å¸¸è¯„åˆ†ï¼šåŸºäºè¯¥å°æ—¶çš„å†å²é¢‘ç‡
        total_logins = sum(typical_hours.values())
        if total_logins == 0:
            anomaly_score = 1.0
        else:
            expected_frequency = total_logins / 24
            anomaly_score = max(0, (expected_frequency - hour_frequency) / expected_frequency)
        
        # æ—¶é—´å¼‚å¸¸æ£€æµ‹
        is_anomaly = hour_frequency == 0 or anomaly_score > 0.5
        
        return is_anomaly, anomaly_score
    
    def detect_resource_access_anomaly(self, user_id: str, 
                                      resource: str) -> Tuple[bool, float]:
        """æ£€æµ‹èµ„æºè®¿é—®å¼‚å¸¸"""
        if user_id not in self.behavior_profiles:
            return False, 0.0
        
        profile = self.behavior_profiles[user_id]
        common_resources = profile['common_resources']
        
        resource_frequency = common_resources.get(resource, 0)
        total_accesses = sum(common_resources.values())
        
        if total_accesses == 0:
            anomaly_score = 1.0
        else:
            expected_frequency = total_accesses / len(common_resources)
            anomaly_score = max(0, (expected_frequency - resource_frequency) / expected_frequency)
        
        is_anomaly = resource_frequency == 0 or anomaly_score > 0.3
        
        return is_anomaly, anomaly_score
    
    def correlate_events(self, events: List[SecurityEvent]) -> List[Dict[str, Any]]:
        """äº‹ä»¶å…³è”åˆ†æ"""
        correlations = []
        
        # æŒ‰æ—¶é—´çª—å£åˆ†ç»„
        time_window = timedelta(minutes=5)
        grouped_events = self._group_events_by_time(events, time_window)
        
        for time_group in grouped_events.values():
            correlation = self._analyze_correlation(time_group)
            if correlation['confidence'] > 0.7:
                correlations.append(correlation)
        
        return correlations
    
    def _group_events_by_time(self, events: List[SecurityEvent], 
                             window: timedelta) -> Dict[datetime, List[SecurityEvent]]:
        """æŒ‰æ—¶é—´çª—å£åˆ†ç»„äº‹ä»¶"""
        grouped = defaultdict(list)
        
        for event in events:
            window_start = event.timestamp.replace(
                minute=(event.timestamp.minute // 5) * 5,
                second=0,
                microsecond=0
            )
            grouped[window_start].append(event)
        
        return dict(grouped)
    
    def _analyze_correlation(self, events: List[SecurityEvent]) -> Dict[str, Any]:
        """åˆ†æäº‹ä»¶ç›¸å…³æ€§"""
        if len(events) < 2:
            return {'confidence': 0.0, 'events': events, 'pattern': 'single_event'}
        
        # æ”»å‡»æ¨¡å¼æ£€æµ‹
        patterns = {
            'brute_force': self._detect_brute_force_pattern(events),
            'escalation': self._detect_privilege_escalation_pattern(events),
            'data_exfiltration': self._detect_data_exfiltration_pattern(events),
            'lateral_movement': self._detect_lateral_movement_pattern(events)
        }
        
        # é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„æ¨¡å¼
        best_pattern = max(patterns.items(), key=lambda x: x[1]['confidence'])
        
        return {
            'pattern': best_pattern[0],
            'confidence': best_pattern[1]['confidence'],
            'events': events,
            'analysis': best_pattern[1]
        }
    
    def _detect_brute_force_pattern(self, events: List[SecurityEvent]) -> Dict[str, Any]:
        """æ£€æµ‹æš´åŠ›ç ´è§£æ¨¡å¼"""
        auth_events = [e for e in events if e.event_type == EventType.AUTHENTICATION]
        failed_events = [e for e in auth_events if 'failed' in e.description.lower()]
        
        if len(failed_events) >= 5:
            return {
                'confidence': min(len(failed_events) / 10.0, 1.0),
                'failed_attempts': len(failed_events),
                'time_span': max(e.timestamp for e in failed_events) - 
                           min(e.timestamp for e in failed_events)
            }
        
        return {'confidence': 0.0}
    
    def _detect_privilege_escalation_pattern(self, events: List[SecurityEvent]) -> Dict[str, Any]:
        """æ£€æµ‹æƒé™æå‡æ¨¡å¼"""
        auth_events = [e for e in events if e.event_type == EventType.AUTHORIZATION]
        success_events = [e for e in auth_events if 'success' in e.description.lower()]
        
        # æ£€æŸ¥æ˜¯å¦æœ‰æƒé™æå‡çš„è¿¹è±¡
        escalation_indicators = ['admin', 'root', 'sudo', 'administrator']
        escalation_events = [e for e in success_events 
                           if any(indicator in e.description.lower() 
                                for indicator in escalation_indicators)]
        
        if len(escalation_events) >= 1:
            return {
                'confidence': 0.8,
                'escalation_count': len(escalation_events),
                'escalation_events': escalation_events
            }
        
        return {'confidence': 0.0}
    
    def _detect_data_exfiltration_pattern(self, events: List[SecurityEvent]) -> Dict[str, Any]:
        """æ£€æµ‹æ•°æ®æ³„éœ²æ¨¡å¼"""
        data_events = [e for e in events if e.event_type == EventType.DATA_ACCESS]
        
        # æ£€æŸ¥å¤§é‡æ•°æ®ä¼ è¾“
        large_transfers = [e for e in data_events 
                          if e.details.get('bytes_transferred', 0) > 1000000]
        
        if len(large_transfers) >= 3:
            return {
                'confidence': 0.9,
                'large_transfer_count': len(large_transfers),
                'total_bytes': sum(e.details.get('bytes_transferred', 0) 
                                 for e in large_transfers)
            }
        
        return {'confidence': 0.0}
    
    def _detect_lateral_movement_pattern(self, events: List[SecurityEvent]) -> Dict[str, Any]:
        """æ£€æµ‹æ¨ªå‘ç§»åŠ¨æ¨¡å¼"""
        network_events = [e for e in events if e.event_type == EventType.NETWORK]
        
        # æ£€æŸ¥å¯¹å¤šä¸ªä¸åŒä¸»æœºçš„è¿æ¥
        target_hosts = set(e.target for e in network_events)
        
        if len(target_hosts) >= 5:
            return {
                'confidence': 0.7,
                'target_host_count': len(target_hosts),
                'target_hosts': list(target_hosts)
            }
        
        return {'confidence': 0.0}
```

## å‘Šè­¦ç³»ç»Ÿ

```python
from typing import Dict, List, Optional, Callable
from datetime import datetime, timedelta
import smtplib
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
import json
from dataclasses import asdict

class AlertRule:
    """å‘Šè­¦è§„åˆ™"""
    
    def __init__(self, name: str, condition: Callable[[SecurityEvent], bool],
                 severity: EventSeverity, description: str):
        self.name = name
        self.condition = condition
        self.severity = severity
        self.description = description
        self.enabled = True
        self.throttle_minutes = 0  # å‘Šè­¦èŠ‚æµæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
        self.last_alert_time = None
    
    def should_fire(self, event: SecurityEvent) -> bool:
        """åˆ¤æ–­æ˜¯å¦åº”è¯¥è§¦å‘å‘Šè­¦"""
        if not self.enabled:
            return False
        
        if not self.condition(event):
            return False
        
        # æ£€æŸ¥èŠ‚æµ
        if self.throttle_minutes > 0 and self.last_alert_time:
            if datetime.now() - self.last_alert_time < timedelta(minutes=self.throttle_minutes):
                return False
        
        self.last_alert_time = datetime.now()
        return True

class Alert:
    """å‘Šè­¦"""
    
    def __init__(self, rule_name: str, event: SecurityEvent, 
                 message: str, actions: List[Dict[str, Any]]):
        self.alert_id = f"alert_{int(time.time())}_{rule_name}"
        self.rule_name = rule_name
        self.event = event
        self.message = message
        self.actions = actions
        self.timestamp = datetime.now()
        self.status = 'active'  # active, acknowledged, resolved
        self.assigned_to = None
        self.notes = []

class EmailNotifier:
    """é‚®ä»¶é€šçŸ¥å™¨"""
    
    def __init__(self, smtp_server: str, smtp_port: int, 
                 username: str, password: str, from_email: str):
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
        self.username = username
        self.password = password
        self.from_email = from_email
    
    def send_alert(self, alert: Alert, recipients: List[str]):
        """å‘é€å‘Šè­¦é‚®ä»¶"""
        try:
            msg = MimeMultipart()
            msg['From'] = self.from_email
            msg['To'] = ', '.join(recipients)
            msg['Subject'] = f"Security Alert: {alert.rule_name}"
            
            # é‚®ä»¶å†…å®¹
            body = f"""
Security Alert Details:
- Alert ID: {alert.alert_id}
- Rule: {alert.rule_name}
- Severity: {alert.event.severity.value}
- Event Time: {alert.event.timestamp}
- Source: {alert.event.source}
- Target: {alert.event.target}
- Description: {alert.event.description}

Message: {alert.message}

Event Details:
{json.dumps(alert.event.to_dict(), indent=2)}
            """
            
            msg.attach(MimeText(body, 'plain'))
            
            # å‘é€é‚®ä»¶
            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.username, self.password)
            server.send_message(msg)
            server.quit()
            
            print(f"Alert email sent: {alert.alert_id}")
        
        except Exception as e:
            print(f"Failed to send alert email: {e}")

class SlackNotifier:
    """Slacké€šçŸ¥å™¨"""
    
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
    
    def send_alert(self, alert: Alert):
        """å‘é€Slackå‘Šè­¦"""
        try:
            payload = {
                "text": f"ğŸš¨ Security Alert: {alert.rule_name}",
                "attachments": [
                    {
                        "color": self._get_color_by_severity(alert.event.severity),
                        "fields": [
                            {
                                "title": "Severity",
                                "value": alert.event.severity.value,
                                "short": True
                            },
                            {
                                "title": "Source",
                                "value": alert.event.source,
                                "short": True
                            },
                            {
                                "title": "Target",
                                "value": alert.event.target,
                                "short": True
                            },
                            {
                                "title": "Event Time",
                                "value": alert.event.timestamp.isoformat(),
                                "short": True
                            }
                        ],
                        "text": alert.message,
                        "footer": f"Alert ID: {alert.alert_id}"
                    }
                ]
            }
            
            # è¿™é‡Œéœ€è¦å®é™…çš„HTTPè¯·æ±‚åº“æ¥å‘é€Slackæ¶ˆæ¯
            print(f"Slack alert sent: {alert.alert_id}")
        
        except Exception as e:
            print(f"Failed to send Slack alert: {e}")
    
    def _get_color_by_severity(self, severity: EventSeverity) -> str:
        """æ ¹æ®ä¸¥é‡çº§åˆ«è·å–é¢œè‰²"""
        colors = {
            EventSeverity.INFO: "good",
            EventSeverity.WARNING: "warning",
            EventSeverity.ERROR: "danger",
            EventSeverity.CRITICAL: "danger"
        }
        return colors.get(severity, "warning")

class AlertManager:
    """å‘Šè­¦ç®¡ç†å™¨"""
    
    def __init__(self):
        self.rules: Dict[str, AlertRule] = {}
        self.active_alerts: Dict[str, Alert] = {}
        self.alert_history: List[Alert] = []
        self.notifiers: List[object] = []
        
        # æ·»åŠ é»˜è®¤è§„åˆ™
        self._add_default_rules()
    
    def _add_default_rules(self):
        """æ·»åŠ é»˜è®¤å‘Šè­¦è§„åˆ™"""
        # å¤šæ¬¡ç™»å½•å¤±è´¥
        self.add_rule(AlertRule(
            name="multiple_failed_logins",
            condition=lambda e: e.event_type == EventType.AUTHENTICATION 
                               and 'failed' in e.description.lower(),
            severity=EventSeverity.WARNING,
            description="Multiple failed login attempts"
        ))
        
        # å¯ç–‘ç½‘ç»œæ´»åŠ¨
        self.add_rule(AlertRule(
            name="suspicious_network_activity",
            condition=lambda e: e.event_type == EventType.NETWORK
                               and e.severity in [EventSeverity.ERROR, EventSeverity.CRITICAL],
            severity=EventSeverity.ERROR,
            description="Suspicious network activity detected"
        ))
        
        # ç³»ç»Ÿå…¥ä¾µ
        self.add_rule(AlertRule(
            name="system_intrusion",
            condition=lambda e: e.event_type == EventType.INTRUSION,
            severity=EventSeverity.CRITICAL,
            description="Possible system intrusion detected"
        ))
    
    def add_rule(self, rule: AlertRule):
        """æ·»åŠ å‘Šè­¦è§„åˆ™"""
        self.rules[rule.name] = rule
    
    def add_notifier(self, notifier):
        """æ·»åŠ é€šçŸ¥å™¨"""
        self.notifiers.append(notifier)
    
    def process_event(self, event: SecurityEvent):
        """å¤„ç†å®‰å…¨äº‹ä»¶"""
        triggered_rules = []
        
        for rule in self.rules.values():
            if rule.should_fire(event):
                triggered_rules.append(rule)
        
        # ç”Ÿæˆå‘Šè­¦
        for rule in triggered_rules:
            alert = self._create_alert(rule, event)
            self.active_alerts[alert.alert_id] = alert
            self.alert_history.append(alert)
            
            # å‘é€é€šçŸ¥
            self._send_notifications(alert)
    
    def _create_alert(self, rule: AlertRule, event: SecurityEvent) -> Alert:
        """åˆ›å»ºå‘Šè­¦"""
        message = f"Alert triggered: {rule.description}"
        
        actions = [
            {
                'type': 'email',
                'recipients': ['security@company.com'],
                'subject': f"Security Alert: {rule.name}"
            },
            {
                'type': 'log',
                'level': event.severity.value
            }
        ]
        
        return Alert(
            rule_name=rule.name,
            event=event,
            message=message,
            actions=actions
        )
    
    def _send_notifications(self, alert: Alert):
        """å‘é€é€šçŸ¥"""
        for action in alert.actions:
            if action['type'] == 'email' and isinstance(action.get('recipients'), list):
                for notifier in self.notifiers:
                    if hasattr(notifier, 'send_alert'):
                        notifier.send_alert(alert, action['recipients'])
            elif action['type'] == 'slack':
                for notifier in self.notifiers:
                    if hasattr(notifier, 'send_alert'):
                        notifier.send_alert(alert)
            elif action['type'] == 'log':
                print(f"[{alert.timestamp}] {alert.rule_name}: {alert.message}")
    
    def acknowledge_alert(self, alert_id: str, user: str, notes: str = ""):
        """ç¡®è®¤å‘Šè­¦"""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].status = 'acknowledged'
            self.active_alerts[alert_id].assigned_to = user
            if notes:
                self.active_alerts[alert_id].notes.append({
                    'timestamp': datetime.now(),
                    'user': user,
                    'notes': notes
                })
    
    def resolve_alert(self, alert_id: str, user: str, notes: str = ""):
        """è§£å†³å‘Šè­¦"""
        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].status = 'resolved'
            if notes:
                self.active_alerts[alert_id].notes.append({
                    'timestamp': datetime.now(),
                    'user': user,
                    'notes': notes
                })
            
            # ä»æ´»è·ƒå‘Šè­¦ä¸­ç§»é™¤
            del self.active_alerts[alert_id]
    
    def get_active_alerts(self) -> List[Alert]:
        """è·å–æ´»è·ƒå‘Šè­¦"""
        return list(self.active_alerts.values())
    
    def get_alert_statistics(self) -> Dict[str, int]:
        """è·å–å‘Šè­¦ç»Ÿè®¡"""
        stats = {
            'active': len(self.active_alerts),
            'acknowledged': 0,
            'resolved': 0,
            'total': len(self.alert_history)
        }
        
        for alert in self.active_alerts.values():
            if alert.status == 'acknowledged':
                stats['acknowledged'] += 1
        
        for alert in self.alert_history:
            if alert.status == 'resolved':
                stats['resolved'] += 1
        
        return stats
```

## æ—¥å¿—ç®¡ç†ä¸åˆ†æ

```python
import os
import gzip
from typing import Dict, List, Any
from datetime import datetime
import sqlite3
from contextlib import contextmanager

class LogManager:
    """æ—¥å¿—ç®¡ç†å™¨"""
    
    def __init__(self, log_dir: str = "security_logs"):
        self.log_dir = log_dir
        self.db_path = os.path.join(log_dir, "security_logs.db")
        
        # ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
        os.makedirs(log_dir, exist_ok=True)
        
        # åˆå§‹åŒ–æ•°æ®åº“
        self._init_database()
    
    def _init_database(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        with self.get_db_connection() as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS security_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    event_id TEXT UNIQUE,
                    timestamp TEXT,
                    event_type TEXT,
                    severity TEXT,
                    source TEXT,
                    target TEXT,
                    description TEXT,
                    details TEXT,
                    tags TEXT,
                    created_at TEXT
                )
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_timestamp ON security_logs(timestamp)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_event_type ON security_logs(event_type)
            """)
            
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_severity ON security_logs(severity)
            """)
    
    @contextmanager
    def get_db_connection(self):
        """è·å–æ•°æ®åº“è¿æ¥"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()
    
    def store_event(self, event: SecurityEvent):
        """å­˜å‚¨å®‰å…¨äº‹ä»¶"""
        with self.get_db_connection() as conn:
            conn.execute("""
                INSERT OR REPLACE INTO security_logs 
                (event_id, timestamp, event_type, severity, source, target, 
                 description, details, tags, created_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                event.event_id,
                event.timestamp.isoformat(),
                event.event_type.value,
                event.severity.value,
                event.source,
                event.target,
                event.description,
                json.dumps(event.details),
                json.dumps(event.tags),
                datetime.now().isoformat()
            ))
            conn.commit()
    
    def search_logs(self, start_time: datetime = None, end_time: datetime = None,
                   event_type: EventType = None, severity: EventSeverity = None,
                   source: str = None, limit: int = 1000) -> List[Dict[str, Any]]:
        """æœç´¢æ—¥å¿—"""
        query = "SELECT * FROM security_logs WHERE 1=1"
        params = []
        
        if start_time:
            query += " AND timestamp >= ?"
            params.append(start_time.isoformat())
        
        if end_time:
            query += " AND timestamp <= ?"
            params.append(end_time.isoformat())
        
        if event_type:
            query += " AND event_type = ?"
            params.append(event_type.value)
        
        if severity:
            query += " AND severity = ?"
            params.append(severity.value)
        
        if source:
            query += " AND source = ?"
            params.append(source)
        
        query += " ORDER BY timestamp DESC LIMIT ?"
        params.append(limit)
        
        with self.get_db_connection() as conn:
            cursor = conn.execute(query, params)
            rows = cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    def export_logs(self, output_file: str, format: str = 'json',
                   start_time: datetime = None, end_time: datetime = None):
        """å¯¼å‡ºæ—¥å¿—"""
        logs = self.search_logs(start_time=start_time, end_time=end_time, limit=1000000)
        
        if format == 'json':
            with open(output_file, 'w') as f:
                json.dump(logs, f, indent=2, default=str)
        
        elif format == 'csv':
            import csv
            
            with open(output_file, 'w', newline='') as f:
                if logs:
                    fieldnames = logs[0].keys()
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    writer.writerows(logs)
    
    def rotate_logs(self, max_size_mb: int = 100, max_files: int = 10):
        """æ—¥å¿—è½®è½¬"""
        # è¿™é‡Œå®ç°ç®€å•çš„æ—¥å¿—æ–‡ä»¶è½®è½¬
        # å®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦æ›´å¤æ‚çš„ç­–ç•¥
        pass
    
    def cleanup_old_logs(self, retention_days: int = 90):
        """æ¸…ç†æ—§æ—¥å¿—"""
        cutoff_date = datetime.now() - timedelta(days=retention_days)
        
        with self.get_db_connection() as conn:
            conn.execute("""
                DELETE FROM security_logs 
                WHERE timestamp < ?
            """, (cutoff_date.isoformat(),))
            
            deleted_count = conn.total_changes
            conn.commit()
        
        print(f"Cleaned up {deleted_count} old log entries")

class LogAnalyzer:
    """æ—¥å¿—åˆ†æå™¨"""
    
    def __init__(self, log_manager: LogManager):
        self.log_manager = log_manager
    
    def analyze_trends(self, days: int = 7) -> Dict[str, Any]:
        """åˆ†ææ—¥å¿—è¶‹åŠ¿"""
        end_time = datetime.now()
        start_time = end_time - timedelta(days=days)
        
        logs = self.log_manager.search_logs(start_time=start_time, end_time=end_time)
        
        # æŒ‰äº‹ä»¶ç±»å‹ç»Ÿè®¡
        event_type_counts = {}
        severity_counts = {}
        hourly_distribution = {}
        
        for log in logs:
            event_type = log['event_type']
            severity = log['severity']
            timestamp = datetime.fromisoformat(log['timestamp'])
            hour = timestamp.hour
            
            event_type_counts[event_type] = event_type_counts.get(event_type, 0) + 1
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            hourly_distribution[hour] = hourly_distribution.get(hour, 0) + 1
        
        return {
            'total_events': len(logs),
            'event_type_distribution': event_type_counts,
            'severity_distribution': severity_counts,
            'hourly_distribution': hourly_distribution,
            'analysis_period_days': days
        }
    
    def detect_patterns(self, days: int = 1) -> List[Dict[str, Any]]:
        """æ£€æµ‹æ¨¡å¼"""
        end_time = datetime.now()
        start_time = end_time - timedelta(days=days)
        
        logs = self.log_manager.search_logs(start_time=start_time, end_time=end_time)
        patterns = []
        
        # æ£€æµ‹é‡å¤äº‹ä»¶æ¨¡å¼
        event_frequency = {}
        for log in logs:
            key = f"{log['event_type']}_{log['source']}_{log['description']}"
            event_frequency[key] = event_frequency.get(key, 0) + 1
        
        # æ‰¾å‡ºé«˜é¢‘äº‹ä»¶
        for event_key, count in event_frequency.items():
            if count > 5:  # é˜ˆå€¼å¯é…ç½®
                patterns.append({
                    'type': 'high_frequency',
                    'description': f'Event "{event_key}" occurred {count} times',
                    'count': count,
                    'frequency': count / len(logs) if logs else 0
                })
        
        # æ£€æµ‹æ—¶é—´æ¨¡å¼
        if logs:
            timestamps = [datetime.fromisoformat(log['timestamp']) for log in logs]
            time_diffs = [(timestamps[i] - timestamps[i-1]).total_seconds() 
                         for i in range(1, len(timestamps))]
            
            if time_diffs:
                avg_interval = sum(time_diffs) / len(time_diffs)
                patterns.append({
                    'type': 'time_pattern',
                    'description': f'Average time interval between events: {avg_interval:.2f} seconds',
                    'avg_interval': avg_interval
                })
        
        return patterns
    
    def generate_report(self, days: int = 7) -> str:
        """ç”Ÿæˆå®‰å…¨æŠ¥å‘Š"""
        trends = self.analyze_trends(days)
        patterns = self.detect_patterns(days)
        
        report = f"""
# Security Log Analysis Report
Generated on: {datetime.now().isoformat()}
Analysis Period: {days} days

## Summary
- Total Events: {trends['total_events']}
- Unique Event Types: {len(trends['event_type_distribution'])}
- Severity Levels: {len(trends['severity_distribution'])}

## Event Type Distribution
"""
        
        for event_type, count in trends['event_type_distribution'].items():
            percentage = (count / trends['total_events'] * 100) if trends['total_events'] else 0
            report += f"- {event_type}: {count} ({percentage:.1f}%)\n"
        
        report += "\n## Severity Distribution\n"
        for severity, count in trends['severity_distribution'].items():
            percentage = (count / trends['total_events'] * 100) if trends['total_events'] else 0
            report += f"- {severity}: {count} ({percentage:.1f}%)\n"
        
        if patterns:
            report += "\n## Detected Patterns\n"
            for pattern in patterns:
                report += f"- {pattern['description']}\n"
        
        report += "\n## Recommendations\n"
        
        # åŸºäºåˆ†æç»“æœç”Ÿæˆå»ºè®®
        critical_count = trends['severity_distribution'].get('critical', 0)
        if critical_count > 0:
            report += f"- HIGH PRIORITY: {critical_count} critical events detected. Immediate investigation required.\n"
        
        network_events = trends['event_type_distribution'].get('network', 0)
        if network_events > trends['total_events'] * 0.3:
            report += "- Consider reviewing network security configurations due to high network event volume.\n"
        
        return report
```

## å¨èƒæƒ…æŠ¥

```python
class ThreatIntelligence:
    """å¨èƒæƒ…æŠ¥ç®¡ç†"""
    
    def __init__(self, data_file: str = "threat_intel.json"):
        self.data_file = data_file
        self.threat_feeds = {}
        self.indicators = {
            'ips': set(),
            'domains': set(),
            'hashes': set(),
            'urls': set()
        }
        self.threat_metadata = {}
        self._load_threat_intelligence()
    
    def _load_threat_intelligence(self):
        """åŠ è½½å¨èƒæƒ…æŠ¥æ•°æ®"""
        try:
            if os.path.exists(self.data_file):
                with open(self.data_file, 'r') as f:
                    data = json.load(f)
                
                self.indicators['ips'] = set(data.get('ips', []))
                self.indicators['domains'] = set(data.get('domains', []))
                self.indicators['hashes'] = set(data.get('hashes', []))
                self.indicators['urls'] = set(data.get('urls', []))
                self.threat_metadata = data.get('metadata', {})
        
        except Exception as e:
            print(f"Error loading threat intelligence: {e}")
            self._initialize_default_data()
    
    def _initialize_default_data(self):
        """åˆå§‹åŒ–é»˜è®¤å¨èƒæƒ…æŠ¥æ•°æ®"""
        self.indicators = {
            'ips': {'192.168.1.100', '10.0.0.50'},
            'domains': {'malicious-domain.com', 'phishing-site.net'},
            'hashes': {'d41d8cd98f00b204e9800998ecf8427e', '0cc175b9c0f1b6a831c399e269772661'},
            'urls': {'http://malicious-site.com/malware.exe', 'https://phishing-site.net/login'}
        }
        
        self.threat_metadata = {
            'sources': ['internal', 'feed1', 'feed2'],
            'last_updated': datetime.now().isoformat()
        }
    
    def add_threat_indicator(self, indicator_type: str, value: str, 
                           metadata: Dict[str, Any] = None):
        """æ·»åŠ å¨èƒæŒ‡æ ‡"""
        if indicator_type in self.indicators:
            self.indicators[indicator_type].add(value)
            
            if metadata:
                self.threat_metadata[value] = metadata
        else:
            raise ValueError(f"Unknown indicator type: {indicator_type}")
    
    def remove_threat_indicator(self, indicator_type: str, value: str):
        """ç§»é™¤å¨èƒæŒ‡æ ‡"""
        if indicator_type in self.indicators:
            self.indicators[indicator_type].discard(value)
            self.threat_metadata.pop(value, None)
    
    def check_indicator(self, indicator_type: str, value: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¨èƒæŒ‡æ ‡"""
        return value in self.indicators.get(indicator_type, set())
    
    def analyze_ip_reputation(self, ip: str) -> Dict[str, Any]:
        """åˆ†æIPä¿¡èª‰"""
        is_malicious = self.check_indicator('ips', ip)
        metadata = self.threat_metadata.get(ip, {})
        
        return {
            'ip': ip,
            'is_malicious': is_malicious,
            'reputation_score': 0.1 if is_malicious else 0.9,
            'threat_types': metadata.get('threat_types', []),
            'first_seen': metadata.get('first_seen'),
            'last_seen': metadata.get('last_seen'),
            'sources': metadata.get('sources', [])
        }
    
    def analyze_domain_reputation(self, domain: str) -> Dict[str, Any]:
        """åˆ†æåŸŸåä¿¡èª‰"""
        is_malicious = self.check_indicator('domains', domain)
        metadata = self.threat_metadata.get(domain, {})
        
        return {
            'domain': domain,
            'is_malicious': is_malicious,
            'reputation_score': 0.1 if is_malicious else 0.9,
            'threat_types': metadata.get('threat_types', []),
            'registration_date': metadata.get('registration_date'),
            'suspicious_tld': domain.endswith(('.tk', '.ml', '.ga', '.cf')),
            'sources': metadata.get('sources', [])
        }
    
    def analyze_file_hash(self, file_hash: str) -> Dict[str, Any]:
        """åˆ†ææ–‡ä»¶å“ˆå¸Œä¿¡èª‰"""
        is_malicious = self.check_indicator('hashes', file_hash)
        metadata = self.threat_metadata.get(file_hash, {})
        
        return {
            'hash': file_hash,
            'is_malicious': is_malicious,
            'reputation_score': 0.1 if is_malicious else 0.9,
            'threat_types': metadata.get('threat_types', []),
            'file_type': metadata.get('file_type'),
            'first_seen': metadata.get('first_seen'),
            'sources': metadata.get('sources', [])
        }
    
    def update_threat_feeds(self):
        """æ›´æ–°å¨èƒæƒ…æŠ¥æº"""
        # è¿™é‡Œå¯ä»¥é›†æˆå®é™…çš„å¨èƒæƒ…æŠ¥æºAPI
        # ä¾‹å¦‚: VirusTotal, ThreatIntel, MISPç­‰
        pass
    
    def save_threat_intelligence(self):
        """ä¿å­˜å¨èƒæƒ…æŠ¥æ•°æ®"""
        data = {
            'ips': list(self.indicators['ips']),
            'domains': list(self.indicators['domains']),
            'hashes': list(self.indicators['hashes']),
            'urls': list(self.indicators['urls']),
            'metadata': self.threat_metadata,
            'last_updated': datetime.now().isoformat()
        }
        
        with open(self.data_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def get_threat_summary(self) -> Dict[str, Any]:
        """è·å–å¨èƒæ‘˜è¦"""
        return {
            'total_indicators': sum(len(indicators) for indicators in self.indicators.values()),
            'ip_addresses': len(self.indicators['ips']),
            'domains': len(self.indicators['domains']),
            'file_hashes': len(self.indicators['hashes']),
            'urls': len(self.indicators['urls']),
            'last_updated': self.threat_metadata.get('last_updated'),
            'sources': self.threat_metadata.get('sources', [])
        }
```

## å®‰å…¨ä»ªè¡¨æ¿

```python
class SecurityDashboard:
    """å®‰å…¨ä»ªè¡¨æ¿"""
    
    def __init__(self, alert_manager: AlertManager, 
                 log_manager: LogManager, 
                 threat_intel: ThreatIntelligence):
        self.alert_manager = alert_manager
        self.log_manager = log_manager
        self.threat_intel = threat_intel
    
    def generate_dashboard_data(self) -> Dict[str, Any]:
        """ç”Ÿæˆä»ªè¡¨æ¿æ•°æ®"""
        # è·å–å‘Šè­¦ç»Ÿè®¡
        alert_stats = self.alert_manager.get_alert_statistics()
        
        # è·å–æ—¥å¿—åˆ†æ
        trends = self.log_manager.analyze_trends(days=1)
        
        # è·å–å¨èƒæƒ…æŠ¥æ‘˜è¦
        threat_summary = self.threat_intel.get_threat_summary()
        
        # ç”Ÿæˆä»ªè¡¨æ¿æ•°æ®
        dashboard_data = {
            'timestamp': datetime.now().isoformat(),
            'alert_summary': alert_stats,
            'event_trends': trends,
            'threat_intelligence': threat_summary,
            'system_health': self._get_system_health(),
            'top_threats': self._get_top_threats(),
            'recent_alerts': self._get_recent_alerts()
        }
        
        return dashboard_data
    
    def _get_system_health(self) -> Dict[str, str]:
        """è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€"""
        return {
            'status': 'healthy',
            'components': {
                'monitoring': 'operational',
                'alerting': 'operational', 
                'log_processing': 'operational',
                'threat_intelligence': 'operational'
            },
            'last_check': datetime.now().isoformat()
        }
    
    def _get_top_threats(self) -> List[Dict[str, Any]]:
        """è·å–ä¸»è¦å¨èƒ"""
        # è·å–æœ€è¿‘çš„å¨èƒäº‹ä»¶
        recent_events = self.log_manager.search_logs(
            start_time=datetime.now() - timedelta(hours=24),
            limit=100
        )
        
        threats = []
        for event in recent_events:
            if event['severity'] in ['critical', 'error']:
                threats.append({
                    'event_type': event['event_type'],
                    'source': event['source'],
                    'severity': event['severity'],
                    'timestamp': event['timestamp']
                })
        
        return sorted(threats, key=lambda x: x['timestamp'], reverse=True)[:10]
    
    def _get_recent_alerts(self) -> List[Dict[str, Any]]:
        """è·å–æœ€è¿‘çš„å‘Šè­¦"""
        recent_alerts = self.alert_manager.get_active_alerts()
        
        return [
            {
                'alert_id': alert.alert_id,
                'rule_name': alert.rule_name,
                'severity': alert.event.severity.value,
                'source': alert.event.source,
                'timestamp': alert.timestamp.isoformat(),
                'status': alert.status
            }
            for alert in recent_alerts[:20]
        ]
    
    def generate_html_dashboard(self, output_file: str = "security_dashboard.html"):
        """ç”ŸæˆHTMLä»ªè¡¨æ¿"""
        data = self.generate_dashboard_data()
        
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Security Dashboard</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background-color: #f0f0f0; padding: 20px; border-radius: 5px; }}
        .metric {{ background-color: #fff; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 5px; }}
        .critical {{ border-left: 5px solid #d32f2f; }}
        .warning {{ border-left: 5px solid #ff9800; }}
        .info {{ border-left: 5px solid #2196f3; }}
        .grid {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
        table {{ width: 100%; border-collapse: collapse; }}
        th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
        th {{ background-color: #f2f2f2; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ›¡ï¸ Security Dashboard</h1>
        <p>Last Updated: {data['timestamp']}</p>
        <p>System Status: {data['system_health']['status']}</p>
    </div>
    
    <div class="grid">
        <div class="metric">
            <h2>Alert Summary</h2>
            <p>Active Alerts: {data['alert_summary']['active']}</p>
            <p>Total Events: {data['alert_summary']['total']}</p>
            <p>Resolved: {data['alert_summary']['resolved']}</p>
        </div>
        
        <div class="metric">
            <h2>Event Trends (24h)</h2>
            <p>Total Events: {data['event_trends']['total_events']}</p>
            <p>Event Types: {len(data['event_trends']['event_type_distribution'])}</p>
            <p>Severity Levels: {len(data['event_trends']['severity_distribution'])}</p>
        </div>
        
        <div class="metric">
            <h2>Threat Intelligence</h2>
            <p>Total Indicators: {data['threat_intelligence']['total_indicators']}</p>
            <p>IP Addresses: {data['threat_intelligence']['ip_addresses']}</p>
            <p>Domains: {data['threat_intelligence']['domains']}</p>
        </div>
    </div>
    
    <div class="metric">
        <h2>Recent Alerts</h2>
        <table>
            <tr><th>Alert ID</th><th>Rule</th><th>Severity</th><th>Source</th><th>Time</th><th>Status</th></tr>
"""
        
        for alert in data['recent_alerts']:
            severity_class = alert['severity']
            html_content += f"""
            <tr class="{severity_class}">
                <td>{alert['alert_id']}</td>
                <td>{alert['rule_name']}</td>
                <td>{alert['severity']}</td>
                <td>{alert['source']}</td>
                <td>{alert['timestamp']}</td>
                <td>{alert['status']}</td>
            </tr>
"""
        
        html_content += """
        </table>
    </div>
</body>
</html>
"""
        
        with open(output_file, 'w') as f:
            f.write(html_content)
        
        return output_file
```

## å“åº”è‡ªåŠ¨åŒ–

```python
class IncidentResponse:
    """äº‹ä»¶å“åº”è‡ªåŠ¨åŒ–"""
    
    def __init__(self, alert_manager: AlertManager, 
                 log_manager: LogManager,
                 threat_intel: ThreatIntelligence):
        self.alert_manager = alert_manager
        self.log_manager = log_manager
        self.threat_intel = threat_intel
        self.response_actions = {}
        self._register_default_actions()
    
    def _register_default_actions(self):
        """æ³¨å†Œé»˜è®¤å“åº”åŠ¨ä½œ"""
        self.register_action('block_ip', self._block_ip_action)
        self.register_action('isolate_host', self._isolate_host_action)
        self.register_action('quarantine_file', self._quarantine_file_action)
        self.register_action('disable_user', self._disable_user_action)
        self.register_action('increase_logging', self._increase_logging_action)
    
    def register_action(self, action_name: str, action_func: Callable):
        """æ³¨å†Œå“åº”åŠ¨ä½œ"""
        self.response_actions[action_name] = action_func
    
    def create_response_workflow(self, alert: Alert) -> List[Dict[str, Any]]:
        """åˆ›å»ºå“åº”å·¥ä½œæµ"""
        workflow = []
        
        # åŸºäºå‘Šè­¦ç±»å‹å’Œä¸¥é‡çº§åˆ«ç¡®å®šå“åº”åŠ¨ä½œ
        if alert.event.severity == EventSeverity.CRITICAL:
            if alert.rule_name == 'system_intrusion':
                workflow.extend([
                    {'action': 'block_ip', 'target': alert.event.source},
                    {'action': 'isolate_host', 'target': alert.event.target},
                    {'action': 'increase_logging', 'target': alert.event.source}
                ])
            elif alert.rule_name == 'multiple_failed_logins':
                workflow.append({'action': 'block_ip', 'target': alert.event.source})
        
        elif alert.event.severity == EventSeverity.ERROR:
            if 'suspicious' in alert.rule_name:
                workflow.append({'action': 'increase_logging', 'target': alert.event.source})
        
        return workflow
    
    def execute_response_workflow(self, alert: Alert) -> Dict[str, Any]:
        """æ‰§è¡Œå“åº”å·¥ä½œæµ"""
        workflow = self.create_response_workflow(alert)
        results = []
        
        for step in workflow:
            try:
                action_name = step['action']
                target = step.get('target')
                
                if action_name in self.response_actions:
                    result = self.response_actions[action_name](target, alert)
                    results.append({
                        'action': action_name,
                        'target': target,
                        'status': 'success',
                        'result': result
                    })
                else:
                    results.append({
                        'action': action_name,
                        'target': target,
                        'status': 'failed',
                        'error': 'Unknown action'
                    })
            
            except Exception as e:
                results.append({
                    'action': step['action'],
                    'target': step.get('target'),
                    'status': 'failed',
                    'error': str(e)
                })
        
        return {
            'alert_id': alert.alert_id,
            'workflow_executed': len(workflow),
            'results': results
        }
    
    def _block_ip_action(self, ip: str, alert: Alert) -> str:
        """å°ç¦IPåœ°å€"""
        # æ¨¡æ‹ŸIPå°ç¦
        action_result = f"IP {ip} has been blocked"
        print(f"BLOCKING IP: {ip}")
        
        # æ·»åŠ åˆ°å¨èƒæƒ…æŠ¥
        self.threat_intel.add_threat_indicator(
            'ips', ip, 
            {
                'threat_types': ['malicious_activity'],
                'first_seen': datetime.now().isoformat(),
                'sources': ['automated_response']
            }
        )
        
        return action_result
    
    def _isolate_host_action(self, host: str, alert: Alert) -> str:
        """éš”ç¦»ä¸»æœº"""
        action_result = f"Host {host} has been isolated"
        print(f"ISOLATING HOST: {host}")
        return action_result
    
    def _quarantine_file_action(self, file_path: str, alert: Alert) -> str:
        """éš”ç¦»æ–‡ä»¶"""
        action_result = f"File {file_path} has been quarantined"
        print(f"QUARANTINING FILE: {file_path}")
        return action_result
    
    def _disable_user_action(self, user_id: str, alert: Alert) -> str:
        """ç¦ç”¨ç”¨æˆ·"""
        action_result = f"User {user_id} has been disabled"
        print(f"DISABLING USER: {user_id}")
        return action_result
    
    def _increase_logging_action(self, target: str, alert: Alert) -> str:
        """å¢åŠ æ—¥å¿—è®°å½•"""
        action_result = f"Increased logging level for {target}"
        print(f"INCREASING LOGGING FOR: {target}")
        return action_result
    
    def auto_respond_to_alerts(self):
        """è‡ªåŠ¨å“åº”å‘Šè­¦"""
        active_alerts = self.alert_manager.get_active_alerts()
        
        for alert in active_alerts:
            if alert.status == 'active':
                # æ‰§è¡Œè‡ªåŠ¨å“åº”
                response_result = self.execute_response_workflow(alert)
                
                print(f"Auto-response executed for alert {alert.alert_id}")
                print(f"Response results: {response_result}")

class SecurityOrchestrator:
    """å®‰å…¨ç¼–æ’å™¨"""
    
    def __init__(self):
        self.event_collector = EventCollector()
        self.alert_manager = AlertManager()
        self.log_manager = LogManager()
        self.security_analyzer = SecurityAnalyzer()
        self.threat_intelligence = ThreatIntelligence()
        self.incident_response = IncidentResponse(
            self.alert_manager, self.log_manager, self.threat_intelligence
        )
        self.dashboard = SecurityDashboard(
            self.alert_manager, self.log_manager, self.threat_intelligence
        )
        
        # è®¾ç½®äº‹ä»¶æµ
        self._setup_event_flow()
    
    def _setup_event_flow(self):
        """è®¾ç½®äº‹ä»¶æµ"""
        # å°†äº‹ä»¶å¤„ç†å™¨é“¾æ¥èµ·æ¥
        self.event_collector.register_handler(self._handle_security_event)
    
    def _handle_security_event(self, event: SecurityEvent):
        """å¤„ç†å®‰å…¨äº‹ä»¶"""
        # 1. å­˜å‚¨äº‹ä»¶æ—¥å¿—
        self.log_manager.store_event(event)
        
        # 2. æ£€æŸ¥å¨èƒæƒ…æŠ¥
        self._check_threat_intelligence(event)
        
        # 3. åˆ†æå¼‚å¸¸è¡Œä¸º
        self._analyze_anomalies(event)
        
        # 4. è§¦å‘å‘Šè­¦
        self.alert_manager.process_event(event)
    
    def _check_threat_intelligence(self, event: SecurityEvent):
        """æ£€æŸ¥å¨èƒæƒ…æŠ¥"""
        # æ£€æŸ¥IPåœ°å€
        if hasattr(self, 'check_ip_threat'):
            is_threat = self.threat_intelligence.check_indicator('ips', event.source)
            if is_threat:
                # åˆ›å»ºé«˜ä¼˜å…ˆçº§å‘Šè­¦
                threat_event = SecurityEvent(
                    event_id=f"threat_{int(time.time())}",
                    timestamp=datetime.now(),
                    event_type=event.event_type,
                    severity=EventSeverity.CRITICAL,
                    source=event.source,
                    target=event.target,
                    description=f"Threat intelligence match: {event.source}",
                    details=event.details,
                    tags=event.tags + ['threat_intelligence']
                )
                self.alert_manager.process_event(threat_event)
    
    def _analyze_anomalies(self, event: SecurityEvent):
        """åˆ†æå¼‚å¸¸è¡Œä¸º"""
        # ç®€åŒ–å¼‚å¸¸æ£€æµ‹é€»è¾‘
        if event.severity == EventSeverity.CRITICAL:
            # åˆ›å»ºå…³è”äº‹ä»¶
            correlation_event = SecurityEvent(
                event_id=f"correlation_{int(time.time())}",
                timestamp=datetime.now(),
                event_type=EventType.SYSTEM,
                severity=EventSeverity.WARNING,
                source="system",
                target="correlation_engine",
                description="Anomaly correlation analysis triggered",
                details={'related_event': event.event_id},
                tags=['anomaly', 'correlation']
            )
            self.log_manager.store_event(correlation_event)
    
    def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        self.event_collector.start_collection()
        
        # å¯åŠ¨å„ç§ç›‘æ§å™¨
        network_monitor = NetworkEventCollector()
        system_monitor = SystemEventCollector()
        app_monitor = ApplicationEventCollector()
        
        network_monitor.start_network_monitoring()
        system_monitor.start_system_monitoring()
        app_monitor.start_application_monitoring()
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.event_collector.stop_collection()
    
    def generate_security_report(self) -> str:
        """ç”Ÿæˆå®‰å…¨æŠ¥å‘Š"""
        return self.log_manager.generate_report(days=7)
    
    def create_dashboard(self) -> str:
        """åˆ›å»ºä»ªè¡¨æ¿"""
        return self.dashboard.generate_html_dashboard()
```

## æ€»ç»“

å®‰å…¨ç›‘æ§ç³»ç»Ÿæ˜¯ç°ä»£ç½‘ç»œå®‰å…¨æ¶æ„çš„æ ¸å¿ƒç»„ä»¶ï¼Œéœ€è¦æ•´åˆäº‹ä»¶æ”¶é›†ã€å¼‚å¸¸æ£€æµ‹ã€å‘Šè­¦ç®¡ç†ã€å¨èƒæƒ…æŠ¥ç­‰å¤šä¸ªåŠŸèƒ½æ¨¡å—ã€‚è‰¯å¥½çš„å®‰å…¨ç›‘æ§ç³»ç»Ÿåº”è¯¥å…·å¤‡ï¼š

1. **å…¨é¢è¦†ç›–**: ç½‘ç»œã€ä¸»æœºã€åº”ç”¨ã€æ•°æ®ã€ç”¨æˆ·ç­‰å„ä¸ªå±‚é¢
2. **å®æ—¶ç›‘æ§**: åŠæ—¶å‘ç°å’Œå¤„ç†å®‰å…¨äº‹ä»¶
3. **æ™ºèƒ½åˆ†æ**: è‡ªåŠ¨å…³è”åˆ†æï¼Œè¯†åˆ«å¤æ‚æ”»å‡»æ¨¡å¼
4. **å¿«é€Ÿå“åº”**: è‡ªåŠ¨åŒ–çš„å“åº”æœºåˆ¶ï¼Œå‡å°‘äººå·¥å¹²é¢„
5. **å¯è§†åŒ–å±•ç¤º**: ç›´è§‚çš„å®‰å…¨ä»ªè¡¨æ¿å’ŒæŠ¥å‘Š
6. **å¯æ‰©å±•æ€§**: æ”¯æŒæ–°å¨èƒç±»å‹çš„æ£€æµ‹å’Œå“åº”

é€šè¿‡æ„å»ºå®Œæ•´çš„ç›‘æ§ä½“ç³»ï¼Œå¯ä»¥æ˜¾è‘—æé«˜ç»„ç»‡çš„ç½‘ç»œå®‰å…¨é˜²æŠ¤èƒ½åŠ›ï¼ŒåŠæ—¶å‘ç°å’Œå¤„ç½®å®‰å…¨å¨èƒã€‚

---
*æ–‡æ¡£æ›´æ–°æ—¶é—´: 2024å¹´12æœˆ*