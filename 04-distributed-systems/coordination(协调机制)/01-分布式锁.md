# 分布式锁详解

## 目录
1. [分布式锁概述](#分布式锁概述)
2. [分布式锁要求](#分布式锁要求)
3. [基于数据库的分布式锁](#基于数据库的分布式锁)
4. [基于Redis的分布式锁](#基于redis的分布式锁)
5. [基于ZooKeeper的分布式锁](#基于zookeeper的分布式锁)
6. [基于Consul的分布式锁](#基于consul的分布式锁)
7. [分布式锁对比分析](#分布式锁对比分析)
8. [Python实现](#python实现)
9. [Go语言实现](#go语言实现)
10. [实际应用案例](#实际应用案例)
11. [最佳实践](#最佳实践)

## 分布式锁概述

### 什么是分布式锁？

分布式锁（Distributed Lock）是一种在分布式系统中实现互斥访问的机制，确保多个进程或节点在同一时间只有一个能够执行特定的操作。

### 为什么需要分布式锁？

```python
class DistributedLockNeed:
    """分布式锁需求分析"""
    
    def __init__(self):
        self.problems = {
            'race_condition': {
                'name': '竞态条件',
                'description': '多个节点同时修改共享资源',
                'example': '库存扣减操作',
                'impact': '数据不一致'
            },
            'data_corruption': {
                'name': '数据损坏',
                'description': '并发写入导致数据异常',
                'example': '账户余额计算错误',
                'impact': '业务逻辑错误'
            },
            'resource_conflict': {
                'name': '资源冲突',
                'description': '多个节点争夺同一资源',
                'example': '文件写入冲突',
                'impact': '操作失败或覆盖'
            },
            'duplicate_execution': {
                'name': '重复执行',
                'description': '同一任务被多次执行',
                'example': '重复支付处理',
                'impact': '业务损失'
            }
        }
    
    def show_local_vs_distributed(self):
        """展示本地锁 vs 分布式锁"""
        comparison = {
            '本地锁': {
                'scope': '单进程内',
                'implementation': '语言内置（synchronized, Lock）',
                'problem': '无法跨机器协调',
                'performance': '极快'
            },
            '分布式锁': {
                'scope': '多机器/多进程',
                'implementation': '外部系统（Redis/ZooKeeper等）',
                'problem': '网络延迟和故障',
                'performance': '较慢但可靠'
            }
        }
        return comparison

# 分布式锁使用场景
class DistributedLockUseCases:
    """分布式锁使用场景"""
    
    def __init__(self):
        self.use_cases = [
            {
                'scenario': '库存扣减',
                'problem': '超卖问题',
                'solution': '分布式锁确保库存操作原子性',
                'critical_level': '极高'
            },
            {
                'scenario': '定时任务',
                'problem': '重复执行',
                'solution': '只有获得锁的节点执行任务',
                'critical_level': '高'
            },
            {
                'scenario': '文件写入',
                'problem': '文件内容冲突',
                'solution': '串行化文件访问',
                'critical_level': '中等'
            },
            {
                'scenario': '数据库操作',
                'problem': '事务隔离问题',
                'solution': '应用层协调数据库访问',
                'critical_level': '高'
            },
            {
                'scenario': '缓存更新',
                'problem': '缓存穿透',
                'solution': '只允许一个节点更新缓存',
                'critical_level': '中等'
            },
            {
                'scenario': 'API限流',
                'problem': '重复调用',
                'solution': '串行化限流检查',
                'critical_level': '中等'
            }
        ]

print("=== 分布式锁使用场景 ===")
for case in DistributedLockUseCases().use_cases:
    print(f"场景: {case['scenario']}")
    print(f"问题: {case['problem']}")
    print(f"解决: {case['solution']}")
    print(f"关键程度: {case['critical_level']}\n")
```

## 分布式锁要求

```python
class DistributedLockRequirements:
    """分布式锁要求"""
    
    def __init__(self):
        self.requirements = {
            'mutual_exclusion': {
                'name': '互斥性',
                'description': '同一时间只有一个节点能获得锁',
                'critical': True,
                'implementation': '通过唯一标识和原子操作实现'
            },
            'deadlock_free': {
                'name': '无死锁',
                'description': '避免系统死锁和锁不释放',
                'critical': True,
                'implementation': '设置锁超时时间和自动释放'
            },
            'fault_tolerance': {
                'name': '容错性',
                'description': '节点故障时锁能够正常释放',
                'critical': True,
                'implementation': '基于租约和TTL机制'
            },
            'fairness': {
                'name': '公平性',
                'description': '等待队列按照FIFO原则',
                'critical': False,
                'implementation': '有序队列或优先级机制'
            },
            'performance': {
                'name': '性能',
                'description': '锁操作延迟低，吞吐量高',
                'critical': False,
                'implementation': '优化网络和存储性能'
            },
            'reliability': {
                'name': '可靠性',
                'description': '锁服务高可用',
                'critical': True,
                'implementation': '集群部署和故障转移'
            }
        }
    
    def evaluate_implementation(self, implementation_name: str, requirements_met: list):
        """评估实现满足要求程度"""
        critical_met = 0
        critical_total = 0
        total_met = 0
        total_total = 0
        
        for req_name, req_data in self.requirements.items():
            total_total += 1
            if req_name in requirements_met:
                total_met += 1
            
            if req_data['critical']:
                critical_total += 1
                if req_name in requirements_met:
                    critical_met += 1
        
        reliability_score = critical_met / critical_total * 100
        completeness_score = total_met / total_total * 100
        
        return {
            'implementation': implementation_name,
            'reliability_score': reliability_score,
            'completeness_score': completeness_score,
            'critical_met': f"{critical_met}/{critical_total}",
            'total_met': f"{total_met}/{total_total}"
        }

# 锁的生命周期
class LockLifecycle:
    """锁的生命周期"""
    
    def __init__(self):
        self.states = {
            'unlocked': '未锁定状态',
            'acquiring': '尝试获取锁',
            'locked': '已锁定状态',
            'renewing': '续租状态',
            'releasing': '释放锁状态',
            'timeout': '超时状态',
            'error': '错误状态'
        }
        
        self.transitions = {
            'unlocked': ['acquiring'],
            'acquiring': ['locked', 'error', 'timeout'],
            'locked': ['renewing', 'releasing', 'timeout'],
            'renewing': ['locked', 'timeout'],
            'releasing': ['unlocked'],
            'timeout': ['unlocked'],
            'error': ['unlocked']
        }
    
    def show_lifecycle(self):
        """显示锁的生命周期"""
        return " -> ".join(self.states.keys())

print(f"锁的生命周期: {LockLifecycle().show_lifecycle()}")
```

## 基于数据库的分布式锁

### 1. 表锁方式

```python
import sqlite3
import time
import threading
from contextlib import contextmanager
from typing import Optional, Dict, Any

class DatabaseLock:
    """基于数据库的分布式锁"""
    
    def __init__(self, db_path: str = "distributed_locks.db"):
        self.db_path = db_path
        self.connection = None
        self.init_database()
    
    def init_database(self):
        """初始化数据库"""
        self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
        cursor = self.connection.cursor()
        
        # 创建锁表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS distributed_locks (
                lock_key TEXT PRIMARY KEY,
                lock_value TEXT NOT NULL,
                created_at REAL NOT NULL,
                expires_at REAL NOT NULL,
                thread_id TEXT
            )
        ''')
        
        self.connection.commit()
    
    def acquire_lock(self, lock_key: str, lock_value: str, timeout: float = 30.0, 
                    lease_duration: float = 10.0) -> bool:
        """获取锁"""
        start_time = time.time()
        thread_id = threading.get_ident()
        
        while time.time() - start_time < timeout:
            try:
                current_time = time.time()
                expires_at = current_time + lease_duration
                
                # 尝试插入锁记录
                cursor = self.connection.cursor()
                cursor.execute('''
                    INSERT INTO distributed_locks 
                    (lock_key, lock_value, created_at, expires_at, thread_id)
                    VALUES (?, ?, ?, ?, ?)
                ''', (lock_key, lock_value, current_time, expires_at, thread_id))
                
                self.connection.commit()
                print(f"Thread {thread_id} acquired lock for key: {lock_key}")
                return True
                
            except sqlite3.IntegrityError:
                # 锁已存在，检查是否过期
                cursor = self.connection.cursor()
                cursor.execute('''
                    SELECT lock_value, expires_at FROM distributed_locks 
                    WHERE lock_key = ?
                ''', (lock_key,))
                
                result = cursor.fetchone()
                if result:
                    lock_value_old, expires_at = result
                    if time.time() > expires_at:
                        # 锁已过期，尝试删除并重新插入
                        cursor.execute('DELETE FROM distributed_locks WHERE lock_key = ?', (lock_key,))
                        self.connection.commit()
                        
                        # 重新尝试插入
                        cursor.execute('''
                            INSERT INTO distributed_locks 
                            (lock_key, lock_value, created_at, expires_at, thread_id)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (lock_key, lock_value, time.time(), expires_at, thread_id))
                        
                        self.connection.commit()
                        print(f"Thread {thread_id} acquired expired lock for key: {lock_key}")
                        return True
                
                # 锁存在且未过期，等待后重试
                time.sleep(0.1)
                
            except Exception as e:
                print(f"Error acquiring lock: {e}")
                time.sleep(0.1)
        
        print(f"Thread {thread_id} failed to acquire lock for key: {lock_key}")
        return False
    
    def release_lock(self, lock_key: str, lock_value: str) -> bool:
        """释放锁"""
        try:
            cursor = self.connection.cursor()
            
            # 验证锁值是否匹配
            cursor.execute('''
                SELECT lock_value FROM distributed_locks 
                WHERE lock_key = ?
            ''', (lock_key,))
            
            result = cursor.fetchone()
            if result and result[0] == lock_value:
                cursor.execute('DELETE FROM distributed_locks WHERE lock_key = ?', (lock_key,))
                self.connection.commit()
                print(f"Released lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to release lock for key: {lock_key} (value mismatch)")
                return False
                
        except Exception as e:
            print(f"Error releasing lock: {e}")
            return False
    
    def renew_lock(self, lock_key: str, lock_value: str, lease_duration: float = 10.0) -> bool:
        """续租锁"""
        try:
            cursor = self.connection.cursor()
            current_time = time.time()
            expires_at = current_time + lease_duration
            
            # 验证锁值并更新过期时间
            cursor.execute('''
                UPDATE distributed_locks 
                SET expires_at = ?
                WHERE lock_key = ? AND lock_value = ?
            ''', (expires_at, lock_key, lock_value))
            
            if cursor.rowcount > 0:
                self.connection.commit()
                print(f"Renewed lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to renew lock for key: {lock_key} (value mismatch or not found)")
                return False
                
        except Exception as e:
            print(f"Error renewing lock: {e}")
            return False
    
    def is_locked(self, lock_key: str) -> bool:
        """检查锁状态"""
        try:
            cursor = self.connection.cursor()
            cursor.execute('''
                SELECT expires_at FROM distributed_locks WHERE lock_key = ?
            ''', (lock_key,))
            
            result = cursor.fetchone()
            if result:
                expires_at = result[0]
                return time.time() <= expires_at
            
            return False
            
        except Exception as e:
            print(f"Error checking lock status: {e}")
            return False
    
    def cleanup_expired_locks(self):
        """清理过期锁"""
        try:
            cursor = self.connection.cursor()
            current_time = time.time()
            
            cursor.execute('''
                DELETE FROM distributed_locks WHERE expires_at < ?
            ''', (current_time,))
            
            deleted_count = cursor.rowcount
            self.connection.commit()
            
            if deleted_count > 0:
                print(f"Cleaned up {deleted_count} expired locks")
            
            return deleted_count
            
        except Exception as e:
            print(f"Error cleaning up expired locks: {e}")
            return 0
    
    @contextmanager
    def lock(self, lock_key: str, timeout: float = 30.0, lease_duration: float = 10.0):
        """锁上下文管理器"""
        lock_value = f"{threading.get_ident()}_{time.time()}"
        
        acquired = self.acquire_lock(lock_key, lock_value, timeout, lease_duration)
        
        if not acquired:
            raise Exception(f"Failed to acquire lock for key: {lock_key}")
        
        try:
            yield self
        finally:
            self.release_lock(lock_key, lock_value)
    
    def close(self):
        """关闭数据库连接"""
        if self.connection:
            self.connection.close()

# 使用示例
def demo_database_lock():
    """数据库锁演示"""
    db_lock = DatabaseLock()
    
    def worker(worker_id: int, lock_key: str, work_duration: float):
        """工作线程"""
        print(f"Worker {worker_id} starting")
        
        try:
            with db_lock.lock(lock_key, timeout=5.0, lease_duration=3.0):
                print(f"Worker {worker_id} acquired lock, starting work...")
                
                # 模拟工作
                time.sleep(work_duration)
                
                print(f"Worker {worker_id} completed work")
                
        except Exception as e:
            print(f"Worker {worker_id} failed: {e}")
    
    # 启动多个工作线程竞争锁
    threads = []
    for i in range(3):
        thread = threading.Thread(target=worker, args=(i, "shared_resource", 2.0))
        threads.append(thread)
        thread.start()
    
    # 等待所有线程完成
    for thread in threads:
        thread.join()
    
    # 清理
    db_lock.cleanup_expired_locks()
    db_lock.close()

if __name__ == "__main__":
    demo_database_lock()
```

### 2. 行锁方式

```python
class RowBasedDatabaseLock:
    """基于数据库行锁的分布式锁"""
    
    def __init__(self, db_path: str = "row_locks.db"):
        self.db_path = db_path
        self.connection = None
        self.init_database()
    
    def init_database(self):
        """初始化数据库"""
        self.connection = sqlite3.connect(self.db_path, check_same_thread=False)
        cursor = self.connection.cursor()
        
        # 创建锁控制表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS lock_control (
                lock_key TEXT PRIMARY KEY,
                holder_id TEXT NOT NULL,
                holder_session TEXT NOT NULL,
                created_at REAL NOT NULL,
                last_heartbeat REAL NOT NULL,
                version INTEGER DEFAULT 1
            )
        ''')
        
        # 创建辅助表用于行锁
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS lock_helper (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                lock_key TEXT NOT NULL,
                created_at REAL NOT NULL
            )
        ''')
        
        self.connection.commit()
    
    def acquire_lock_with_select_for_update(self, lock_key: str, holder_id: str, 
                                          session_id: str, timeout: float = 30.0) -> bool:
        """使用SELECT FOR UPDATE方式获取锁"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                cursor = self.connection.cursor()
                
                # 开始事务
                cursor.execute('BEGIN IMMEDIATE')
                
                # 尝试获取行锁
                cursor.execute('''
                    SELECT id FROM lock_helper WHERE lock_key = ?
                    FOR UPDATE
                ''', (lock_key,))
                
                result = cursor.fetchone()
                
                if not result:
                    # 创建锁记录
                    cursor.execute('''
                        INSERT INTO lock_helper (lock_key, created_at)
                        VALUES (?, ?)
                    ''', (lock_key, time.time()))
                    
                    lock_id = cursor.lastrowid
                else:
                    lock_id = result[0]
                
                # 插入或更新锁控制表
                current_time = time.time()
                cursor.execute('''
                    INSERT OR REPLACE INTO lock_control 
                    (lock_key, holder_id, holder_session, created_at, last_heartbeat, version)
                    VALUES (?, ?, ?, ?, ?, 
                            COALESCE((SELECT version + 1 FROM lock_control WHERE lock_key = ?), 1))
                ''', (lock_key, holder_id, session_id, current_time, current_time, lock_key))
                
                self.connection.commit()
                print(f"Holder {holder_id} acquired lock for key: {lock_key}")
                return True
                
            except sqlite3.Error as e:
                self.connection.rollback()
                print(f"Error acquiring lock: {e}")
                time.sleep(0.1)
        
        return False
    
    def release_lock(self, lock_key: str, holder_id: str, session_id: str) -> bool:
        """释放锁"""
        try:
            cursor = self.connection.cursor()
            cursor.execute('BEGIN IMMEDIATE')
            
            # 验证持有者身份
            cursor.execute('''
                SELECT holder_id, holder_session FROM lock_control WHERE lock_key = ?
            ''', (lock_key,))
            
            result = cursor.fetchone()
            if not result or result[0] != holder_id or result[1] != session_id:
                self.connection.rollback()
                print(f"Lock holder verification failed for key: {lock_key}")
                return False
            
            # 删除锁记录
            cursor.execute('DELETE FROM lock_control WHERE lock_key = ?', (lock_key,))
            cursor.execute('DELETE FROM lock_helper WHERE lock_key = ?', (lock_key,))
            
            self.connection.commit()
            print(f"Holder {holder_id} released lock for key: {lock_key}")
            return True
            
        except sqlite3.Error as e:
            self.connection.rollback()
            print(f"Error releasing lock: {e}")
            return False
    
    def heartbeat(self, lock_key: str, holder_id: str, session_id: str) -> bool:
        """发送心跳"""
        try:
            cursor = self.connection.cursor()
            
            # 更新最后心跳时间
            cursor.execute('''
                UPDATE lock_control 
                SET last_heartbeat = ?
                WHERE lock_key = ? AND holder_id = ? AND holder_session = ?
            ''', (time.time(), lock_key, holder_id, session_id))
            
            if cursor.rowcount > 0:
                self.connection.commit()
                return True
            else:
                return False
                
        except sqlite3.Error as e:
            print(f"Error sending heartbeat: {e}")
            return False
    
    def force_release_expired_locks(self, timeout: float = 30.0):
        """强制释放过期锁"""
        try:
            cursor = self.connection.cursor()
            current_time = time.time()
            expired_time = current_time - timeout
            
            cursor.execute('''
                SELECT lock_key FROM lock_control 
                WHERE last_heartbeat < ?
            ''', (expired_time,))
            
            expired_locks = cursor.fetchall()
            
            for (lock_key,) in expired_locks:
                cursor.execute('DELETE FROM lock_control WHERE lock_key = ?', (lock_key,))
                cursor.execute('DELETE FROM lock_helper WHERE lock_key = ?', (lock_key,))
                print(f"Force released expired lock for key: {lock_key}")
            
            if expired_locks:
                self.connection.commit()
            
            return len(expired_locks)
            
        except sqlite3.Error as e:
            print(f"Error releasing expired locks: {e}")
            return 0
    
    def close(self):
        """关闭数据库连接"""
        if self.connection:
            self.connection.close()

# 分布式锁管理器
class DistributedLockManager:
    """分布式锁管理器"""
    
    def __init__(self, lock_backend: str = 'database'):
        self.backend_type = lock_backend
        
        if lock_backend == 'database':
            self.db_lock = DatabaseLock()
            self.row_lock = RowBasedDatabaseLock()
        else:
            raise ValueError(f"Unsupported lock backend: {lock_backend}")
    
    def acquire_lock(self, lock_key: str, timeout: float = 30.0, lease_duration: float = 10.0) -> Optional[str]:
        """获取锁，返回锁标识"""
        import uuid
        lock_id = str(uuid.uuid4())
        
        if self.backend_type == 'database':
            if self.db_lock.acquire_lock(lock_key, lock_id, timeout, lease_duration):
                return lock_id
        elif self.backend_type == 'row_database':
            if self.row_lock.acquire_lock_with_select_for_update(lock_key, lock_id, str(time.time()), timeout):
                return lock_id
        
        return None
    
    def release_lock(self, lock_key: str, lock_id: str) -> bool:
        """释放锁"""
        if self.backend_type == 'database':
            return self.db_lock.release_lock(lock_key, lock_id)
        elif self.backend_type == 'row_database':
            return self.row_lock.release_lock(lock_key, lock_id, str(time.time()))
        
        return False
    
    def is_locked(self, lock_key: str) -> bool:
        """检查锁状态"""
        if self.backend_type == 'database':
            return self.db_lock.is_locked(lock_key)
        elif self.backend_type == 'row_database':
            cursor = self.row_lock.connection.cursor()
            cursor.execute('SELECT holder_id FROM lock_control WHERE lock_key = ?', (lock_key,))
            return cursor.fetchone() is not None
        
        return False
    
    @contextmanager
    def lock(self, lock_key: str, timeout: float = 30.0, lease_duration: float = 10.0):
        """锁上下文管理器"""
        lock_id = self.acquire_lock(lock_key, timeout, lease_duration)
        
        if not lock_id:
            raise Exception(f"Failed to acquire lock for key: {lock_key}")
        
        try:
            yield lock_id
        finally:
            self.release_lock(lock_key, lock_id)
    
    def close(self):
        """关闭锁管理器"""
        if self.backend_type == 'database':
            self.db_lock.close()
        elif self.backend_type == 'row_database':
            self.row_lock.close()

print("=== 数据库锁实现完成 ===")
```

## 基于Redis的分布式锁

### 1. 基本Redis锁实现

```python
import redis
import time
import uuid
import threading
from contextlib import contextmanager
from typing import Optional, Dict, Any

class RedisDistributedLock:
    """基于Redis的分布式锁"""
    
    def __init__(self, host: str = 'localhost', port: int = 6379, db: int = 0, 
                 password: str = None, decode_responses: bool = True):
        self.redis_client = redis.Redis(
            host=host, port=port, db=db, password=password, 
            decode_responses=decode_responses
        )
        self.acquired_locks = {}  # track acquired locks per thread
    
    def acquire_lock(self, lock_key: str, lock_value: str, timeout: float = 30.0, 
                    lease_duration: float = 10.0) -> bool:
        """获取锁"""
        try:
            # 设置过期时间（秒）
            expire_time = int(lease_duration)
            
            # 使用SET命令原子性获取锁
            result = self.redis_client.set(lock_key, lock_value, ex=expire_time, nx=True)
            
            if result:
                # 记录锁信息用于清理
                thread_id = threading.get_ident()
                if thread_id not in self.acquired_locks:
                    self.acquired_locks[thread_id] = []
                
                self.acquired_locks[thread_id].append({
                    'key': lock_key,
                    'value': lock_value,
                    'expires_at': time.time() + lease_duration
                })
                
                print(f"Acquired lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to acquire lock for key: {lock_key} (already exists)")
                return False
                
        except redis.RedisError as e:
            print(f"Redis error acquiring lock: {e}")
            return False
    
    def try_acquire_lock(self, lock_key: str, lock_value: str, timeout: float = 1.0) -> bool:
        """尝试非阻塞获取锁"""
        return self.acquire_lock(lock_key, lock_value, timeout, timeout)
    
    def release_lock(self, lock_key: str, lock_value: str) -> bool:
        """释放锁"""
        try:
            # Lua脚本确保原子性删除
            lua_script = """
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
            """
            
            result = self.redis_client.eval(lua_script, 1, lock_key, lock_value)
            
            if result:
                # 从本地记录中移除
                thread_id = threading.get_ident()
                if thread_id in self.acquired_locks:
                    self.acquired_locks[thread_id] = [
                        lock_info for lock_info in self.acquired_locks[thread_id]
                        if lock_info['key'] != lock_key
                    ]
                
                print(f"Released lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to release lock for key: {lock_key} (not owned or doesn't exist)")
                return False
                
        except redis.RedisError as e:
            print(f"Redis error releasing lock: {e}")
            return False
    
    def renew_lock(self, lock_key: str, lock_value: str, lease_duration: float = 10.0) -> bool:
        """续租锁"""
        try:
            # Lua脚本验证并更新过期时间
            lua_script = """
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("EXPIRE", KEYS[1], ARGV[2])
            else
                return 0
            end
            """
            
            result = self.redis_client.eval(lua_script, 1, lock_key, lock_value, str(int(lease_duration)))
            
            if result:
                # 更新本地记录
                thread_id = threading.get_ident()
                if thread_id in self.acquired_locks:
                    for lock_info in self.acquired_locks[thread_id]:
                        if lock_info['key'] == lock_key and lock_info['value'] == lock_value:
                            lock_info['expires_at'] = time.time() + lease_duration
                
                print(f"Renewed lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to renew lock for key: {lock_key} (not owned)")
                return False
                
        except redis.RedisError as e:
            print(f"Redis error renewing lock: {e}")
            return False
    
    def is_locked(self, lock_key: str) -> bool:
        """检查锁是否存在且有效"""
        try:
            return self.redis_client.exists(lock_key) > 0
        except redis.RedisError as e:
            print(f"Redis error checking lock status: {e}")
            return False
    
    def get_lock_info(self, lock_key: str) -> Optional[Dict[str, Any]]:
        """获取锁信息"""
        try:
            value = self.redis_client.get(lock_key)
            ttl = self.redis_client.ttl(lock_key)
            
            if value:
                return {
                    'key': lock_key,
                    'value': value,
                    'ttl': ttl,
                    'exists': True
                }
            else:
                return {'key': lock_key, 'exists': False}
                
        except redis.RedisError as e:
            print(f"Redis error getting lock info: {e}")
            return None
    
    def cleanup_expired_locks(self):
        """清理本地过期的锁记录"""
        current_time = time.time()
        thread_id = threading.get_ident()
        
        if thread_id in self.acquired_locks:
            expired_locks = []
            for lock_info in self.acquired_locks[thread_id]:
                if lock_info['expires_at'] <= current_time:
                    expired_locks.append(lock_info)
            
            # 移除过期锁记录
            for lock_info in expired_locks:
                self.acquired_locks[thread_id].remove(lock_info)
            
            return len(expired_locks)
        
        return 0
    
    @contextmanager
    def lock(self, lock_key: str, timeout: float = 30.0, lease_duration: float = 10.0):
        """锁上下文管理器"""
        lock_value = f"{threading.get_ident()}_{time.time()}_{uuid.uuid4()}"
        
        acquired = self.acquire_lock(lock_key, lock_value, timeout, lease_duration)
        
        if not acquired:
            raise Exception(f"Failed to acquire lock for key: {lock_key}")
        
        try:
            yield lock_value
        finally:
            self.release_lock(lock_key, lock_value)
    
    def execute_with_lock(self, func, lock_key: str, *args, **kwargs):
        """在锁保护下执行函数"""
        with self.lock(lock_key):
            return func(*args, **kwargs)
    
    def close(self):
        """关闭Redis连接"""
        self.redis_client.close()

# 使用示例
def demo_redis_lock():
    """Redis锁演示"""
    redis_lock = RedisDistributedLock()
    
    def critical_task(task_id: int, lock_key: str, duration: float):
        """关键任务"""
        print(f"Task {task_id} starting")
        
        try:
            with redis_lock.lock(lock_key, timeout=10.0, lease_duration=5.0):
                print(f"Task {task_id} acquired lock, executing critical work...")
                
                # 模拟关键业务处理
                time.sleep(duration)
                result = f"Task {task_id} completed at {time.time()}"
                print(f"Task {task_id} result: {result}")
                return result
                
        except Exception as e:
            print(f"Task {task_id} failed: {e}")
            return None
    
    # 并发执行多个任务
    import concurrent.futures
    
    lock_key = "order_processing"
    tasks = [(i, lock_key, 2.0 + i * 0.5) for i in range(3)]
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = [executor.submit(critical_task, *task) for task in tasks]
        
        for future in concurrent.futures.as_completed(futures):
            try:
                result = future.result()
                print(f"Future result: {result}")
            except Exception as e:
                print(f"Future exception: {e}")
    
    redis_lock.close()

if __name__ == "__main__":
    demo_redis_lock()
```

### 2. Redis锁集群支持

```python
import redis.sentinel
import random
from typing import List, Dict

class RedisSentinelLock:
    """Redis Sentinel分布式锁"""
    
    def __init__(self, sentinel_hosts: List[tuple], master_name: str):
        self.sentinel_hosts = sentinel_hosts
        self.master_name = master_name
        self.sentinel_client = None
        self.master_client = None
        self.slave_clients = []
        
        self._connect_sentinel()
    
    def _connect_sentinel(self):
        """连接Sentinel"""
        try:
            self.sentinel_client = redis.sentinel.Sentinel(
                self.sentinel_hosts, socket_timeout=0.5
            )
            
            # 获取主从实例
            self.master_client = self.sentinel_client.master_for(
                self.master_name, socket_timeout=0.5
            )
            
            # 获取从实例列表
            for slave in self.sentinel_client.discover_slaves(self.master_name):
                slave_host, slave_port = slave
                slave_client = redis.Redis(
                    host=slave_host, port=slave_port, 
                    socket_timeout=0.5, decode_responses=True
                )
                self.slave_clients.append(slave_client)
            
            print(f"Connected to Redis Sentinel: {len(self.slave_clients)} slaves available")
            
        except Exception as e:
            print(f"Failed to connect to Redis Sentinel: {e}")
    
    def acquire_lock(self, lock_key: str, lock_value: str, 
                    timeout: float = 30.0, lease_duration: float = 10.0) -> bool:
        """获取锁（只在主节点）"""
        try:
            expire_time = int(lease_duration)
            result = self.master_client.set(lock_key, lock_value, ex=expire_time, nx=True)
            
            if result:
                print(f"Acquired lock for key: {lock_key} on master")
                return True
            else:
                print(f"Failed to acquire lock for key: {lock_key}")
                return False
                
        except Exception as e:
            print(f"Error acquiring lock: {e}")
            return False
    
    def release_lock(self, lock_key: str, lock_value: str) -> bool:
        """释放锁（只在主节点）"""
        try:
            lua_script = """
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
            """
            
            result = self.master_client.eval(lua_script, 1, lock_key, lock_value)
            
            if result:
                print(f"Released lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to release lock for key: {lock_key}")
                return False
                
        except Exception as e:
            print(f"Error releasing lock: {e}")
            return False
    
    def is_locked(self, lock_key: str) -> bool:
        """检查锁状态（主节点）"""
        try:
            return self.master_client.exists(lock_key) > 0
        except Exception as e:
            print(f"Error checking lock status: {e}")
            return False
    
    def close(self):
        """关闭连接"""
        try:
            if self.master_client:
                self.master_client.close()
            
            for client in self.slave_clients:
                client.close()
                
        except Exception as e:
            print(f"Error closing connections: {e}")

class RedisClusterLock:
    """Redis Cluster分布式锁"""
    
    def __init__(self, startup_nodes: List[Dict[str, any]]):
        self.cluster = rediscluster.StrictRedisCluster(
            startup_nodes=startup_nodes, decode_responses=True
        )
    
    def acquire_lock(self, lock_key: str, lock_value: str, 
                    timeout: float = 30.0, lease_duration: float = 10.0) -> bool:
        """获取锁"""
        try:
            expire_time = int(lease_duration)
            result = self.cluster.set(lock_key, lock_value, ex=expire_time, nx=True)
            
            if result:
                print(f"Acquired lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to acquire lock for key: {lock_key}")
                return False
                
        except Exception as e:
            print(f"Error acquiring lock: {e}")
            return False
    
    def release_lock(self, lock_key: str, lock_value: str) -> bool:
        """释放锁"""
        try:
            lua_script = """
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
            """
            
            result = self.cluster.eval(lua_script, 1, lock_key, lock_value)
            
            if result:
                print(f"Released lock for key: {lock_key}")
                return True
            else:
                print(f"Failed to release lock for {lock_key}")
                return False
                
        except Exception as e:
            print(f"Error releasing lock: {e}")
            return False
    
    def close(self):
        """关闭集群连接"""
        try:
            self.cluster.close()
        except Exception as e:
            print(f"Error closing cluster: {e}")

print("=== Redis分布式锁实现完成 ===")
```

## 基于ZooKeeper的分布式锁

```python
import kazoo
from kazoo.client import KazooClient
from kazoo.recipe.lock import Lock
import time
import uuid
from contextlib import contextmanager
from typing import Optional, List

class ZooKeeperLock:
    """基于ZooKeeper的分布式锁"""
    
    def __init__(self, hosts: str = 'localhost:2181', timeout: float = 30.0):
        self.client = KazooClient(hosts=hosts, timeout=timeout)
        self.client.start()
        self.lock_path = "/distributed_locks"
        self.acquired_locks = []
        
        # 确保锁路径存在
        self.client.ensure_path(self.lock_path)
    
    def acquire_lock(self, lock_name: str, timeout: float = 30.0) -> str:
        """获取锁"""
        try:
            # 创建有序临时节点
            lock_node = self.client.create(
                f"{self.lock_path}/{lock_name}_",
                value=b"lock",
                ephemeral=True,
                sequence=True
            )
            
            # 获取所有子节点
            children = self.client.get_children(self.lock_path)
            
            # 过滤出相关锁节点并排序
            lock_nodes = [node for node in children if node.startswith(f"{lock_name}_")]
            lock_nodes.sort()
            
            # 如果当前节点是序号最小的，则获得锁
            if lock_node.split('/')[-1] == lock_nodes[0]:
                lock_id = str(uuid.uuid4())
                self.acquired_locks.append({
                    'lock_name': lock_name,
                    'lock_node': lock_node,
                    'lock_id': lock_id
                })
                
                print(f"Acquired lock for: {lock_name}")
                return lock_id
            else:
                # 监听前一个节点
                current_index = lock_nodes.index(lock_node.split('/')[-1])
                if current_index > 0:
                    previous_node = lock_nodes[current_index - 1]
                    previous_path = f"{self.lock_path}/{previous_node}"
                    
                    @self.client.DataWatch(previous_path)
                    def watch_previous_node(data, stat):
                        # 前一个节点被删除，说明轮到我们了
                        if stat.version == -1:  # 节点被删除
                            return False  # 停止watch
                        return True
                
                # 等待超时时间
                start_time = time.time()
                while time.time() - start_time < timeout:
                    time.sleep(0.1)
                    
                    # 重新检查是否获得锁
                    children = self.client.get_children(self.lock_path)
                    lock_nodes = [node for node in children if node.startswith(f"{lock_name}_")]
                    lock_nodes.sort()
                    
                    if lock_node.split('/')[-1] == lock_nodes[0]:
                        lock_id = str(uuid.uuid4())
                        self.acquired_locks.append({
                            'lock_name': lock_name,
                            'lock_node': lock_node,
                            'lock_id': lock_id
                        })
                        
                        print(f"Acquired lock for: {lock_name}")
                        return lock_id
                
                # 超时，清理节点
                self.client.delete(lock_node)
                print(f"Failed to acquire lock for: {lock_name} (timeout)")
                return None
                
        except Exception as e:
            print(f"Error acquiring lock: {e}")
            return None
    
    def release_lock(self, lock_name: str, lock_id: str) -> bool:
        """释放锁"""
        try:
            # 查找对应的锁
            lock_info = None
            for lock in self.acquired_locks:
                if lock['lock_name'] == lock_name and lock['lock_id'] == lock_id:
                    lock_info = lock
                    break
            
            if not lock_info:
                print(f"Lock not found: {lock_name}")
                return False
            
            # 删除节点
            self.client.delete(lock_info['lock_node'])
            
            # 从本地记录中移除
            self.acquired_locks.remove(lock_info)
            
            print(f"Released lock for: {lock_name}")
            return True
            
        except Exception as e:
            print(f"Error releasing lock: {e}")
            return False
    
    def is_locked(self, lock_name: str) -> bool:
        """检查锁状态"""
        try:
            children = self.client.get_children(self.lock_path)
            lock_nodes = [node for node in children if node.startswith(f"{lock_name}_")]
            return len(lock_nodes) > 0
        except Exception as e:
            print(f"Error checking lock status: {e}")
            return False
    
    def get_lock_info(self, lock_name: str) -> Optional[dict]:
        """获取锁信息"""
        try:
            children = self.client.get_children(self.lock_path)
            lock_nodes = [node for node in children if node.startswith(f"{lock_name}_")]
            lock_nodes.sort()
            
            if lock_nodes:
                current_node = lock_nodes[0]
                node_path = f"{self.lock_path}/{current_node}"
                data, stat = self.client.get(node_path)
                
                return {
                    'lock_name': lock_name,
                    'current_holder': current_node,
                    'queue_length': len(lock_nodes),
                    'created_time': stat.ctime
                }
            else:
                return {'lock_name': lock_name, 'queue_length': 0}
                
        except Exception as e:
            print(f"Error getting lock info: {e}")
            return None
    
    @contextmanager
    def lock(self, lock_name: str, timeout: float = 30.0):
        """锁上下文管理器"""
        lock_id = self.acquire_lock(lock_name, timeout)
        
        if not lock_id:
            raise Exception(f"Failed to acquire lock for: {lock_name}")
        
        try:
            yield lock_id
        finally:
            self.release_lock(lock_name, lock_id)
    
    def execute_with_lock(self, func, lock_name: str, *args, **kwargs):
        """在锁保护下执行函数"""
        with self.lock(lock_name):
            return func(*args, **kwargs)
    
    def cleanup_locks(self):
        """清理所有锁"""
        try:
            children = self.client.get_children(self.lock_path)
            for child in children:
                try:
                    self.client.delete(f"{self.lock_path}/{child}")
                except Exception:
                    pass  # 忽略删除失败
            print("Cleaned up all locks")
        except Exception as e:
            print(f"Error cleaning up locks: {e}")
    
    def close(self):
        """关闭ZooKeeper连接"""
        try:
            self.client.stop()
            self.client.close()
        except Exception as e:
            print(f"Error closing ZooKeeper connection: {e}")

# ZooKeeper锁性能监控
class ZooKeeperLockMonitor:
    """ZooKeeper锁监控"""
    
    def __init__(self, zk_lock: ZooKeeperLock):
        self.zk_lock = zk_lock
        self.metrics = {
            'acquire_attempts': 0,
            'acquire_success': 0,
            'acquire_failures': 0,
            'release_attempts': 0,
            'release_success': 0,
            'release_failures': 0,
            'total_acquire_time': 0.0
        }
    
    def monitor_acquire(self, lock_name: str, timeout: float) -> str:
        """监控获取锁"""
        start_time = time.time()
        self.metrics['acquire_attempts'] += 1
        
        lock_id = self.zk_lock.acquire_lock(lock_name, timeout)
        
        acquire_time = time.time() - start_time
        self.metrics['total_acquire_time'] += acquire_time
        
        if lock_id:
            self.metrics['acquire_success'] += 1
        else:
            self.metrics['acquire_failures'] += 1
        
        return lock_id
    
    def monitor_release(self, lock_name: str, lock_id: str) -> bool:
        """监控释放锁"""
        self.metrics['release_attempts'] += 1
        
        result = self.zk_lock.release_lock(lock_name, lock_id)
        
        if result:
            self.metrics['release_success'] += 1
        else:
            self.metrics['release_failures'] += 1
        
        return result
    
    def get_performance_metrics(self) -> dict:
        """获取性能指标"""
        if self.metrics['acquire_success'] > 0:
            avg_acquire_time = self.metrics['total_acquire_time'] / self.metrics['acquire_success']
        else:
            avg_acquire_time = 0
        
        acquire_rate = (
            self.metrics['acquire_success'] / 
            max(1, self.metrics['acquire_attempts']) * 100
        )
        
        release_rate = (
            self.metrics['release_success'] / 
            max(1, self.metrics['release_attempts']) * 100
        )
        
        return {
            'acquire_rate': f"{acquire_rate:.1f}%",
            'release_rate': f"{release_rate:.1f}%",
            'avg_acquire_time': f"{avg_acquire_time:.3f}s",
            'total_acquires': self.metrics['acquire_attempts'],
            'total_releases': self.metrics['release_attempts']
        }
    
    def print_metrics(self):
        """打印指标"""
        metrics = self.get_performance_metrics()
        print("=== ZooKeeper Lock Metrics ===")
        for key, value in metrics.items():
            print(f"{key}: {value}")

print("=== ZooKeeper分布式锁实现完成 ===")
```

## 分布式锁对比分析

```python
class DistributedLockComparison:
    """分布式锁对比分析"""
    
    def __init__(self):
        self.comparisons = {
            'database': {
                'implementation_complexity': '低',
                'reliability': '中等',
                'performance': '中等',
                'scalability': '中等',
                'persistence': '强',
                'failure_recovery': '好',
                'monitoring': '好',
                'use_cases': ['小规模应用', '已有数据库'],
                'advantages': [
                    '依赖现有数据库，无需额外组件',
                    '支持事务特性',
                    '持久化存储',
                    '易于监控和管理'
                ],
                'disadvantages': [
                    '性能相对较低',
                    '数据库连接开销',
                    '可能成为单点故障',
                    '扩展性有限'
                ]
            },
            'redis': {
                'implementation_complexity': '低',
                'reliability': '高',
                'performance': '高',
                'scalability': '高',
                'persistence': '中等',
                'failure_recovery': '好',
                'monitoring': '好',
                'use_cases': ['高并发场景', '缓存应用', '微服务'],
                'advantages': [
                    '高性能',
                    '简单易用',
                    '支持集群模式',
                    '丰富的数据类型',
                    '支持发布订阅'
                ],
                'disadvantages': [
                    '单线程模式',
                    '持久化配置复杂',
                    '内存使用',
                    '主从切换可能丢失锁'
                ]
            },
            'zookeeper': {
                'implementation_complexity': '高',
                'reliability': '极高',
                'performance': '中等',
                'scalability': '高',
                'persistence': '强',
                'failure_recovery': '极佳',
                'monitoring': '好',
                'use_cases': ['分布式协调', '配置管理', '服务发现'],
                'advantages': [
                    '高可靠性',
                    '强一致性',
                    '临时节点自动清理',
                    '顺序节点支持',
                    '丰富的监听机制'
                ],
                'disadvantages': [
                    '部署复杂',
                    '性能相对较低',
                    '学习成本高',
                    '资源消耗大'
                ]
            },
            'consul': {
                'implementation_complexity': '中等',
                'reliability': '高',
                'performance': '中等',
                'scalability': '高',
                'persistence': '强',
                'failure_recovery': '好',
                'monitoring': '好',
                'use_cases': ['微服务架构', '服务发现', '配置管理'],
                'advantages': [
                    '服务发现集成',
                    '健康检查',
                    'KV存储',
                    '支持ACL',
                    'HTTP API'
                ],
                'disadvantages': [
                    '相对较新',
                    '社区较小',
                    '配置复杂',
                    '内存使用'
                ]
            }
        }
    
    def compare_feature(self, feature: str) -> dict:
        """对比特定特性"""
        return {name: details[feature] for name, details in self.comparisons.items()}
    
    def recommend_by_scenario(self, scenario: str) -> List[str]:
        """根据场景推荐"""
        recommendations = {
            'high_performance': ['redis'],
            'high_reliability': ['zookeeper'],
            'simple_deployment': ['database', 'redis'],
            'service_discovery': ['consul', 'zookeeper'],
            'micro_services': ['redis', 'consul'],
            'existing_infrastructure': ['database'],
            'complex_coordination': ['zookeeper'],
            'high_throughput': ['redis']
        }
        return recommendations.get(scenario, [])
    
    def print_comparison_table(self):
        """打印对比表格"""
        print("=== 分布式锁对比 ===\n")
        
        features = [
            'implementation_complexity', 'reliability', 'performance', 
            'scalability', 'failure_recovery'
        ]
        
        print(f"{'特性':<20} {'数据库':<15} {'Redis':<15} {'ZooKeeper':<15} {'Consul':<15}")
        print("-" * 80)
        
        for feature in features:
            row = f"{feature:<20}"
            for mq in ['database', 'redis', 'zookeeper', 'consul']:
                row += f"{self.comparisons[mq][feature]:<15}"
            print(row)
    
    def print_use_case_recommendations(self):
        """打印使用场景推荐"""
        print("\n=== 使用场景推荐 ===")
        
        scenarios = [
            'high_performance', 'high_reliability', 'simple_deployment', 
            'micro_services', 'service_discovery'
        ]
        
        for scenario in scenarios:
            recommended = self.recommend_by_scenario(scenario)
            print(f"{scenario}: {', '.join(recommended)}")

# 性能测试工具
class LockPerformanceBenchmark:
    """锁性能基准测试"""
    
    def __init__(self, lock_manager, benchmark_name: str):
        self.lock_manager = lock_manager
        self.benchmark_name = benchmark_name
        self.results = {}
    
    def benchmark_concurrent_access(self, lock_key: str, thread_count: int = 10, 
                                  operations_per_thread: int = 100) -> dict:
        """测试并发访问性能"""
        import concurrent.futures
        import threading
        
        print(f"=== 并发访问性能测试: {thread_count}线程, {operations_per_thread}操作/线程 ===")
        
        results = {
            'total_operations': thread_count * operations_per_thread,
            'successful_operations': 0,
            'failed_operations': 0,
            'total_time': 0.0,
            'operations_per_second': 0.0,
            'avg_operation_time': 0.0,
            'min_operation_time': float('inf'),
            'max_operation_time': 0.0,
            'thread_timings': []
        }
        
        def worker_operation(worker_id: int):
            """工作线程"""
            thread_results = {
                'worker_id': worker_id,
                'successful': 0,
                'failed': 0,
                'timings': []
            }
            
            for i in range(operations_per_thread):
                start_time = time.time()
                
                try:
                    # 获取锁并执行操作
                    with self.lock_manager.lock(lock_key):
                        time.sleep(0.001)  # 模拟业务处理
                    
                    operation_time = time.time() - start_time
                    thread_results['timings'].append(operation_time)
                    thread_results['successful'] += 1
                    
                except Exception as e:
                    operation_time = time.time() - start_time
                    thread_results['timings'].append(operation_time)
                    thread_results['failed'] += 1
                    print(f"Worker {worker_id} operation {i} failed: {e}")
            
            return thread_results
        
        # 执行并发测试
        start_time = time.time()
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=thread_count) as executor:
            futures = [executor.submit(worker_operation, i) for i in range(thread_count)]
            
            for future in concurrent.futures.as_completed(futures):
                thread_result = future.result()
                results['successful_operations'] += thread_result['successful']
                results['failed_operations'] += thread_result['failed']
                results['thread_timings'].extend(thread_result['timings'])
        
        total_time = time.time() - start_time
        
        # 计算统计指标
        results['total_time'] = total_time
        results['operations_per_second'] = results['successful_operations'] / total_time
        
        if results['thread_timings']:
            results['avg_operation_time'] = sum(results['thread_timings']) / len(results['thread_timings'])
            results['min_operation_time'] = min(results['thread_timings'])
            results['max_operation_time'] = max(results['thread_timings'])
        
        return results
    
    def benchmark_lock_contention(self, lock_key: str, contention_level: int = 5) -> dict:
        """测试锁竞争性能"""
        print(f"=== 锁竞争测试: {contention_level}个并发锁请求 ===")
        
        lock_requests = []
        
        def request_lock(request_id: int):
            """请求锁"""
            start_time = time.time()
            lock_id = self.lock_manager.acquire_lock(lock_key, timeout=5.0)
            acquire_time = time.time() - start_time
            
            if lock_id:
                # 持有锁时间
                hold_start = time.time()
                time.sleep(0.1)  # 模拟业务处理
                hold_time = time.time() - hold_start
                
                # 释放锁
                release_start = time.time()
                self.lock_manager.release_lock(lock_key, lock_id)
                release_time = time.time() - release_start
                
                total_time = time.time() - start_time
                
                return {
                    'request_id': request_id,
                    'status': 'success',
                    'acquire_time': acquire_time,
                    'hold_time': hold_time,
                    'release_time': release_time,
                    'total_time': total_time
                }
            else:
                total_time = time.time() - start_time
                return {
                    'request_id': request_id,
                    'status': 'timeout',
                    'acquire_time': total_time,
                    'hold_time': 0,
                    'release_time': 0,
                    'total_time': total_time
                }
        
        # 并发请求锁
        import concurrent.futures
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=contention_level) as executor:
            futures = [executor.submit(request_lock, i) for i in range(contention_level)]
            
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                lock_requests.append(result)
        
        # 分析结果
        successful_requests = [r for r in lock_requests if r['status'] == 'success']
        failed_requests = [r for r in lock_requests if r['status'] == 'timeout']
        
        return {
            'total_requests': contention_level,
            'successful_requests': len(successful_requests),
            'failed_requests': len(failed_requests),
            'success_rate': len(successful_requests) / contention_level * 100,
            'avg_acquire_time': sum(r['acquire_time'] for r in successful_requests) / max(1, len(successful_requests)),
            'avg_hold_time': sum(r['hold_time'] for r in successful_requests) / max(1, len(successful_requests)),
            'requests': lock_requests
        }
    
    def print_results(self, results: dict):
        """打印测试结果"""
        print(f"\n--- 测试结果 ({self.benchmark_name}) ---")
        
        for key, value in results.items():
            if key == 'requests':
                continue
            elif key == 'thread_timings':
                continue
            elif isinstance(value, float):
                print(f"{key}: {value:.3f}")
            else:
                print(f"{key}: {value}")

# 使用示例
def demo_lock_comparison():
    """分布式锁对比演示"""
    comparison = DistributedLockComparison()
    
    # 显示对比表
    comparison.print_comparison_table()
    comparison.print_use_case_recommendations()
    
    print("\n=== 选择指南 ===")
    print("数据库锁: 适合已有数据库基础设施的小型应用")
    print("Redis锁: 适合高并发、高性能要求的应用")
    print("ZooKeeper锁: 适合要求极高可靠性的分布式系统")
    print("Consul锁: 适合微服务架构和服务发现")

if __name__ == "__main__":
    demo_lock_comparison()
```

## 实际应用案例

```python
class InventoryManagement:
    """库存管理系统"""
    
    def __init__(self, lock_manager):
        self.lock_manager = lock_manager
        self.inventory = {}
    
    def deduct_stock(self, product_id: str, quantity: int, user_id: str) -> bool:
        """扣减库存"""
        lock_key = f"inventory:{product_id}"
        
        try:
            with self.lock_manager.lock(lock_key, timeout=10.0, lease_duration=5.0):
                current_stock = self.inventory.get(product_id, 100)  # 默认100库存
                
                if current_stock >= quantity:
                    # 模拟库存扣减
                    time.sleep(0.1)  # 模拟数据库操作
                    
                    self.inventory[product_id] = current_stock - quantity
                    print(f"User {user_id} deducted {quantity} from product {product_id}. "
                          f"Remaining: {self.inventory[product_id]}")
                    return True
                else:
                    print(f"Insufficient stock for product {product_id}. "
                          f"Available: {current_stock}, Requested: {quantity}")
                    return False
                    
        except Exception as e:
            print(f"Stock deduction failed: {e}")
            return False
    
    def get_stock(self, product_id: str) -> int:
        """获取库存"""
        return self.inventory.get(product_id, 100)

class ScheduledTaskManager:
    """定时任务管理器"""
    
    def __init__(self, lock_manager):
        self.lock_manager = lock_manager
        self.running_tasks = {}
    
    def execute_scheduled_task(self, task_name: str, task_func, schedule_interval: float = 60.0):
        """执行定时任务（只有一个节点执行）"""
        lock_key = f"scheduled_task:{task_name}"
        
        try:
            with self.lock_manager.lock(lock_key, timeout=30.0, lease_duration=schedule_interval / 2):
                print(f"Executing scheduled task: {task_name}")
                result = task_func()
                print(f"Task {task_name} completed: {result}")
                return result
                
        except Exception as e:
            print(f"Scheduled task {task_name} failed: {e}")
            return None
    
    def start_task_scheduler(self, task_name: str, task_func, interval: float = 30.0):
        """启动任务调度器"""
        def scheduler_loop():
            while True:
                try:
                    self.execute_scheduled_task(task_name, task_func, interval)
                    time.sleep(interval)
                except KeyboardInterrupt:
                    print(f"Scheduler for {task_name} stopped")
                    break
                except Exception as e:
                    print(f"Scheduler error: {e}")
                    time.sleep(5)
        
        import threading
        scheduler_thread = threading.Thread(target=scheduler_loop, daemon=True)
        scheduler_thread.start()
        
        self.running_tasks[task_name] = scheduler_thread
        print(f"Started scheduler for task: {task_name}")

class FileProcessingService:
    """文件处理服务"""
    
    def __init__(self, lock_manager):
        self.lock_manager = lock_manager
        self.processing_files = set()
    
    def process_file(self, file_path: str, processor_func):
        """处理文件"""
        lock_key = f"file_processing:{file_path}"
        
        try:
            with self.lock_manager.lock(lock_key, timeout=60.0, lease_duration=30.0):
                if file_path in self.processing_files:
                    print(f"File {file_path} is already being processed")
                    return False
                
                self.processing_files.add(file_path)
                
                print(f"Starting to process file: {file_path}")
                result = processor_func(file_path)
                
                print(f"Completed processing file: {file_path}")
                self.processing_files.remove(file_path)
                
                return result
                
        except Exception as e:
            print(f"File processing failed: {e}")
            self.processing_files.discard(file_path)
            return None

# 应用场景演示
def demo_application_scenarios():
    """演示应用场景"""
    
    # 创建锁管理器（这里使用Redis锁作为示例）
    lock_manager = RedisDistributedLock()
    
    print("=== 1. 库存管理演示 ===")
    inventory = InventoryManagement(lock_manager)
    
    # 模拟多个用户并发扣减库存
    import concurrent.futures
    
    def user_purchase(user_id: int, product_id: str, quantity: int):
        return inventory.deduct_stock(product_id, quantity, f"user_{user_id}")
    
    # 10个用户同时购买同一商品
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        futures = [
            executor.submit(user_purchase, i, "product_001", 1) 
            for i in range(10)
        ]
        
        for future in concurrent.futures.as_completed(futures):
            try:
                result = future.result()
            except Exception as e:
                print(f"Purchase failed: {e}")
    
    final_stock = inventory.get_stock("product_001")
    print(f"Final stock for product_001: {final_stock}")
    
    print("\n=== 2. 定时任务演示 ===")
    task_manager = ScheduledTaskManager(lock_manager)
    
    def daily_report_task():
        """日报生成任务"""
        print(f"Generating daily report at {time.strftime('%Y-%m-%d %H:%M:%S')}")
        return "Report generated successfully"
    
    # 启动定时任务
    task_manager.start_task_scheduler("daily_report", daily_report_task, 5.0)
    
    # 等待几秒观察任务执行
    time.sleep(12)
    
    print("\n=== 3. 文件处理演示 ===")
    file_service = FileProcessingService(lock_manager)
    
    def simple_file_processor(file_path: str):
        """简单文件处理器"""
        # 模拟文件处理
        time.sleep(2)
        return f"Processed {file_path}"
    
    # 模拟多个进程处理不同文件
    files_to_process = ["file1.txt", "file2.txt", "file1.txt"]  # file1会被串行化
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
        futures = [
            executor.submit(file_service.process_file, file_path, simple_file_processor)
            for file_path in files_to_process
        ]
        
        for future in concurrent.futures.as_completed(futures):
            try:
                result = future.result()
                if result:
                    print(f"File processing result: {result}")
            except Exception as e:
                print(f"File processing failed: {e}")
    
    print("\n=== 应用演示完成 ===")
    
    lock_manager.close()

if __name__ == "__main__":
    demo_application_scenarios()
```

## 最佳实践

```python
class DistributedLockBestPractices:
    """分布式锁最佳实践"""
    
    def __init__(self):
        self.best_practices = {
            'idempotency': {
                'title': '幂等性设计',
                'description': '确保重复操作不会产生副作用',
                'examples': [
                    '使用唯一业务标识作为锁标识',
                    '在业务流程中检查前置状态',
                    '使用乐观锁机制',
                    '记录操作日志便于恢复'
                ],
                'code_example': '''
# 幂等性锁设计
class IdempotentDistributedLock:
    def process_order_with_lock(self, order_id: str, amount: float):
        # 生成幂等键
        idempotency_key = f"order_processing_{order_id}"
        
        # 检查是否已处理
        if self.is_already_processed(idempotency_key):
            return "Already processed"
        
        try:
            # 获取锁
            with self.lock_manager.lock(idempotency_key, timeout=30.0):
                # 再次检查状态（双重检查）
                if self.is_already_processed(idempotency_key):
                    return "Already processed"
                
                # 执行处理逻辑
                result = self.execute_order_processing(order_id, amount)
                
                # 标记为已处理
                self.mark_as_processed(idempotency_key)
                
                return result
                
        except Exception as e:
            # 处理异常，但不影响幂等性
            return f"Error: {e}"
                '''
            },
            'timeout_management': {
                'title': '超时管理',
                'description': '合理设置超时时间避免死锁',
                'examples': [
                    '业务操作时间的3-5倍作为锁超时时间',
                    '实现续租机制保持锁有效',
                    '监控锁持有时间过长的情况',
                    '实现锁自动过期机制'
                ],
                'code_example': '''
# 超时管理示例
class TimeoutManagedLock:
    def __init__(self):
        self.lock_manager = RedisDistributedLock()
        self.heartbeat_interval = 30  # 30秒心跳
        self.lock_renewal_task = None
    
    def acquire_with_timeout_management(self, lock_key: str, business_timeout: float):
        # 设置租约时间为业务超时的一半
        lease_duration = business_timeout / 2
        
        lock_id = self.lock_manager.acquire_lock(
            lock_key, lease_duration=lease_duration
        )
        
        if lock_id:
            # 启动续租任务
            self.start_renewal_task(lock_key, lock_id, lease_duration)
        
        return lock_id
    
    def start_renewal_task(self, lock_key: str, lock_id: str, lease_duration: float):
        def renewal_loop():
            while True:
                time.sleep(lease_duration * 0.8)  # 80%时间续租
                if not self.lock_manager.renew_lock(lock_key, lock_id, lease_duration):
                    break
        
        renewal_thread = threading.Thread(target=renewal_loop, daemon=True)
        renewal_thread.start()
                '''
            },
            'monitoring': {
                'title': '监控和告警',
                'description': '全面监控锁的使用情况',
                'examples': [
                    '监控锁获取成功率和延迟',
                    '告警锁超时和死锁情况',
                    '跟踪锁持有时间分布',
                    '监控锁服务健康状态'
                ],
                'code_example': '''
# 锁监控示例
class LockMonitor:
    def __init__(self):
        self.metrics = {
            'acquire_attempts': 0,
            'acquire_success': 0,
            'acquire_failures': 0,
            'acquire_latencies': [],
            'active_locks': set(),
            'lock_hold_times': []
        }
    
    def track_acquire(self, lock_key: str, start_time: float, success: bool):
        self.metrics['acquire_attempts'] += 1
        if success:
            self.metrics['acquire_success'] += 1
            self.metrics['active_locks'].add(lock_key)
        else:
            self.metrics['acquire_failures'] += 1
        
        latency = time.time() - start_time
        self.metrics['acquire_latencies'].append(latency)
        
        # 定期清理指标
        if len(self.metrics['acquire_latencies']) > 1000:
            self.metrics['acquire_latencies'] = self.metrics['acquire_latencies'][-500:]
    
    def check_health(self):
        if self.metrics['acquire_attempts'] > 0:
            success_rate = self.metrics['acquire_success'] / self.metrics['acquire_attempts']
            avg_latency = sum(self.metrics['acquire_latencies']) / len(self.metrics['acquire_latencies'])
            
            # 告警条件
            if success_rate < 0.95:
                print(f"WARNING: Lock success rate too low: {success_rate:.2%}")
            
            if avg_latency > 1.0:
                print(f"WARNING: Lock acquire latency too high: {avg_latency:.2f}s")
            
            if len(self.metrics['active_locks']) > 100:
                print(f"WARNING: Too many active locks: {len(self.metrics['active_locks'])}")
                '''
            },
            'circuit_breaker': {
                'title': '熔断器模式',
                'description': '在锁服务异常时提供降级方案',
                'examples': [
                    '检测锁服务可用性',
                    '在故障时禁用锁机制',
                    '实现重试和回退机制',
                    '使用本地锁作为兜底'
                ],
                'code_example': '''
# 熔断器锁
class CircuitBreakerLock:
    def __init__(self, lock_manager):
        self.lock_manager = lock_manager
        self.circuit_state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.failure_count = 0
        self.failure_threshold = 5
        self.recovery_timeout = 30
        self.last_failure_time = 0
    
    def acquire_lock_with_circuit_breaker(self, lock_key: str, **kwargs):
        if self.circuit_state == 'OPEN':
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.circuit_state = 'HALF_OPEN'
            else:
                return self.fallback_acquire(lock_key)
        
        try:
            result = self.lock_manager.acquire_lock(lock_key, **kwargs)
            
            if result:
                self.reset_failure_count()
                return result
            else:
                self.increment_failure_count()
                return None
                
        except Exception as e:
            self.increment_failure_count()
            return self.fallback_acquire(lock_key)
    
    def fallback_acquire(self, lock_key: str):
        # 使用本地锁作为兜底
        print("Using fallback local lock")
        return f"local_lock_{int(time.time())}"
    
    def increment_failure_count(self):
        self.failure_count += 1
        if self.failure_count >= self.failure_threshold:
            self.circuit_state = 'OPEN'
            self.last_failure_time = time.time()
    
    def reset_failure_count(self):
        self.failure_count = 0
        self.circuit_state = 'CLOSED'
                '''
            }
        }
    
    def print_best_practices(self):
        """打印最佳实践"""
        print("=== 分布式锁最佳实践 ===\n")
        
        for key, practice in self.best_practices.items():
            print(f"{practice['title']}")
            print(f"{'='*len(practice['title'])}")
            print(f"{practice['description']}\n")
            
            print("实践要点:")
            for i, example in enumerate(practice['examples'], 1):
                print(f"  {i}. {example}")
            
            print("\n代码示例:")
            print(practice['code_example'])
            print("\n" + "="*50 + "\n")

# 安全注意事项
class DistributedLockSecurity:
    """分布式锁安全注意事项"""
    
    def __init__(self):
        self.security_considerations = [
            {
                'issue': '锁标识泄露',