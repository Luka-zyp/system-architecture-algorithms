# 设计模式实战案例

## 概述

本文档通过实际的项目案例，展示如何在真实的系统架构中应用设计模式解决具体的业务问题。每个案例都包含业务背景、问题分析、设计模式选择、具体实现和效果评估。

## 电商系统订单处理系统

### 业务背景

在电商系统中，订单处理是一个核心业务流程，涉及库存扣减、支付处理、物流安排、通知发送等多个环节。需要支持多种支付方式、不同类型的商品、复杂的优惠策略，并且要求高可靠性和性能。

### 核心问题

1. **订单状态管理复杂**：订单从创建到完成需要经过多个状态转换
2. **支付方式多样化**：信用卡、支付宝、微信支付、货到付款等
3. **促销策略复杂**：满减、折扣、积分、优惠券等
4. **系统集成复杂**：需要与库存、支付、物流、用户服务等多个系统集成

### 设计模式选择

- **状态模式**：管理订单状态转换
- **策略模式**：处理不同支付方式
- **装饰器模式**：实现促销策略叠加
- **观察者模式**：处理订单事件通知
- **命令模式**：封装订单操作
- **工厂模式**：创建不同类型的订单处理器

### 实现代码

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
import asyncio
import time
from enum import Enum
import logging

# 订单状态枚举
class OrderStatus(Enum):
    CREATED = "created"
    CONFIRMED = "confirmed"
    PAID = "paid"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    REFUNDED = "refunded"

# 订单事件枚举
class OrderEvent(Enum):
    ORDER_CREATED = "order_created"
    ORDER_CONFIRMED = "order_confirmed"
    PAYMENT_SUCCESSFUL = "payment_successful"
    PAYMENT_FAILED = "payment_failed"
    INVENTORY_RESERVED = "inventory_reserved"
    INVENTORY_SHORTAGE = "inventory_shortage"
    SHIPPING_SCHEDULED = "shipping_scheduled"
    ORDER_DELIVERED = "order_delivered"
    ORDER_COMPLETED = "order_completed"
    ORDER_CANCELLED = "order_cancelled"
    REFUND_PROCESSED = "refund_processed"

# 订单状态上下文
class OrderContext:
    def __init__(self, order_id: str, total_amount: float):
        self.order_id = order_id
        self.total_amount = total_amount
        self.items = []
        self.promotions = []
        self.payment_info = {}
        self.shipping_info = {}
        self.status_history = []
        self.created_at = time.time()
    
    def add_item(self, item: Dict[str, Any]):
        """添加订单项"""
        self.items.append(item)
    
    def add_promotion(self, promotion: Dict[str, Any]):
        """添加促销信息"""
        self.promotions.append(promotion)
    
    def set_payment_info(self, payment_info: Dict[str, Any]):
        """设置支付信息"""
        self.payment_info = payment_info
    
    def set_shipping_info(self, shipping_info: Dict[str, Any]):
        """设置配送信息"""
        self.shipping_info = shipping_info
    
    def get_current_amount(self) -> float:
        """计算当前订单金额（考虑促销）"""
        base_amount = self.total_amount
        
        # 应用促销策略
        for promotion in self.promotions:
            if promotion['type'] == 'discount':
                base_amount *= (1 - promotion['value'])
            elif promotion['type'] == 'fixed_amount':
                base_amount -= promotion['value']
        
        return max(0, base_amount)

# 订单状态抽象
class OrderState(ABC):
    @abstractmethod
    def confirm(self, context: OrderContext) -> bool:
        """确认订单"""
        pass
    
    @abstractmethod
    def pay(self, context: OrderContext) -> bool:
        """支付订单"""
        pass
    
    @abstractmethod
    def ship(self, context: OrderContext) -> bool:
        """发货"""
        pass
    
    @abstractmethod
    def deliver(self, context: OrderContext) -> bool:
        """送达"""
        pass
    
    @abstractmethod
    def complete(self, context: OrderContext) -> bool:
        """完成订单"""
        pass
    
    @abstractmethod
    def cancel(self, context: OrderContext) -> bool:
        """取消订单"""
        pass
    
    @abstractmethod
    def refund(self, context: OrderContext) -> bool:
        """退款"""
        pass

# 已创建状态
class CreatedState(OrderState):
    def confirm(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.CONFIRMED,
            'timestamp': time.time(),
            'action': 'confirm'
        })
        print(f"订单 {context.order_id} 已确认")
        return True
    
    def pay(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先确认才能支付")
        return False
    
    def ship(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先支付才能发货")
        return False
    
    def deliver(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先发货才能送达")
        return False
    
    def complete(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先送达才能完成")
        return False
    
    def cancel(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.CANCELLED,
            'timestamp': time.time(),
            'action': 'cancel'
        })
        print(f"订单 {context.order_id} 已取消")
        return True
    
    def refund(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 未支付，无法退款")
        return False

# 已确认状态
class ConfirmedState(OrderState):
    def confirm(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 已经确认")
        return False
    
    def pay(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.PAID,
            'timestamp': time.time(),
            'action': 'pay'
        })
        print(f"订单 {context.order_id} 支付成功")
        return True
    
    def ship(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先支付才能发货")
        return False
    
    def deliver(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先发货才能送达")
        return False
    
    def complete(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先送达才能完成")
        return False
    
    def cancel(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.CANCELLED,
            'timestamp': time.time(),
            'action': 'cancel'
        })
        print(f"订单 {context.order_id} 已取消")
        return True
    
    def refund(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 未支付，无法退款")
        return False

# 已支付状态
class PaidState(OrderState):
    def confirm(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 已经确认")
        return False
    
    def pay(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 已经支付")
        return False
    
    def ship(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.SHIPPED,
            'timestamp': time.time(),
            'action': 'ship'
        })
        print(f"订单 {context.order_id} 已发货")
        return True
    
    def deliver(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先发货才能送达")
        return False
    
    def complete(self, context: OrderContext) -> bool:
        print(f"订单 {context.order_id} 必须先送达才能完成")
        return False
    
    def cancel(self, context: OrderContext) -> bool:
        # 已支付的订单取消需要走退款流程
        context.status_history.append({
            'status': OrderStatus.REFUNDED,
            'timestamp': time.time(),
            'action': 'refund'
        })
        print(f"订单 {context.order_id} 已退款取消")
        return True
    
    def refund(self, context: OrderContext) -> bool:
        context.status_history.append({
            'status': OrderStatus.REFUNDED,
            'timestamp': time.time(),
            'action': 'refund'
        })
        print(f"订单 {context.order_id} 退款成功")
        return True

# 订单管理器
class OrderManager:
    def __init__(self):
        self.orders = {}
        self.state_factories = {
            OrderStatus.CREATED: CreatedState,
            OrderStatus.CONFIRMED: ConfirmedState,
            OrderStatus.PAID: PaidState
        }
    
    def create_order(self, order_id: str, total_amount: float) -> OrderContext:
        """创建订单"""
        context = OrderContext(order_id, total_amount)
        self.orders[order_id] = context
        context.status_history.append({
            'status': OrderStatus.CREATED,
            'timestamp': time.time(),
            'action': 'create'
        })
        print(f"订单 {order_id} 创建成功")
        return context
    
    def get_order(self, order_id: str) -> Optional[OrderContext]:
        """获取订单"""
        return self.orders.get(order_id)
    
    def execute_action(self, order_id: str, action: str, **kwargs) -> bool:
        """执行订单动作"""
        order = self.get_order(order_id)
        if not order:
            print(f"订单 {order_id} 不存在")
            return False
        
        # 获取当前状态
        current_status = order.status_history[-1]['status'] if order.status_history else OrderStatus.CREATED
        state_factory = self.state_factories.get(current_status, CreatedState)
        state = state_factory()
        
        # 执行对应的动作
        if action == 'confirm':
            return state.confirm(order)
        elif action == 'pay':
            return state.pay(order)
        elif action == 'ship':
            return state.ship(order)
        elif action == 'deliver':
            return state.deliver(order)
        elif action == 'complete':
            return state.complete(order)
        elif action == 'cancel':
            return state.cancel(order)
        elif action == 'refund':
            return state.refund(order)
        else:
            print(f"未知动作: {action}")
            return False
```

## 支付系统架构案例

### 业务背景

支付系统需要支持多种支付方式（信用卡、第三方支付、数字货币等），每种支付方式有不同的安全要求、费用结构和处理流程。系统需要高安全性、高可用性和强一致性。

### 核心问题

1. **支付方式多样化**：需要适配不同支付提供商的API
2. **安全要求严格**：需要加密、签名、风险控制
3. **事务一致性**：支付涉及资金转移，必须保证原子性
4. **高可用性**：支付失败会影响用户体验和业务收入

### 设计模式选择

- **策略模式**：处理不同支付方式
- **工厂模式**：创建支付处理器
- **装饰器模式**：添加安全控制和监控
- **观察者模式**：处理支付事件
- **单例模式**：支付配置管理
- **适配器模式**：适配第三方支付接口

### 实现代码

```python
# 支付接口抽象
class PaymentProcessor(ABC):
    @abstractmethod
    async def process_payment(self, payment_request: Dict[str, Any]) -> Dict[str, Any]:
        """处理支付"""
        pass
    
    @abstractmethod
    async def refund_payment(self, refund_request: Dict[str, Any]) -> Dict[str, Any]:
        """处理退款"""
        pass
    
    @abstractmethod
    def validate_payment(self, payment_request: Dict[str, Any]) -> bool:
        """验证支付请求"""
        pass

# 支付请求
class PaymentRequest:
    def __init__(self, order_id: str, amount: float, currency: str, payment_method: str, user_info: Dict):
        self.order_id = order_id
        self.amount = amount
        self.currency = currency
        self.payment_method = payment_method
        self.user_info = user_info
        self.timestamp = time.time()
        self.request_id = f"req_{int(self.timestamp * 1000000)}"

# 信用卡支付处理器
class CreditCardProcessor(PaymentProcessor):
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.api_key = config.get('api_key')
        self.secret_key = config.get('secret_key')
    
    async def process_payment(self, payment_request: PaymentRequest) -> Dict[str, Any]:
        print(f"处理信用卡支付: {payment_request.request_id}")
        
        # 模拟支付处理
        await asyncio.sleep(0.5)
        
        if payment_request.amount > 0:
            result = {
                'success': True,
                'transaction_id': f"cc_txn_{int(time.time())}",
                'amount': payment_request.amount,
                'currency': payment_request.currency,
                'timestamp': time.time()
            }
            print(f"信用卡支付成功: {result['transaction_id']}")
            return result
        else:
            raise Exception("支付金额必须大于0")
    
    async def refund_payment(self, refund_request: Dict[str, Any]) -> Dict[str, Any]:
        print(f"处理信用卡退款: {refund_request.get('transaction_id')}")
        await asyncio.sleep(0.3)
        
        return {
            'success': True,
            'refund_id': f"cc_ref_{int(time.time())}",
            'amount': refund_request['amount'],
            'timestamp': time.time()
        }
    
    def validate_payment(self, payment_request: PaymentRequest) -> bool:
        # 简单的验证逻辑
        return (payment_request.amount > 0 and 
                payment_request.currency in ['USD', 'EUR', 'CNY'] and
                'card_number' in payment_request.user_info)

# 支付宝支付处理器
class AlipayProcessor(PaymentProcessor):
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.app_id = config.get('app_id')
        self.private_key = config.get('private_key')
    
    async def process_payment(self, payment_request: PaymentRequest) -> Dict[str, Any]:
        print(f"处理支付宝支付: {payment_request.request_id}")
        
        await asyncio.sleep(0.4)
        
        if payment_request.amount > 0:
            result = {
                'success': True,
                'transaction_id': f"alipay_txn_{int(time.time())}",
                'qr_code': f"https://qr.alipay.com/{int(time.time())}",
                'amount': payment_request.amount,
                'currency': payment_request.currency,
                'timestamp': time.time()
            }
            print(f"支付宝支付创建成功: {result['transaction_id']}")
            return result
        else:
            raise Exception("支付金额必须大于0")
    
    async def refund_payment(self, refund_request: Dict[str, Any]) -> Dict[str, Any]:
        print(f"处理支付宝退款: {refund_request.get('transaction_id')}")
        await asyncio.sleep(0.2)
        
        return {
            'success': True,
            'refund_id': f"alipay_ref_{int(time.time())}",
            'amount': refund_request['amount'],
            'timestamp': time.time()
        }
    
    def validate_payment(self, payment_request: PaymentRequest) -> bool:
        return (payment_request.amount > 0 and 
                'user_id' in payment_request.user_info)

# 支付策略工厂
class PaymentStrategyFactory:
    _strategies = {
        'credit_card': CreditCardProcessor,
        'alipay': AlipayProcessor,
        'wechat_pay': lambda config: AlipayProcessor(config)  # 示例，实际应该是不同的类
    }
    
    @classmethod
    def create_strategy(cls, payment_method: str, config: Dict[str, Any]) -> PaymentProcessor:
        if payment_method not in cls._strategies:
            raise ValueError(f"不支持的支付方式: {payment_method}")
        
        strategy_class = cls._strategies[payment_method]
        return strategy_class(config)
    
    @classmethod
    def register_strategy(cls, payment_method: str, strategy_class: type):
        cls._strategies[payment_method] = strategy_class

# 支付服务 - 使用装饰器模式添加安全控制
class SecurePaymentDecorator(PaymentProcessor):
    def __init__(self, wrapped_processor: PaymentProcessor, security_config: Dict[str, Any]):
        self.wrapped_processor = wrapped_processor
        self.security_config = security_config
        self.encryption_key = security_config.get('encryption_key')
        self.risk_threshold = security_config.get('risk_threshold', 1000)
    
    async def process_payment(self, payment_request: PaymentRequest) -> Dict[str, Any]:
        # 风险评估
        risk_score = self._assess_risk(payment_request)
        print(f"风险评估得分: {risk_score}")
        
        if risk_score > self.risk_threshold:
            raise Exception(f"风险评估过高: {risk_score}")
        
        # 加密敏感信息
        encrypted_request = self._encrypt_payment_request(payment_request)
        
        # 执行支付
        result = await self.wrapped_processor.process_payment(encrypted_request)
        
        # 记录安全日志
        self._log_security_event(payment_request, result)
        
        return result
    
    async def refund_payment(self, refund_request: Dict[str, Any]) -> Dict[str, Any]:
        # 安全检查
        if not self._validate_refund_request(refund_request):
            raise Exception("退款请求验证失败")
        
        return await self.wrapped_processor.refund_payment(refund_request)
    
    def validate_payment(self, payment_request: PaymentRequest) -> bool:
        # 基础验证
        if not self.wrapped_processor.validate_payment(payment_request):
            return False
        
        # 安全验证
        return self._validate_security_requirements(payment_request)
    
    def _assess_risk(self, payment_request: PaymentRequest) -> float:
        """简单的风险评估"""
        risk_score = 0.0
        
        # 大额支付风险
        if payment_request.amount > 1000:
            risk_score += 30
        
        # 高频支付风险（简化模拟）
        if 'high_frequency' in payment_request.user_info:
            risk_score += 40
        
        # 新用户风险
        if not payment_request.user_info.get('is_verified', False):
            risk_score += 20
        
        return min(risk_score, 100)
    
    def _encrypt_payment_request(self, payment_request: PaymentRequest) -> PaymentRequest:
        """加密支付请求（简化实现）"""
        # 在实际应用中，这里应该进行真正的加密
        encrypted_user_info = payment_request.user_info.copy()
        if 'card_number' in encrypted_user_info:
            encrypted_user_info['card_number'] = "****-****-****-1234"
        
        return PaymentRequest(
            payment_request.order_id,
            payment_request.amount,
            payment_request.currency,
            payment_request.payment_method,
            encrypted_user_info
        )
    
    def _validate_security_requirements(self, payment_request: PaymentRequest) -> bool:
        """验证安全要求"""
        # 检查HTTPS
        # 检查IP白名单
        # 检查用户认证状态
        return True
    
    def _validate_refund_request(self, refund_request: Dict[str, Any]) -> bool:
        """验证退款请求"""
        required_fields = ['transaction_id', 'amount', 'reason']
        return all(field in refund_request for field in required_fields)
    
    def _log_security_event(self, payment_request: PaymentRequest, result: Dict[str, Any]):
        """记录安全事件"""
        print(f"[SECURITY] 支付处理完成: {payment_request.request_id}, 结果: {result.get('success', False)}")

# 支付监控系统
class PaymentMonitor:
    def __init__(self):
        self.transaction_log = []
        self.alert_rules = []
        self.subscribers = []
    
    def log_transaction(self, transaction: Dict[str, Any]):
        """记录交易"""
        self.transaction_log.append({
            **transaction,
            'timestamp': time.time()
        })
        
        # 检查告警规则
        self._check_alert_rules(transaction)
    
    def add_alert_rule(self, rule: Dict[str, Any]):
        """添加告警规则"""
        self.alert_rules.append(rule)
    
    def subscribe(self, callback: callable):
        """订阅监控事件"""
        self.subscribers.append(callback)
    
    def _check_alert_rules(self, transaction: Dict[str, Any]):
        """检查告警规则"""
        for rule in self.alert_rules:
            if self._should_alert(rule, transaction):
                alert = {
                    'rule': rule,
                    'transaction': transaction,
                    'timestamp': time.time()
                }
                
                # 通知订阅者
                for subscriber in self.subscribers:
                    subscriber(alert)
    
    def _should_alert(self, rule: Dict[str, Any], transaction: Dict[str, Any]) -> bool:
        """判断是否应该告警"""
        condition = rule.get('condition', {})
        
        if condition.get('type') == 'high_amount':
            threshold = condition.get('threshold', 1000)
            return transaction.get('amount', 0) > threshold
        
        elif condition.get('type') == 'failed_transaction':
            return not transaction.get('success', False)
        
        return False
    
    def get_transaction_stats(self) -> Dict[str, Any]:
        """获取交易统计"""
        total_transactions = len(self.transaction_log)
        successful_transactions = sum(1 for t in self.transaction_log if t.get('success', False))
        
        return {
            'total_transactions': total_transactions,
            'successful_transactions': successful_transactions,
            'failed_transactions': total_transactions - successful_transactions,
            'success_rate': successful_transactions / total_transactions if total_transactions > 0 else 0
        }

# 支付管理器
class PaymentManager:
    def __init__(self, payment_configs: Dict[str, Dict]):
        self.payment_configs = payment_configs
        self.strategies = {}
        self.monitor = PaymentMonitor()
        self._initialize_strategies()
    
    def _initialize_strategies(self):
        """初始化支付策略"""
        for payment_method, config in self.payment_configs.items():
            base_processor = PaymentStrategyFactory.create_strategy(payment_method, config)
            
            # 使用装饰器添加安全控制
            secure_processor = SecurePaymentDecorator(
                base_processor,
                config.get('security', {})
            )
            
            self.strategies[payment_method] = secure_processor
    
    async def process_payment(self, payment_request: PaymentRequest) -> Dict[str, Any]:
        """处理支付"""
        # 获取支付策略
        processor = self.strategies.get(payment_request.payment_method)
        if not processor:
            raise ValueError(f"不支持的支付方式: {payment_request.payment_method}")
        
        # 验证请求
        if not processor.validate_payment(payment_request):
            raise ValueError("支付请求验证失败")
        
        try:
            # 执行支付
            result = await processor.process_payment(payment_request)
            
            # 记录交易
            self.monitor.log_transaction({
                'request_id': payment_request.request_id,
                'payment_method': payment_request.payment_method,
                'amount': payment_request.amount,
                'success': result.get('success', False),
                'transaction_id': result.get('transaction_id')
            })
            
            return result
            
        except Exception as e:
            # 记录失败交易
            self.monitor.log_transaction({
                'request_id': payment_request.request_id,
                'payment_method': payment_request.payment_method,
                'amount': payment_request.amount,
                'success': False,
                'error': str(e)
            })
            
            raise
    
    async def refund_payment(self, payment_method: str, refund_request: Dict[str, Any]) -> Dict[str, Any]:
        """处理退款"""
        processor = self.strategies.get(payment_method)
        if not processor:
            raise ValueError(f"不支持的支付方式: {payment_method}")
        
        return await processor.refund_payment(refund_request)
    
    def add_monitoring_callback(self, callback: callable):
        """添加监控回调"""
        self.monitor.subscribe(callback)
    
    def get_payment_stats(self) -> Dict[str, Any]:
        """获取支付统计"""
        return self.monitor.get_transaction_stats()
```

## 分布式任务调度系统

### 业务背景

在大型分布式系统中，需要处理大量的异步任务，包括数据同步、消息推送、批量处理、定时任务等。系统需要支持任务的高效调度、失败重试、负载均衡、资源管理和监控。

### 核心问题

1. **任务调度复杂**：需要根据任务类型、优先级、资源需求进行调度
2. **高可用性**：调度器本身不能成为单点故障
3. **负载均衡**：合理分配任务到不同的工作节点
4. **失败处理**：任务失败需要重试机制和错误处理
5. **资源管理**：合理分配CPU、内存等资源

### 设计模式选择

- **工厂模式**：创建不同类型的任务处理器
- **策略模式**：实现不同的调度策略
- **观察者模式**：监控任务状态变化
- **装饰器模式**：添加重试、监控、日志等横切关注点
- **建造者模式**：配置复杂的调度任务
- **命令模式**：封装任务执行命令

### 实现代码

```python
# 任务状态枚举
class TaskStatus(Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    RETRYING = "retrying"

# 任务类型枚举
class TaskType(Enum):
    SYNC_DATA = "sync_data"
    SEND_EMAIL = "send_email"
    GENERATE_REPORT = "generate_report"
    CLEANUP = "cleanup"
    BACKUP = "backup"

# 任务配置
class TaskConfig:
    def __init__(self, 
                 task_type: TaskType,
                 priority: int = 5,
                 max_retries: int = 3,
                 timeout: int = 300,
                 dependencies: List[str] = None,
                 resources: Dict[str, Any] = None):
        self.task_type = task_type
        self.priority = priority
        self.max_retries = max_retries
        self.timeout = timeout
        self.dependencies = dependencies or []
        self.resources = resources or {}

# 任务抽象
class Task(ABC):
    def __init__(self, task_id: str, config: TaskConfig, payload: Dict[str, Any]):
        self.task_id = task_id
        self.config = config
        self.payload = payload
        self.status = TaskStatus.PENDING
        self.created_at = time.time()
        self.started_at = None
        self.completed_at = None
        self.retry_count = 0
        self.result = None
        self.error = None
    
    @abstractmethod
    async def execute(self) -> Dict[str, Any]:
        """执行任务"""
        pass
    
    def can_retry(self) -> bool:
        """判断是否可以重试"""
        return self.retry_count < self.config.max_retries and self.status == TaskStatus.FAILED
    
    def increment_retry(self):
        """增加重试计数"""
        self.retry_count += 1
        self.status = TaskStatus.RETRYING

# 数据同步任务
class DataSyncTask(Task):
    async def execute(self) -> Dict[str, Any]:
        print(f"执行数据同步任务: {self.task_id}")
        
        # 模拟数据同步
        await asyncio.sleep(2)
        
        # 模拟随机失败
        import random
        if random.random() < 0.2:
            raise Exception("数据同步失败")
        
        return {
            'records_processed': 1000,
            'sync_timestamp': time.time(),
            'source': self.payload.get('source'),
            'target': self.payload.get('target')
        }

# 邮件发送任务
class EmailTask(Task):
    async def execute(self) -> Dict[str, Any]:
        print(f"发送邮件任务: {self.task_id}")
        
        await asyncio.sleep(1)
        
        return {
            'email_sent': True,
            'recipient': self.payload.get('recipient'),
            'subject': self.payload.get('subject'),
            'timestamp': time.time()
        }

# 报告生成任务
class ReportTask(Task):
    async def execute(self) -> Dict[str, Any]:
        print(f"生成报告任务: {self.task_id}")
        
        await asyncio.sleep(3)
        
        return {
            'report_generated': True,
            'report_type': self.payload.get('report_type'),
            'file_path': f"/reports/{self.task_id}.pdf",
            'timestamp': time.time()
        }

# 任务工厂
class TaskFactory:
    _task_classes = {
        TaskType.SYNC_DATA: DataSyncTask,
        TaskType.SEND_EMAIL: EmailTask,
        TaskType.GENERATE_REPORT: ReportTask
    }
    
    @classmethod
    def create_task(cls, task_id: str, task_type: TaskType, config: TaskConfig, payload: Dict[str, Any]) -> Task:
        if task_type not in cls._task_classes:
            raise ValueError(f"不支持的任务类型: {task_type}")
        
        task_class = cls._task_classes[task_type]
        return task_class(task_id, config, payload)
    
    @classmethod
    def register_task_type(cls, task_type: TaskType, task_class: type):
        cls._task_classes[task_type] = task_class

# 调度策略抽象
class SchedulingStrategy(ABC):
    @abstractmethod
    def select_next_task(self, pending_tasks: List[Task]) -> Optional[Task]:
        """选择下一个执行的任务"""
        pass

# 优先级调度策略
class PrioritySchedulingStrategy(SchedulingStrategy):
    def select_next_task(self, pending_tasks: List[Task]) -> Optional[Task]:
        if not pending_tasks:
            return None
        
        # 按优先级降序排列
        sorted_tasks = sorted(pending_tasks, key=lambda t: t.config.priority, reverse=True)
        return sorted_tasks[0]

# 轮询调度策略
class RoundRobinSchedulingStrategy(SchedulingStrategy):
    def __init__(self):
        self.current_index = 0
    
    def select_next_task(self, pending_tasks: List[Task]) -> Optional[Task]:
        if not pending_tasks:
            return None
        
        task = pending_tasks[self.current_index % len(pending_tasks)]
        self.current_index += 1
        return task

# 最短作业优先策略
class ShortestJobFirstStrategy(SchedulingStrategy):
    def select_next_task(self, pending_tasks: List[Task]) -> Optional[Task]:
        if not pending_tasks:
            return None
        
        # 简化实现：根据任务类型估计执行时间
        execution_times = {
            TaskType.SYNC_DATA: 2,
            TaskType.SEND_EMAIL: 1,
            TaskType.GENERATE_REPORT: 3,
            TaskType.CLEANUP: 1,
            TaskType.BACKUP: 5
        }
        
        return min(pending_tasks, 
                  key=lambda t: execution_times.get(t.config.task_type, 2))

# 任务装饰器基类
class TaskDecorator(Task):
    def __init__(self, wrapped_task: Task):
        self.wrapped_task = wrapped_task
        self.wrapped_task.task_id = wrapped_task.task_id
        self.wrapped_task.config = wrapped_task.config
        self.wrapped_task.payload = wrapped_task.payload
        self.wrapped_task.status = wrapped_task.status
        self.wrapped_task.created_at = wrapped_task.created_at
        self.wrapped_task.started_at = wrapped_task.started_at
        self.wrapped_task.completed_at = wrapped_task.completed_at
        self.wrapped_task.retry_count = wrapped_task.retry_count
        self.wrapped_task.result = wrapped_task.result
        self.wrapped_task.error = wrapped_task.error
    
    async def execute(self) -> Dict[str, Any]:
        return await self.wrapped_task.execute()
    
    def __getattr__(self, name):
        return getattr(self.wrapped_task, name)

# 重试装饰器
class RetryTaskDecorator(TaskDecorator):
    def __init__(self, wrapped_task: Task, max_retries: int = None):
        super().__init__(wrapped_task)
        self.max_retries = max_retries or wrapped_task.config.max_retries
    
    async def execute(self) -> Dict[str, Any]:
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                self.wrapped_task.started_at = time.time()
                self.wrapped_task.status = TaskStatus.RUNNING
                
                result = await self.wrapped_task.execute()
                
                self.wrapped_task.status = TaskStatus.COMPLETED
                self.wrapped_task.completed_at = time.time()
                self.wrapped_task.result = result
                
                return result
                
            except Exception as e:
                last_exception = e
                self.wrapped_task.error = str(e)
                
                if attempt < self.max_retries:
                    self.wrapped_task.retry_count = attempt + 1
                    self.wrapped_task.status = TaskStatus.RETRYING
                    
                    print(f"任务 {self.wrapped_task.task_id} 第{attempt + 1}次重试...")
                    await asyncio.sleep(2 ** attempt)  # 指数退避
                else:
                    self.wrapped_task.status = TaskStatus.FAILED
                    self.wrapped_task.completed_at = time.time()
        
        raise last_exception

# 监控装饰器
class MonitoringTaskDecorator(TaskDecorator):
    def __init__(self, wrapped_task: Task, monitor: 'TaskMonitor'):
        super().__init__(wrapped_task)
        self.monitor = monitor
    
    async def execute(self) -> Dict[str, Any]:
        start_time = time.time()
        
        # 记录任务开始
        self.monitor.log_task_start(self.wrapped_task)
        
        try:
            result = await self.wrapped_task.execute()
            
            # 记录任务完成
            execution_time = time.time() - start_time
            self.monitor.log_task_completion(self.wrapped_task, execution_time)
            
            return result
            
        except Exception as e:
            # 记录任务失败
            execution_time = time.time() - start_time
            self.monitor.log_task_failure(self.wrapped_task, execution_time, str(e))
            raise

# 任务监控器
class TaskMonitor:
    def __init__(self):
        self.task_logs = []
        self.performance_metrics = {}
        self.subscribers = []
    
    def log_task_start(self, task: Task):
        """记录任务开始"""
        log_entry = {
            'task_id': task.task_id,
            'task_type': task.config.task_type.value,
            'status': 'started',
            'timestamp': time.time(),
            'payload_size': len(str(task.payload))
        }
        self.task_logs.append(log_entry)
        self._notify_subscribers(log_entry)
    
    def log_task_completion(self, task: Task, execution_time: float):
        """记录任务完成"""
        log_entry = {
            'task_id': task.task_id,
            'task_type': task.config.task_type.value,
            'status': 'completed',
            'execution_time': execution_time,
            'timestamp': time.time()
        }
        self.task_logs.append(log_entry)
        
        # 更新性能指标
        self._update_performance_metrics(task.config.task_type, execution_time)
        self._notify_subscribers(log_entry)
    
    def log_task_failure(self, task: Task, execution_time: float, error: str):
        """记录任务失败"""
        log_entry = {
            'task_id': task.task_id,
            'task_type': task.config.task_type.value,
            'status': 'failed',
            'execution_time': execution_time,
            'error': error,
            'timestamp': time.time()
        }
        self.task_logs.append(log_entry)
        self._notify_subscribers(log_entry)
    
    def _update_performance_metrics(self, task_type: TaskType, execution_time: float):
        """更新性能指标"""
        if task_type not in self.performance_metrics:
            self.performance_metrics[task_type] = []
        
        self.performance_metrics[task_type].append(execution_time)
        
        # 保持最近100次记录
        if len(self.performance_metrics[task_type]) > 100:
            self.performance_metrics[task_type] = self.performance_metrics[task_type][-100:]
    
    def _notify_subscribers(self, log_entry: Dict[str, Any]):
        """通知订阅者"""
        for subscriber in self.subscribers:
            try:
                subscriber(log_entry)
            except Exception as e:
                print(f"监控订阅者回调失败: {e}")
    
    def subscribe(self, callback: callable):
        """订阅监控事件"""
        self.subscribers.append(callback)
    
    def get_task_statistics(self) -> Dict[str, Any]:
        """获取任务统计"""
        total_tasks = len(self.task_logs)
        completed_tasks = len([log for log in self.task_logs if log['status'] == 'completed'])
        failed_tasks = len([log for log in self.task_logs if log['status'] == 'failed'])
        
        return {
            'total_tasks': total_tasks,
            'completed_tasks': completed_tasks,
            'failed_tasks': failed_tasks,
            'success_rate': completed_tasks / total_tasks if total_tasks > 0 else 0,
            'performance_metrics': self._get_performance_summary()
        }
    
    def _get_performance_summary(self) -> Dict[str, Any]:
        """获取性能摘要"""
        summary = {}
        for task_type, execution_times in self.performance_metrics.items():
            if execution_times:
                summary[task_type.value] = {
                    'avg_execution_time': sum(execution_times) / len(execution_times),
                    'min_execution_time': min(execution_times),
                    'max_execution_time': max(execution_times),
                    'total_executions': len(execution_times)
                }
        return summary

# 任务队列
class TaskQueue:
    def __init__(self):
        self.tasks = []
        self.completed_tasks = []
        self.failed_tasks = []
        self.in_progress_tasks = []
    
    def add_task(self, task: Task):
        """添加任务"""
        self.tasks.append(task)
        print(f"任务已添加: {task.task_id}")
    
    def get_next_task(self) -> Optional[Task]:
        """获取下一个任务"""
        if not self.tasks:
            return None
        
        return self.tasks.pop(0)
    
    def mark_task_in_progress(self, task: Task):
        """标记任务为进行中"""
        self.in_progress_tasks.append(task)
    
    def mark_task_completed(self, task: Task):
        """标记任务为已完成"""
        if task in self.in_progress_tasks:
            self.in_progress_tasks.remove(task)
        self.completed_tasks.append(task)
        print(f"任务已完成: {task.task_id}")
    
    def mark_task_failed(self, task: Task):
        """标记任务为失败"""
        if task in self.in_progress_tasks:
            self.in_progress_tasks.remove(task)
        self.failed_tasks.append(task)
        print(f"任务已失败: {task.task_id}")
    
    def get_queue_status(self) -> Dict[str, int]:
        """获取队列状态"""
        return {
            'pending': len(self.tasks),
            'in_progress': len(self.in_progress_tasks),
            'completed': len(self.completed_tasks),
            'failed': len(self.failed_tasks)
        }

# 任务调度器
class TaskScheduler:
    def __init__(self, 
                 scheduling_strategy: SchedulingStrategy = None,
                 monitor: TaskMonitor = None):
        self.task_queue = TaskQueue()
        self.scheduling_strategy = scheduling_strategy or PrioritySchedulingStrategy()
        self.monitor = monitor or TaskMonitor()
        self.workers = []
        self.is_running = False
        self.running_tasks = {}
    
    def add_task(self, task: Task):
        """添加任务"""
        self.task_queue.add_task(task)
    
    def set_scheduling_strategy(self, strategy: SchedulingStrategy):
        """设置调度策略"""
        self.scheduling_strategy = strategy
    
    def start_worker(self, worker_id: str):
        """启动工作进程"""
        worker = TaskWorker(worker_id, self)
        self.workers.append(worker)
        worker.start()
        print(f"工作进程 {worker_id} 已启动")
    
    def stop_all_workers(self):
        """停止所有工作进程"""
        for worker in self.workers:
            worker.stop()
        self.workers.clear()
        print("所有工作进程已停止")
    
    def get_next_task(self, worker_id: str) -> Optional[Task]:
        """获取下一个任务"""
        # 检查依赖
        pending_tasks = [task for task in self.task_queue.tasks 
                        if self._check_dependencies(task)]
        
        if not pending_tasks:
            return None
        
        task = self.scheduling_strategy.select_next_task(pending_tasks)
        if task:
            self.task_queue.tasks.remove(task)
            self.task_queue.mark_task_in_progress(task)
            self.running_tasks[worker_id] = task
        
        return task
    
    def _check_dependencies(self, task: Task) -> bool:
        """检查任务依赖"""
        # 简化实现：检查已完成的任务中是否包含依赖
        completed_task_ids = [t.task_id for t in self.task_queue.completed_tasks]
        return all(dep_id in completed_task_ids for dep_id in task.config.dependencies)
    
    def complete_task(self, worker_id: str, task: Task, result: Dict[str, Any]):
        """完成任务"""
        task.result = result
        self.task_queue.mark_task_completed(task)
        self.running_tasks.pop(worker_id, None)
        print(f"工作进程 {worker_id} 完成任务: {task.task_id}")
    
    def fail_task(self, worker_id: str, task: Task, error: str):
        """任务失败"""
        task.error = error
        self.task_queue.mark_task_failed(task)
        self.running_tasks.pop(worker_id, None)
        print(f"工作进程 {worker_id} 任务失败: {task.task_id}, 错误: {error}")
    
    def get_scheduler_stats(self) -> Dict[str, Any]:
        """获取调度器统计"""
        queue_stats = self.task_queue.get_queue_status()
        performance_stats = self.monitor.get_task_statistics()
        
        return {
            'queue': queue_stats,
            'workers': len(self.workers),
            'performance': performance_stats,
            'running_tasks': len(self.running_tasks)
        }

# 工作进程
class TaskWorker:
    def __init__(self, worker_id: str, scheduler: TaskScheduler):
        self.worker_id = worker_id
        self.scheduler = scheduler
        self.is_running = False
        self.current_task = None
    
    def start(self):
        """启动工作进程"""
        self.is_running = True
        print(f"工作进程 {self.worker_id} 开始运行")
        self._run_loop()
    
    def stop(self):
        """停止工作进程"""
        self.is_running = False
        print(f"工作进程 {self.worker_id} 停止运行")
    
    def _run_loop(self):
        """运行主循环"""
        while self.is_running:
            try:
                # 获取任务
                task = self.scheduler.get_next_task(self.worker_id)
                if not task:
                    time.sleep(1)  # 没有任务时等待
                    continue
                
                # 执行任务
                self.current_task = task
                self._execute_task(task)
                
            except Exception as e:
                print(f"工作进程 {self.worker_id} 出现异常: {e}")
                time.sleep(1)
    
    def _execute_task(self, task: Task):
        """执行任务"""
        try:
            # 创建装饰器链
            decorated_task = task
            decorated_task = RetryTaskDecorator(decorated_task)
            decorated_task = MonitoringTaskDecorator(decorated_task, self.scheduler.monitor)
            
            # 执行任务
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            result = loop.run_until_complete(decorated_task.execute())
            loop.close()
            
            # 任务成功
            self.scheduler.complete_task(self.worker_id, task, result)
            
        except Exception as e:
            # 任务失败
            self.scheduler.fail_task(self.worker_id, task, str(e))
        
        finally:
            self.current_task = None
```

## 案例效果分析

### 电商订单处理系统效果

1. **状态管理简化**：使用状态模式将复杂的状态转换逻辑封装在独立的状态类中
2. **支付方式扩展**：策略模式使得新增支付方式变得简单，只需要实现新的处理器
3. **促销策略灵活**：装饰器模式支持促销策略的灵活组合
4. **系统解耦**：观察者模式实现了订单事件的松耦合通知

### 支付系统架构效果

1. **安全性提升**：装饰器模式添加了风险评估、加密、日志等安全控制
2. **可扩展性**：工厂模式支持快速添加新的支付方式
3. **监控完善**：观察者模式实现了完整的交易监控和告警
4. **错误处理**：重试机制和异常处理提高了系统的可靠性

### 分布式任务调度系统效果

1. **调度灵活**：多种调度策略可以根据不同场景灵活选择
2. **高可用性**：多工作进程支持故障转移和负载均衡
3. **监控完善**：装饰器模式添加了全面的监控和性能指标收集
4. **重试机制**：自动重试和指数退避提高了任务成功率

## 总结

通过这些实际案例，我们可以看到设计模式在实际系统架构中的重要作用：

1. **问题针对性**：每个设计模式都是为解决特定问题而设计的
2. **组合使用**：复杂系统通常需要多个设计模式的组合使用
3. **横切关注点**：装饰器模式是处理横切关注点的有效方法
4. **架构演进**：设计模式使系统架构更加灵活和易于演进

在实际项目中，应该根据具体的业务需求和技术约束，选择合适的设计模式，并考虑性能、维护性、测试性等多个因素。设计模式是工具，而不是目的，正确的使用才能发挥最大价值。