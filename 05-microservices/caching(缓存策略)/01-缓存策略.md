# 缓存策略

## 目录
1. [缓存概述](#缓存概述)
2. [缓存架构模式](#缓存架构模式)
3. [缓存策略](#缓存策略)
4. [分布式缓存](#分布式缓存)
5. [缓存问题与解决方案](#缓存问题与解决方案)
6. [最佳实践](#最佳实践)

## 缓存概述

缓存是提升系统性能的重要手段，通过将热点数据存储在高速存储介质中，减少对后端数据源的访问压力。

### 缓存层次结构
```
应用层缓存 → 分布式缓存 → 持久化存储
   (纳秒级)    (微秒级)     (毫秒级)
```

## 缓存架构模式

### 1. Cache Aside（缓存旁路模式）

最常用的模式，应用程序先从缓存获取数据，未命中时从数据库获取并更新缓存。

```python
class SimpleCache:
    def __init__(self):
        self.data = {}
    
    def get(self, key):
        return self.data.get(key)
    
    def set(self, key, value):
        self.data[key] = value

class CacheAside:
    def __init__(self, cache, data_loader):
        self.cache = cache
        self.data_loader = data_loader
    
    def get(self, key):
        value = self.cache.get(key)
        if value is None:
            value = self.data_loader(key)
            if value:
                self.cache.set(key, value)
        return value
```

### 2. Write Through（写透模式）

写入数据时，同时更新缓存和数据库。

```python
class WriteThrough:
    def __init__(self, cache, database):
        self.cache = cache
        self.database = database
    
    def write(self, key, value):
        self.database.save(key, value)
        self.cache.set(key, value)
```

### 3. Write Behind（写回模式）

写入数据时只更新缓存，异步刷新到数据库。

```python
class WriteBehind:
    def __init__(self, cache, database):
        self.cache = cache
        self.database = database
        self.pending_writes = {}
    
    def write(self, key, value):
        self.cache.set(key, value)
        self.pending_writes[key] = value
    
    def flush(self):
        for key, value in self.pending_writes.items():
            self.database.save(key, value)
        self.pending_writes.clear()
```

## 缓存策略

### TTL策略

设置不同类型数据的缓存时间：

```python
TTL_SETTINGS = {
    'user_session': 1800,      # 30分钟
    'product_info': 3600,      # 1小时
    'category_data': 7200,     # 2小时
    'recommendations': 900,    # 15分钟
    'search_results': 300,     # 5分钟
    'static_content': 86400    # 24小时
}
```
    ## 分布式缓存

### 一致性哈希

一致性哈希是分布式缓存的核心技术，确保数据在节点变更时的最小化迁移。

```python
import bisect
import hashlib
from typing import List, Optional

class ConsistentHash:
    """一致性哈希实现"""
    def __init__(self, nodes: List[str], virtual_nodes: int = 150):
        self.virtual_nodes = virtual_nodes
        self.ring: List[int] = []
        self.node_map: dict[int, str] = {}
        
        for node in nodes:
            self.add_node(node)
    
    def _hash(self, key: str) -> int:
        """哈希函数"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node: str):
        """添加节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            position = self._hash(virtual_key)
            bisect.insort(self.ring, position)
            self.node_map[position] = node
    
    def get_node(self, key: str) -> Optional[str]:
        """获取key对应的节点"""
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        index = bisect.bisect_right(self.ring, hash_value)
        if index == len(self.ring):
            index = 0
        
        return self.node_map[self.ring[index]]
```

## 缓存问题与解决方案

### 1. 缓存穿透

**问题**: 查询不存在的数据导致绕过缓存直接访问数据库

**解决方案**: 布隆过滤器 + 空值缓存

```python
class CachePenetrationProtection:
    """缓存穿透防护"""
    def __init__(self, cache: Cache, data_loader):
        self.cache = cache
        self.data_loader = data_loader
        self.bloom_filter: set[str] = set()
    
    async def get(self, key: str) -> Any:
        if key not in self.bloom_filter:
            return None
        
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        value = await self.data_loader(key)
        if value is not None:
            await self.cache.set(key, value)
        
        return value
```

### 2. 缓存击穿

**问题**: 热点数据过期瞬间大量请求直接访问数据库

**解决方案**: 单飞机制

```python
class CacheBreakdownProtection:
    """缓存击穿防护"""
    def __init__(self, cache: Cache, data_loader):
        self.cache = cache
        self.data_loader = data_loader
        self.locks: set[str] = set()
    
    async def get(self, key: str) -> Any:
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        if key in self.locks:
            await asyncio.sleep(0.1)
            return await self.get(key)
        
        try:
            self.locks.add(key)
            value = await self.cache.get(key)
            if value is not None:
                return value
            
            value = await self.data_loader(key)
            if value is not None:
                await self.cache.set(key, value)
            
            return value
        finally:
            self.locks.remove(key)
```

### 3. 缓存雪崩

**问题**: 大量缓存同时过期导致数据库压力激增

**解决方案**: 分布式限流 + 多级缓存

```python
class CacheAvalancheProtection:
    """缓存雪崩防护"""
    def __init__(self, cache: Cache, fallback_cache: dict):
        self.cache = cache
        self.fallback_cache = fallback_cache
    
    async def get(self, key: str) -> Any:
        # 检查主缓存
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        # 检查降级缓存
        if key in self.fallback_cache:
            return self.fallback_cache[key]
        
        return None
```

## 最佳实践

### 1. 缓存设计原则

- **数据一致性**: 确保缓存与数据库数据的一致性
- **性能优化**: 根据数据特点选择合适的TTL策略
- **容错机制**: 设计降级和熔断机制
- **监控告警**: 实时监控缓存性能和健康状态

### 2. TTL设置策略

```python
class TTLCategories:
    CATEGORIES = {
        'user_session': 1800,      # 30分钟
        'product_info': 3600,      # 1小时
        'category_data': 7200,     # 2小时
        'recommendations': 900,    # 15分钟
        'search_results': 300,     # 5分钟
        'static_content': 86400    # 24小时
    }
```

### 3. 缓存监控指标

```python
class CacheMonitor:
    def __init__(self):
        self.metrics = {'hits': 0, 'misses': 0, 'errors': 0}
    
    def get_hit_rate(self) -> float:
        total = self.metrics['hits'] + self.metrics['misses']
        return self.metrics['hits'] / total if total > 0 else 0
```

## 总结

缓存策略是系统性能优化的关键，选择合适的模式：

1. **Cache Aside**: 读多写少的场景
2. **Write Through**: 数据一致性要求高的场景  
3. **Write Behind**: 写性能要求高的场景

核心是处理穿透、击穿、雪崩问题，确保系统稳定性。

---
*文档更新时间: 精简冗余代码，保留核心概念*