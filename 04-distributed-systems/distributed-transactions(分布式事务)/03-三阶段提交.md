# Three-Phase Commit (3PC) 详解

## 目录
1. [3PC概述](#3pc概述)
2. [3PC原理](#3pc原理)
3. [三个阶段详解](#三个阶段详解)
4. [状态转换](#状态转换)
5. [故障恢复机制](#故障恢复机制)
6. [Python实现](#python实现)
7. [Go语言实现](#go语言实现)
8. [性能分析](#性能分析)
9. [实际应用案例](#实际应用案例)
10. [与2PC对比](#与2pc对比)
11. [最佳实践](#最佳实践)

## 3PC概述

### 什么是3PC

三阶段提交协议（Three-Phase Commit, 3PC）是2PC的改进版本，主要解决2PC中的阻塞问题。3PC通过增加一个预提交阶段（Pre-Commit）来减少协调者故障时的阻塞情况，提高了系统的可用性。

```python
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import uuid
import queue
import random
from abc import ABC, abstractmethod

class ThreePCState(Enum):
    """3PC事务状态"""
    INITIATED = "initiated"
    VOTING = "voting"
    PREPARED = "prepared"
    PRE_COMMITTING = "pre_committing"
    PRE_COMMITTED = "pre_commmitted"
    COMMITTING = "committing"
    COMMITTED = "committed"
    ABORTING = "aborting"
    ABORTED = "aborted"
    TIMEOUT = "timeout"

class Participant3PCState(Enum):
    """参与者3PC状态"""
    INIT = "init"
    WAITING = "waiting"
    PREPARED = "prepared"
    PRE_COMMITTED = "pre_committed"
    COMMITTED = "committed"
    ABORTED = "aborted"
    FAILED = "failed"

class Vote3PC(Enum):
    """3PC投票"""
    YES = "yes"
    NO = "no"
    TIMEOUT = "timeout"

class ThreePCTransaction:
    """3PC事务定义"""
    
    def __init__(self, transaction_id: str, coordinator_id: str):
        self.transaction_id = transaction_id
        self.coordinator_id = coordinator_id
        self.state = ThreePCState.INITIATED
        self.participants: List[str] = []
        self.votes: Dict[str, Vote3PC] = {}
        self.start_time = time.time()
        self.operations: List[dict] = []
        self.timeout = 30.0
        
    def add_participant(self, participant_id: str):
        """添加参与者"""
        if participant_id not in self.participants:
            self.participants.append(participant_id)
    
    def all_yes_votes(self) -> bool:
        """检查是否所有投票都是YES"""
        return all(vote == Vote3PC.YES for vote in self.votes.values())

class ThreePCMessage:
    """3PC消息定义"""
    
    def __init__(self, sender_id: str, receiver_id: str, 
                 message_type: str, transaction_id: str):
        self.sender_id = sender_id
        self.receiver_id = receiver_id
        self.message_type = message_type
        self.transaction_id = transaction_id
        self.payload = {}
        self.timestamp = time.time()

class ThreePCCoordinator:
    """3PC协调者实现"""
    
    def __init__(self, coordinator_id: str):
        self.coordinator_id = coordinator_id
        self.active_transactions: Dict[str, ThreePCTransaction] = {}
        self.message_queue = queue.Queue()
        self.participant_records: Dict[str, Dict[str, str]] = {}  # participant_id -> {transaction_id: state}
        self.mutex = threading.Lock()
    
    def begin_transaction(self, participants: List[str]) -> str:
        """开始事务"""
        transaction_id = f"3pc_txn_{uuid.uuid4().hex[:8]}"
        
        transaction = ThreePCTransaction(transaction_id, self.coordinator_id)
        for participant in participants:
            transaction.add_participant(participant)
        
        with self.mutex:
            self.active_transactions[transaction_id] = transaction
        
        print(f"Coordinator {self.coordinator_id} begins 3PC transaction {transaction_id}")
        print(f"Participants: {', '.join(participants)}")
        
        return transaction_id
    
    def execute_transaction(self, transaction_id: str, operations: List[dict]) -> bool:
        """执行事务"""
        if transaction_id not in self.active_transactions:
            return False
        
        transaction = self.active_transactions[transaction_id]
        transaction.operations = operations
        
        # Phase 1: Voting Phase
        return self._voting_phase(transaction_id)
    
    def _voting_phase(self, transaction_id: str) -> bool:
        """阶段1: 投票阶段"""
        print(f"=== Phase 1: Voting Phase for {transaction_id} ===")
        
        transaction = self.active_transactions[transaction_id]
        transaction.state = ThreePCState.VOTING
        
        # 发送投票请求
        vote_request = ThreePCMessage(
            sender_id=self.coordinator_id,
            receiver_id="",  # 广播
            message_type="VOTE_REQUEST",
            transaction_id=transaction_id
        )
        vote_request.payload = {"operations": transaction.operations}
        
        for participant_id in transaction.participants:
            vote_request.receiver_id = participant_id
            self._broadcast_message(vote_request)
            print(f"Sent VOTE_REQUEST to {participant_id}")
        
        # 等待投票结果
        return self._wait_for_votes(transaction_id)
    
    def _wait_for_votes(self, transaction_id: str) -> bool:
        """等待投票"""
        transaction = self.active_transactions[transaction_id]
        start_time = time.time()
        
        while time.time() - start_time < transaction.timeout:
            message = self._receive_message()
            if message and (message.message_type == "VOTE" and 
                          message.transaction_id == transaction_id):
                
                participant_id = message.sender_id
                vote = message.payload.get("vote", Vote3PC.TIMEOUT)
                
                transaction.votes[participant_id] = vote
                print(f"Received vote from {participant_id}: {vote.value}")
                
                if vote == Vote3PC.NO:
                    print(f"Participant {participant_id} voted NO, aborting transaction")
                    self._abort_transaction(transaction_id)
                    return False
                elif vote == Vote3PC.TIMEOUT:
                    print(f"Vote timeout from {participant_id}, treating as NO")
                    self._abort_transaction(transaction_id)
                    return False
            
            # 检查是否收到所有参与者的投票
            if len(transaction.votes) >= len(transaction.participants):
                if transaction.all_yes_votes():
                    print("All participants voted YES, proceeding to pre-commit phase")
                    return self._pre_commit_phase(transaction_id)
                else:
                    print("Not all participants voted YES, aborting transaction")
                    self._abort_transaction(transaction_id)
                    return False
        
        # 超时处理
        print("Vote timeout occurred, aborting transaction")
        self._abort_transaction(transaction_id)
        return False
    
    def _pre_commit_phase(self, transaction_id: str) -> bool:
        """阶段2: 预提交阶段"""
        print(f"=== Phase 2: Pre-Commit Phase for {transaction_id} ===")
        
        transaction = self.active_transactions[transaction_id]
        transaction.state = ThreePCState.PRE_COMMITTING
        
        # 发送预提交请求
        pre_commit_request = ThreePCMessage(
            sender_id=self.coordinator_id,
            receiver_id="",
            message_type="PRE_COMMIT",
            transaction_id=transaction_id
        )
        
        for participant_id in transaction.participants:
            pre_commit_request.receiver_id = participant_id
            self._broadcast_message(pre_commit_request)
            print(f"Sent PRE_COMMIT to {participant_id}")
        
        # 等待参与者确认预提交
        return self._wait_for_pre_commits(transaction_id)
    
    def _wait_for_pre_commits(self, transaction_id: str) -> bool:
        """等待预提交确认"""
        transaction = self.active_transactions[transaction_id]
        start_time = time.time()
        confirmed_participants = set()
        
        while time.time() - start_time < transaction.timeout:
            message = self._receive_message()
            if message and (message.message_type == "PRE_COMMIT_ACK" and 
                          message.transaction_id == transaction_id):
                
                participant_id = message.sender_id
                confirmed_participants.add(participant_id)
                print(f"Received PRE_COMMIT_ACK from {participant_id}")
            
            # 检查是否所有参与者都确认预提交
            if len(confirmed_participants) >= len(transaction.participants):
                print("All participants pre-committed successfully")
                return self._commit_phase(transaction_id)
        
        print("Pre-commit timeout, some participants failed to pre-commit")
        self._abort_transaction(transaction_id)
        return False
    
    def _commit_phase(self, transaction_id: str) -> bool:
        """阶段3: 提交阶段"""
        print(f"=== Phase 3: Commit Phase for {transaction_id} ===")
        
        transaction = self.active_transactions[transaction_id]
        transaction.state = ThreePCState.COMMITTING
        
        # 发送最终提交请求
        commit_request = ThreePCMessage(
            sender_id=self.coordinator_id,
            receiver_id="",
            message_type="GLOBAL_COMMIT",
            transaction_id=transaction_id
        )
        
        for participant_id in transaction.participants:
            commit_request.receiver_id = participant_id
            self._broadcast_message(commit_request)
            print(f"Sent GLOBAL_COMMIT to {participant_id}")
        
        transaction.state = ThreePCState.COMMITTED
        print(f"Transaction {transaction_id} committed successfully")
        
        # 清理参与者记录
        if transaction_id in self.participant_records:
            del self.participant_records[transaction_id]
        
        return True
    
    def _abort_transaction(self, transaction_id: str):
        """回滚事务"""
        if transaction_id not in self.active_transactions:
            return
        
        transaction = self.active_transactions[transaction_id]
        transaction.state = ThreePCState.ABORTING
        
        # 发送全局回滚
        abort_request = ThreePCMessage(
            sender_id=self.coordinator_id,
            receiver_id="",
            message_type="GLOBAL_ABORT",
            transaction_id=transaction_id
        )
        
        for participant_id in transaction.participants:
            abort_request.receiver_id = participant_id
            self._broadcast_message(abort_request)
            print(f"Sent GLOBAL_ABORT to {participant_id}")
        
        transaction.state = ThreePCState.ABORTED
        print(f"Transaction {transaction_id} aborted")
    
    def handle_participant_timeout(self, transaction_id: str, participant_id: str):
        """处理参与者超时"""
        print(f"Participant {participant_id} timeout in transaction {transaction_id}")
        
        # 如果在投票阶段，视为NO票
        # 如果在预提交阶段，进入回滚
        transaction = self.active_transactions.get(transaction_id)
        if not transaction:
            return
        
        if transaction.state == ThreePCState.VOTING:
            transaction.votes[participant_id] = Vote3PC.TIMEOUT
        elif transaction.state == ThreePCState.PRE_COMMITTING:
            self._abort_transaction(transaction_id)
    
    def _broadcast_message(self, message: ThreePCMessage):
        """广播消息"""
        # 在实际实现中，这里会发送到消息队列或网络
        print(f"Broadcasting {message.message_type} for transaction {message.transaction_id}")
    
    def _receive_message(self) -> Optional[ThreePCMessage]:
        """接收消息"""
        try:
            return self.message_queue.get(timeout=0.1)
        except queue.Empty:
            return None

class ThreePCParticipant:
    """3PC参与者实现"""
    
    def __init__(self, participant_id: str):
        self.participant_id = participant_id
        self.active_transactions: Dict[str, Participant3PCState] = {}
        self.message_queue = queue.Queue()
        self.coordinator_records: Dict[str, Dict[str, str]] = {}  # transaction_id -> {coordinator_id: state}
        self.local_operations: Dict[str, List[dict]] = {}
        self.mutex = threading.Lock()
    
    def handle_vote_request(self, message: ThreePCMessage) -> Vote3PC:
        """处理投票请求"""
        transaction_id = message.transaction_id
        operations = message.payload.get("operations", [])
        
        print(f"Participant {self.participant_id} received VOTE_REQUEST for {transaction_id}")
        
        # 记录事务状态
        self.active_transactions[transaction_id] = Participant3PCState.WAITING
        self.local_operations[transaction_id] = operations
        
        # 执行本地验证
        try:
            if self._validate_operations(operations):
                print(f"Participant {self.participant_id} votes YES for {transaction_id}")
                
                # 发送YES投票
                vote_response = ThreePCMessage(
                    sender_id=self.participant_id,
                    receiver_id=message.sender_id,
                    message_type="VOTE",
                    transaction_id=transaction_id
                )
                vote_response.payload = {"vote": Vote3PC.YES}
                self._send_message(vote_response)
                
                return Vote3PC.YES
            else:
                print(f"Participant {self.participant_id} votes NO for {transaction_id}")
                
                # 发送NO投票
                vote_response = ThreePCMessage(
                    sender_id=self.participant_id,
                    receiver_id=message.sender_id,
                    message_type="VOTE",
                    transaction_id=transaction_id
                )
                vote_response.payload = {"vote": Vote3PC.NO}
                self._send_message(vote_response)
                
                return Vote3PC.NO
                
        except Exception as e:
            print(f"Participant {self.participant_id} failed validation: {e}")
            
            # 发送NO投票
            vote_response = ThreePCMessage(
                sender_id=self.participant_id,
                receiver_id=message.sender_id,
                message_type="VOTE",
                transaction_id=transaction_id
            )
            vote_response.payload = {"vote": Vote3PC.NO}
            self._send_message(vote_response)
            
            return Vote3PC.NO
    
    def handle_pre_commit(self, message: ThreePCMessage):
        """处理预提交"""
        transaction_id = message.transaction_id
        
        print(f"Participant {self.participant_id} received PRE_COMMIT for {transaction_id}")
        
        # 状态转换到预提交
        self.active_transactions[transaction_id] = Participant3PCState.PRE_COMMITTED
        
        # 发送预提交确认
        ack_response = ThreePCMessage(
            sender_id=self.participant_id,
            receiver_id=message.sender_id,
            message_type="PRE_COMMIT_ACK",
            transaction_id=transaction_id
        )
        self._send_message(ack_response)
        
        print(f"Participant {self.participant_id} sent PRE_COMMIT_ACK")
    
    def handle_global_commit(self, message: ThreePCMessage):
        """处理全局提交"""
        transaction_id = message.transaction_id
        
        print(f"Participant {self.participant_id} received GLOBAL_COMMIT for {transaction_id}")
        
        # 执行最终提交
        success = self._execute_operations(self.local_operations[transaction_id])
        
        if success:
            self.active_transactions[transaction_id] = Participant3PCState.COMMITTED
            print(f"Participant {self.participant_id} committed transaction {transaction_id}")
        else:
            self.active_transactions[transaction_id] = Participant3PCState.FAILED
            print(f"Participant {self.participant_id} failed to commit {transaction_id}")
    
    def handle_global_abort(self, message: ThreePCMessage):
        """处理全局回滚"""
        transaction_id = message.transaction_id
        
        print(f"Participant {self.participant_id} received GLOBAL_ABORT for {transaction_id}")
        
        # 执行回滚
        self._rollback_operations(transaction_id)
        
        self.active_transactions[transaction_id] = Participant3PCState.ABORTED
        print(f"Participant {self.participant_id} aborted transaction {transaction_id}")
    
    def handle_coordinator_timeout(self, transaction_id: str):
        """处理协调者超时"""
        print(f"Participant {self.participant_id} coordinator timeout for {transaction_id}")
        
        state = self.active_transactions.get(transaction_id)
        
        if state == Participant3PCState.PRE_COMMITTED:
            # 在3PC中，如果参与者已经预提交，可以安全提交
            print(f"Participant {self.participant_id} auto-committing due to pre-commit state")
            self.active_transactions[transaction_id] = Participant3PCState.COMMITTED
    
    def _validate_operations(self, operations: List[dict]) -> bool:
        """验证操作"""
        for operation in operations:
            if operation.get("type") == "transfer":
                account = operation.get("account")
                amount = operation.get("amount")
                if account == "insufficient_funds" and amount > 0:
                    return False
                if account == "invalid_account":
                    return False
        
        return True
    
    def _execute_operations(self, operations: List[dict]) -> bool:
        """执行操作"""
        try:
            for operation in operations:
                op_type = operation.get("type")
                
                if op_type == "transfer":
                    from_account = operation.get("from")
                    to_account = operation.get("to")
                    amount = operation.get("amount")
                    
                    print(f"  Executing: Transfer {amount} from {from_account} to {to_account}")
                    
                    # 模拟执行时间
                    time.sleep(0.1)
                    
                elif op_type == "update":
                    table = operation.get("table")
                    data = operation.get("data")
                    print(f"  Executing: Update {table} with {data}")
                
                # 模拟5%的失败率
                if random.random() < 0.05:
                    return False
            
            return True
            
        except Exception as e:
            print(f"Execution failed: {e}")
            return False
    
    def _rollback_operations(self, transaction_id: str):
        """回滚操作"""
        operations = self.local_operations.get(transaction_id, [])
        
        for operation in operations:
            op_type = operation.get("type")
            
            if op_type == "transfer":
                from_account = operation.get("from")
                to_account = operation.get("to")
                amount = operation.get("amount")
                
                print(f"  Rolling back: Transfer {amount} from {to_account} to {from_account}")
    
    def _send_message(self, message: ThreePCMessage):
        """发送消息"""
        # 在实际实现中，这里会发送到消息队列或网络
        print(f"Sending {message.message_type} to {message.receiver_id}")

class ThreePCSimulation:
    """3PC仿真系统"""
    
    def __init__(self):
        self.coordinator = ThreePCCoordinator("3pc_coordinator")
        self.participants = {}
        self.message_queues = {}
        self._setup_system()
    
    def _setup_system(self):
        """设置系统"""
        participant_ids = ["3pc_participant_1", "3pc_participant_2", "3pc_participant_3"]
        
        for pid in participant_ids:
            participant = ThreePCParticipant(pid)
            self.participants[pid] = participant
        
        print("=== 3PC System Setup ===")
        print(f"Coordinator: {self.coordinator.coordinator_id}")
        print(f"Participants: {', '.join(participant_ids)}")
    
    def run_successful_transaction(self):
        """运行成功的事务"""
        print("\n" + "="*50)
        print("3PC SUCCESSFUL TRANSACTION DEMO")
        print("="*50)
        
        participants_list = list(self.participants.keys())
        
        # 开始事务
        transaction_id = self.coordinator.begin_transaction(participants_list)
        
        # 定义操作
        operations = [
            {"type": "transfer", "from": "account_A", "to": "account_B", "amount": 200},
            {"type": "update", "table": "audit_log", "data": {"action": "transfer", "amount": 200}}
        ]
        
        # 执行事务
        success = self.coordinator.execute_transaction(transaction_id, operations)
        
        print(f"\nTransaction {transaction_id} result: {'Success' if success else 'Failed'}")
        print(f"Final state: {self.coordinator.active_transactions[transaction_id].state}")
    
    def run_failed_transaction(self):
        """运行失败的事务"""
        print("\n" + "="*50)
        print("3PC FAILED TRANSACTION DEMO")
        print("="*50)
        
        participants_list = list(self.participants.keys())
        
        # 开始事务
        transaction_id = self.coordinator.begin_transaction(participants_list)
        
        # 定义包含失败操作的操作
        operations = [
            {"type": "transfer", "from": "insufficient_funds", "to": "account_B", "amount": 500}
        ]
        
        # 执行事务
        success = self.coordinator.execute_transaction(transaction_id, operations)
        
        print(f"\nTransaction {transaction_id} result: {'Success' if success else 'Failed'}")
        print(f"Final state: {self.coordinator.active_transactions[transaction_id].state}")
    
    def simulate_coordinator_failure(self):
        """模拟协调者故障"""
        print("\n" + "="*50)
        print("3PC COORDINATOR FAILURE DEMO")
        print("="*50)
        
        participants_list = list(self.participants.keys())
        
        # 开始事务
        transaction_id = self.coordinator.begin_transaction(participants_list)
        
        operations = [
            {"type": "update", "table": "orders", "data": {"order_id": "123", "status": "processing"}}
        ]
        
        print("Starting transaction, but coordinator will fail during pre-commit phase...")
        
        # 模拟协调者在预提交后故障
        # 在实际实现中，这里会触发参与者的超时机制
        
        print("Simulating coordinator failure recovery...")

class GoStyle3PC:
    """Go风格3PC实现"""
    
    def __init__(self):
        self.coordinator = ThreePCCoordinator("go_3pc_coordinator")
        self.participants = {f"go_3pc_participant_{i}": ThreePCParticipant(f"go_3pc_participant_{i}") 
                           for i in range(1, 4)}
    
    def run_go_style_demo(self):
        """运行Go风格演示"""
        print("\n=== Go-Style 3PC Demo ===")
        
        participants_list = list(self.participants.keys())
        
        # 创建通道模拟Go的channel
        result_channel = queue.Queue()
        
        def async_3pc_execution():
            """异步3PC执行"""
            try:
                transaction_id = self.coordinator.begin_transaction(participants_list)
                
                operations = [
                    {"type": "update", "table": "products", "data": {"id": 2, "stock": 25}},
                    {"type": "update", "table": "inventory", "data": {"product_id": 2, "reserved": 5}}
                ]
                
                # 执行事务
                success = self.coordinator.execute_transaction(transaction_id, operations)
                
                # 发送结果到通道
                result_channel.put({
                    "transaction_id": transaction_id,
                    "success": success,
                    "state": self.coordinator.active_transactions[transaction_id].state.value
                })
                
            except Exception as e:
                result_channel.put({"error": str(e)})
        
        # 启动异步执行
        thread = threading.Thread(target=async_3pc_execution)
        thread.start()
        
        # 等待结果
        try:
            result = result_channel.get(timeout=10.0)
            print(f"3PC transaction result: {result}")
        except queue.Empty:
            print("3PC transaction timed out")

class ThreePCPerformanceAnalysis:
    """3PC性能分析"""
    
    @staticmethod
    def analyze_3pc_complexity():
        """分析3PC复杂度"""
        complexity = {
            "message_complexity": {
                "phase_1": "O(n)",  # 投票请求
                "phase_2": "O(n)",  # 预提交请求
                "phase_3": "O(n)",  # 提交/回滚请求
                "total_messages": "3n",  # 3个阶段，每阶段n条消息
                "worst_case": "4n"  # 如果需要重试
            },
            "time_complexity": {
                "synchronous_rounds": "3",  # 3个阶段
                "blocking_time": "low",     # 比2PC减少阻塞
                "timeout_handling": "required"
            },
            "space_complexity": {
                "coordinator_memory": "O(t)",  # t个活跃事务
                "participant_memory": "O(1)",  # 恒定空间
                "recovery_info": "O(t)"        # 恢复信息
            }
        }
        
        print("=== 3PC Performance Analysis ===\n")
        
        for category, metrics in complexity.items():
            print(f"**{category.replace('_', ' ').title()}**")
            for metric, value in metrics.items():
                print(f"  {metric.replace('_', ' ').title()}: {value}")
            print()

class ThreePCApplicationExamples:
    """3PC实际应用案例"""
    
    @staticmethod
    def distributed_database_example():
        """分布式数据库示例"""
        print("=== Distributed Database with 3PC ===\n")
        
        # 模拟分布式数据库集群
        db_nodes = [ThreePCParticipant(f"db_node_{i}") for i in range(1, 6)]
        
        print("Scenario: Distributed database update with replication")
        
        operations = [
            {"type": "update", "table": "user_profiles", "data": {"user_id": "user123", "email": "new@email.com"}},
            {"type": "update", "table": "user_preferences", "data": {"user_id": "user123", "theme": "dark"}},
            {"type": "insert", "table": "audit_trail", "data": {"action": "profile_update", "user_id": "user123"}}
        ]
        
        print("Database operations:")
        for op in operations:
            print(f"  {op}")
        
        coordinator = ThreePCCoordinator("database_coordinator")
        participant_ids = [node.participant_id for node in db_nodes]
        
        transaction_id = coordinator.begin_transaction(participant_ids)
        print(f"\nStarting 3PC for database transaction: {transaction_id}")
        
        success = coordinator.execute_transaction(transaction_id, operations)
        
        print(f"Database transaction result: {'Success' if success else 'Failed'}")
    
    @staticmethod
    def microservices_example():
        """微服务示例"""
        print("\n=== Microservices with 3PC ===\n")
        
        # 模拟微服务架构
        services = {
            "order_service": ThreePCParticipant("order_service"),
            "inventory_service": ThreePCParticipant("inventory_service"),
            "payment_service": ThreePCParticipant("payment_service"),
            "shipping_service": ThreePCParticipant("shipping_service")
        }
        
        print("Scenario: E-commerce order processing across services")
        
        operations = [
            {"type": "create_order", "service": "order_service", "data": {"order_id": "order789", "items": ["item1", "item2"]}},
            {"type": "reserve_inventory", "service": "inventory_service", "data": {"items": ["item1", "item2"], "quantities": [1, 2]}},
            {"type": "process_payment", "service": "payment_service", "data": {"order_id": "order789", "amount": 99.99}},
            {"type": "schedule_shipping", "service": "shipping_service", "data": {"order_id": "order789", "address": "123 Main St"}}
        ]
        
        print("Microservice operations:")
        for op in operations:
            print(f"  {op}")
        
        coordinator = ThreePCCoordinator("order_coordinator")
        participant_ids = list(services.keys())
        
        transaction_id = coordinator.begin_transaction(participant_ids)
        print(f"\nStarting 3PC for order processing: {transaction_id}")
        
        success = coordinator.execute_transaction(transaction_id, operations)
        
        print(f"Order processing result: {'Success' if success else 'Failed'}")

class ThreePCComparison:
    """3PC与2PC对比"""
    
    @staticmethod
    def compare_with_2pc():
        """与2PC对比"""
        comparison = {
            "2PC vs 3PC": {
                "consistency": "Both provide strong consistency",
                "availability": "2PC: Low, 3PC: Medium",
                "latency": "2PC: 2 rounds, 3PC: 3 rounds",
                "blocking": "2PC: High, 3PC: Low",
                "fault_tolerance": "2PC: Poor, 3PC: Better",
                "message_overhead": "2PC: 2n messages, 3PC: 3n messages",
                "complexity": "2PC: Simple, 3PC: More complex",
                "timeout_handling": "Both require timeout mechanisms",
                "network_partitions": "2P2: Unavailable, 3PC: Partially available"
            }
        }
        
        print("=== 3PC vs 2PC Comparison ===\n")
        
        for category, details in comparison.items():
            print(f"**{category}**")
            for aspect, value in details.items():
                print(f"  {aspect.replace('_', ' ').title()}: {value}")
            print()
    
    @staticmethod
    def use_case_recommendations():
        """使用场景建议"""
        recommendations = {
            "Use 3PC when": [
                "System availability is critical",
                "Network partitions may occur",
                "Participants can handle the additional round trip",
                "Blocking is unacceptable",
                "Strong consistency is still required",
                "Network reliability is variable"
            ],
            "Use 2PC when": [
                "Simplicity is more important than availability",
                "Network is highly reliable",
                "Number of participants is small",
                "Blocking can be tolerated",
                "System is in a trusted environment",
                "Message overhead must be minimized"
            ],
            "Consider alternatives when": [
                "Eventual consistency is acceptable",
                "High availability is the primary concern",
                "Participants are in different trust domains",
                "Network conditions are poor",
                "Microservices architecture is used"
            ]
        }
        
        print("=== When to Use 3PC vs Alternatives ===\n")
        
        for scenario, conditions in recommendations.items():
            print(f"**{scenario}**")
            for condition in conditions:
                print(f"  • {condition}")
            print()

class ThreePCBestPractices:
    """3PC最佳实践"""
    
    @staticmethod
    def optimization_strategies():
        """优化策略"""
        strategies = {
            "coordinator_optimization": [
                "Implement coordinator replication",
                "Use leader election for coordinator selection",
                "Cache participant state information",
                "Implement efficient timeout handling",
                "Use asynchronous I/O for message processing"
            ],
            "participant_optimization": [
                "Optimize local transaction processing",
                "Implement lock timeout mechanisms",
                "Use pre-validation of operations",
                "Implement state recovery protocols",
                "Optimize memory usage for active transactions"
            ],
            "network_optimization": [
                "Implement message batching",
                "Use connection pooling",
                "Implement message compression",
                "Use multicast for broadcast messages",
                "Implement adaptive timeout based on network conditions"
            ],
            "fault_handling": [
                "Implement participant state logging",
                "Use majority consensus for recovery decisions",
                "Implement automatic coordinator failover",
                "Use heartbeats for participant monitoring",
                "Implement deadlock detection and resolution"
            ]
        }
        
        print("=== 3PC Optimization Strategies ===\n")
        
        for category, techniques in strategies.items():
            print(f"**{category.replace('_', ' ').title()}**")
            for technique in techniques:
                print(f"  • {technique}")
            print()
    
    @staticmethod
    def common_issues():
        """常见问题"""
        issues = {
            "coordinator_spoofing": {
                "issue": "Malicious coordinator can cause inconsistencies",
                "solution": "Implement coordinator authentication and authorization"
            },
            "participant_timeout": {
                "issue": "Participants may timeout at different times",
                "solution": "Implement synchronized timeout mechanisms"
            },
            "state_inconsistency": {
                "issue": "Coordinator and participant states may diverge",
                "solution": "Implement state reconciliation protocols"
            },
            "message_loss": {
                "issue": "Lost messages can cause transaction blocking",
                "solution": "Implement message acknowledgment and retry mechanisms"
            },
            "network_partitions": {
                "issue": "Partitions can cause split-brain scenarios",
                "solution": "Implement partition detection and resolution"
            }
        }
        
        print("=== Common 3PC Issues ===\n")
        
        for issue, details in issues.items():
            print(f"**{issue.replace('_', ' ').title()}**")
            print(f"Problem: {details['issue']}")
            print(f"Solution: {details['solution']}")
            print()

# 主演示函数
def demo_three_phase_commit():
    """主演示函数"""
    
    print("=== Three-Phase Commit (3PC) Complete Demo ===\n")
    
    # 1. 成功事务演示
    simulation = ThreePCSimulation()
    simulation.run_successful_transaction()
    
    # 2. 失败事务演示
    simulation.run_failed_transaction()
    
    # 3. 协调者故障演示
    simulation.simulate_coordinator_failure()
    
    # 4. Go风格演示
    go_demo = GoStyle3PC()
    go_demo.run_go_style_demo()
    
    # 5. 性能分析
    performance = ThreePCPerformanceAnalysis()
    performance.analyze_3pc_complexity()
    
    # 6. 实际应用案例
    applications = ThreePCApplicationExamples()
    applications.distributed_database_example()
    applications.microservices_example()
    
    # 7. 2PC对比
    comparison = ThreePCComparison()
    comparison.compare_with_2pc()
    comparison.use_case_recommendations()
    
    # 8. 最佳实践
    best_practices = ThreePCBestPractices()
    best_practices.optimization_strategies()
    best_practices.common_issues()
    
    print("\n=== 3PC Summary ===")
    print("Three-Phase Commit improves upon 2PC by:")
    print("• Reducing blocking through the pre-commit phase")
    print("• Providing better fault tolerance")
    print("• Improving availability in failure scenarios")
    print("\nHowever, 3PC trades:")
    print("• Higher latency (3 round trips vs 2)")
    print("• More complex protocol implementation")
    print("• Higher message overhead")
    print("\nChoose 3PC when:")
    print("• System availability is critical")
    print("• Network partitions are possible")
    print("• Blocking cannot be tolerated")
    print("• Strong consistency is still required")

if __name__ == "__main__":
    demo_three_phase_commit()
```

这个Three-Phase Commit学习文档涵盖了：

1. **3PC概述**：3PC的改进点和对2PC的优化
2. **核心原理**：三个阶段的详细执行流程和状态转换
3. **参与者角色**：协调者和参与者在各阶段的职责
4. **完整实现**：包含协调者、参与者的完整Python实现
5. **故障恢复**：协调者故障、网络分区等异常情况的处理
6. **Go语言风格**：模拟Go的并发和通道模式
7. **性能分析**：复杂度分析和与2PC的性能对比
8. **实际应用**：分布式数据库、微服务架构等案例
9. **对比分析**：与2PC的详细对比和使用场景建议
10. **最佳实践**：优化策略和常见问题的解决方案

文档提供了全面的3PC协议学习路径，从理论原理到实际应用，帮助深入理解3PC如何解决2PC的阻塞问题以及其适用场景。