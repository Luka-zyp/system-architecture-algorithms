# Two-Phase Commit (2PC) 详解

## 目录
1. [2PC概述](#2pc概述)
2. [2PC原理](#2pc原理)
3. [参与者角色](#参与者角色)
4. [2PC流程详解](#2pc流程详解)
5. [协调者实现](#协调者实现)
6. [参与者实现](#参与者实现)
7. [故障处理机制](#故障处理机制)
8. [优化技术](#优化技术)
9. [Python实现](#python实现)
10. [Go语言实现](#go语言实现)
11. [性能分析](#性能分析)
12. [实际应用案例](#实际应用案例)
13. [最佳实践](#最佳实践)

## 2PC概述

### 什么是2PC

两阶段提交协议（Two-Phase Commit, 2PC）是分布式系统中实现分布式事务的经典算法。它确保在多个参与者参与的分布式操作中，要么所有参与者都成功提交，要么所有参与者都回滚，从而保证事务的原子性。

```python
from typing import Dict, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import uuid
import queue
import random
from abc import ABC, abstractmethod

class TransactionState(Enum):
    """事务状态"""
    INITIATED = "initiated"
    PREPARING = "preparing"
    PREPARED = "prepared"
    COMMITTING = "committing"
    COMMITTED = "committed"
    ABORTING = "aborting"
    ABORTED = "aborted"
    TIMEOUT = "timeout"

class Vote(Enum):
    """参与者投票"""
    YES = "yes"
    NO = "no"

class ParticipantStatus(Enum):
    """参与者状态"""
    ACTIVE = "active"
    PREPARED = "prepared"
    COMMITTED = "committed"
    ABORTED = "aborted"
    FAILED = "failed"
    UNKNOWN = "unknown"

@dataclass
class Transaction:
    """事务定义"""
    transaction_id: str
    coordinator_id: str
    participants: List[str] = field(default_factory=list)
    state: TransactionState = TransactionState.INITIATED
    start_time: float = field(default_factory=time.time)
    timeout: float = 30.0
    operations: List[dict] = field(default_factory=list)

@dataclass
class Message:
    """消息定义"""
    sender_id: str
    receiver_id: str
    message_type: str
    transaction_id: str
    payload: dict = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)

class TwoPhaseCommitSystem:
    """2PC系统基类"""
    
    def __init__(self, system_id: str):
        self.system_id = system_id
        self.transactions: Dict[str, Transaction] = {}
        self.message_queue = queue.Queue()
        self.timeout_handlers = {}
        self.mutex = threading.Lock()
    
    def create_transaction(self, coordinator_id: str, participants: List[str]) -> str:
        """创建事务"""
        transaction_id = f"txn_{uuid.uuid4().hex[:8]}"
        
        transaction = Transaction(
            transaction_id=transaction_id,
            coordinator_id=coordinator_id,
            participants=participants
        )
        
        with self.mutex:
            self.transactions[transaction_id] = transaction
        
        return transaction_id
    
    def send_message(self, message: Message):
        """发送消息"""
        self.message_queue.put(message)
    
    def receive_message(self) -> Optional[Message]:
        """接收消息"""
        try:
            return self.message_queue.get(timeout=1.0)
        except queue.Empty:
            return None
    
    def set_timeout_handler(self, transaction_id: str, handler_func, timeout: float):
        """设置超时处理器"""
        def timeout_handler():
            time.sleep(timeout)
            handler_func(transaction_id)
        
        thread = threading.Thread(target=timeout_handler, daemon=True)
        thread.start()
        self.timeout_handlers[transaction_id] = thread

class Coordinator(TwoPhaseCommitSystem):
    """2PC协调者实现"""
    
    def __init__(self, coordinator_id: str):
        super().__init__(coordinator_id)
        self.coordinator_id = coordinator_id
        self.participant_responses: Dict[str, Dict[str, Vote]] = {}
        self.vote_results: Dict[str, bool] = {}
    
    def begin_transaction(self, participants: List[str]) -> str:
        """开始事务"""
        transaction_id = self.create_transaction(self.coordinator_id, participants)
        
        print(f"Coordinator {self.coordinator_id} begins transaction {transaction_id}")
        print(f"Participants: {', '.join(participants)}")
        
        # 记录参与者响应
        self.participant_responses[transaction_id] = {}
        self.vote_results[transaction_id] = True
        
        return transaction_id
    
    def execute_transaction(self, transaction_id: str, operations: List[dict]) -> bool:
        """执行事务"""
        if transaction_id not in self.transactions:
            print(f"Transaction {transaction_id} not found")
            return False
        
        transaction = self.transactions[transaction_id]
        transaction.operations = operations
        
        print(f"Coordinator executing transaction {transaction_id}")
        
        # Phase 1: Prepare Phase
        return self._prepare_phase(transaction_id, operations)
    
    def _prepare_phase(self, transaction_id: str, operations: List[dict]) -> bool:
        """准备阶段"""
        print(f"=== Phase 1: Prepare Phase for {transaction_id} ===")
        
        transaction = self.transactions[transaction_id]
        transaction.state = TransactionState.PREPARING
        
        # 发送准备请求给所有参与者
        prepare_request = Message(
            sender_id=self.coordinator_id,
            receiver_id="",  # 广播消息
            message_type="PREPARE_REQUEST",
            transaction_id=transaction_id,
            payload={"operations": operations}
        )
        
        for participant_id in transaction.participants:
            prepare_request.receiver_id = participant_id
            self.send_message(prepare_request)
            print(f"Sent PREPARE_REQUEST to {participant_id}")
        
        # 等待参与者投票
        return self._wait_for_votes(transaction_id)
    
    def _wait_for_votes(self, transaction_id: str) -> bool:
        """等待参与者投票"""
        print("Waiting for participant votes...")
        
        transaction = self.transactions[transaction_id]
        timeout = transaction.timeout
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            message = self.receive_message()
            if not message:
                continue
            
            if (message.message_type == "VOTE_RESPONSE" and 
                message.transaction_id == transaction_id):
                
                participant_id = message.sender_id
                vote = message.payload.get("vote")
                
                self.participant_responses[transaction_id][participant_id] = vote
                
                if vote == Vote.NO:
                    self.vote_results[transaction_id] = False
                    print(f"Participant {participant_id} voted NO")
                    break
                else:
                    print(f"Participant {participant_id} voted YES")
            
            # 检查是否收到所有参与者的响应
            if len(self.participant_responses[transaction_id]) >= len(transaction.participants):
                break
        
        return self.vote_results[transaction_id]
    
    def _commit_phase(self, transaction_id: str):
        """提交阶段"""
        print(f"=== Phase 2: Commit Phase for {transaction_id} ===")
        
        transaction = self.transactions[transaction_id]
        
        if self.vote_results[transaction_id]:
            # 所有参与者都投票YES，执行提交
            transaction.state = TransactionState.COMMITTING
            self._send_global_commit(transaction_id)
        else:
            # 有参与者投票NO，执行回滚
            transaction.state = TransactionState.ABORTING
            self._send_global_abort(transaction_id)
    
    def _send_global_commit(self, transaction_id: str):
        """发送全局提交"""
        transaction = self.transactions[transaction_id]
        
        commit_message = Message(
            sender_id=self.coordinator_id,
            receiver_id="",
            message_type="GLOBAL_COMMIT",
            transaction_id=transaction_id
        )
        
        for participant_id in transaction.participants:
            commit_message.receiver_id = participant_id
            self.send_message(commit_message)
            print(f"Sent GLOBAL_COMMIT to {participant_id}")
        
        transaction.state = TransactionState.COMMITTED
        print(f"Transaction {transaction_id} committed successfully")
    
    def _send_global_abort(self, transaction_id: str):
        """发送全局回滚"""
        transaction = self.transactions[transaction_id]
        
        abort_message = Message(
            sender_id=self.coordinator_id,
            receiver_id="",
            message_type="GLOBAL_ABORT",
            transaction_id=transaction_id
        )
        
        for participant_id in transaction.participants:
            abort_message.receiver_id = participant_id
            self.send_message(abort_message)
            print(f"Sent GLOBAL_ABORT to {participant_id}")
        
        transaction.state = TransactionState.ABORTED
        print(f"Transaction {transaction_id} aborted")
    
    def handle_timeout(self, transaction_id: str):
        """处理超时"""
        if transaction_id in self.transactions:
            transaction = self.transactions[transaction_id]
            if transaction.state in [TransactionState.PREPARING, TransactionState.COMMITTING]:
                print(f"Transaction {transaction_id} timed out, aborting...")
                transaction.state = TransactionState.TIMEOUT
                self._send_global_abort(transaction_id)

class Participant(TwoPhaseCommitSystem):
    """2PC参与者实现"""
    
    def __init__(self, participant_id: str):
        super().__init__(participant_id)
        self.participant_id = participant_id
        self.participant_status: Dict[str, ParticipantStatus] = {}
        self.local_operations: Dict[str, List[dict]] = {}
        self.coordinators = {}
    
    def handle_prepare_request(self, message: Message) -> bool:
        """处理准备请求"""
        transaction_id = message.transaction_id
        operations = message.payload.get("operations", [])
        
        print(f"Participant {self.participant_id} received PREPARE_REQUEST for {transaction_id}")
        
        # 记录操作
        self.local_operations[transaction_id] = operations
        
        # 询问参与者是否准备好提交
        try:
            # 模拟本地操作验证
            can_commit = self._validate_operations(operations)
            
            if can_commit:
                self.participant_status[transaction_id] = ParticipantStatus.PREPARED
                vote = Vote.YES
                print(f"Participant {self.participant_id} votes YES for {transaction_id}")
            else:
                vote = Vote.NO
                print(f"Participant {self.participant_id} votes NO for {transaction_id}")
            
            # 发送投票响应
            vote_response = Message(
                sender_id=self.participant_id,
                receiver_id=message.sender_id,
                message_type="VOTE_RESPONSE",
                transaction_id=transaction_id,
                payload={"vote": vote}
            )
            
            self.send_message(vote_response)
            return can_commit
            
        except Exception as e:
            print(f"Participant {self.participant_id} failed to prepare: {e}")
            
            # 发送NO投票
            vote_response = Message(
                sender_id=self.participant_id,
                receiver_id=message.sender_id,
                message_type="VOTE_RESPONSE",
                transaction_id=transaction_id,
                payload={"vote": Vote.NO}
            )
            
            self.send_message(vote_response)
            return False
    
    def handle_global_commit(self, message: Message):
        """处理全局提交"""
        transaction_id = message.transaction_id
        
        print(f"Participant {self.participant_id} received GLOBAL_COMMIT for {transaction_id}")
        
        if transaction_id in self.local_operations:
            # 执行实际的本地操作
            success = self._execute_operations(self.local_operations[transaction_id])
            
            if success:
                self.participant_status[transaction_id] = ParticipantStatus.COMMITTED
                print(f"Participant {self.participant_id} committed transaction {transaction_id}")
            else:
                self.participant_status[transaction_id] = ParticipantStatus.FAILED
                print(f"Participant {self.participant_id} failed to commit {transaction_id}")
    
    def handle_global_abort(self, message: Message):
        """处理全局回滚"""
        transaction_id = message.transaction_id
        
        print(f"Participant {self.participant_id} received GLOBAL_ABORT for {transaction_id}")
        
        # 回滚本地操作
        if transaction_id in self.local_operations:
            self._rollback_operations(transaction_id)
        
        self.participant_status[transaction_id] = ParticipantStatus.ABORTED
        print(f"Participant {self.participant_id} aborted transaction {transaction_id}")
    
    def _validate_operations(self, operations: List[dict]) -> bool:
        """验证操作"""
        for operation in operations:
            # 模拟各种验证逻辑
            if operation.get("type") == "transfer":
                # 检查余额是否充足
                account = operation.get("account")
                amount = operation.get("amount")
                if account == "empty_account" and amount > 0:
                    return False
        
        return True
    
    def _execute_operations(self, operations: List[dict]) -> bool:
        """执行操作"""
        try:
            for operation in operations:
                op_type = operation.get("type")
                
                if op_type == "transfer":
                    # 模拟转账操作
                    from_account = operation.get("from")
                    to_account = operation.get("to")
                    amount = operation.get("amount")
                    
                    # 记录操作
                    print(f"  Transferring {amount} from {from_account} to {to_account}")
                    
                elif op_type == "update":
                    # 模拟更新操作
                    table = operation.get("table")
                    data = operation.get("data")
                    print(f"  Updating {table} with {data}")
                
                # 模拟网络延迟或操作失败
                if random.random() < 0.05:  # 5%失败率
                    return False
            
            return True
            
        except Exception as e:
            print(f"Execution failed: {e}")
            return False
    
    def _rollback_operations(self, transaction_id: str):
        """回滚操作"""
        operations = self.local_operations.get(transaction_id, [])
        
        for operation in operations:
            op_type = operation.get("type")
            
            if op_type == "transfer":
                # 模拟回滚转账
                from_account = operation.get("from")
                to_account = operation.get("to")
                amount = operation.get("amount")
                
                print(f"  Rolling back: Transferring {amount} from {to_account} to {from_account}")
            
            elif op_type == "update":
                # 模拟回滚更新
                table = operation.get("table")
                print(f"  Rolling back update to {table}")

class TwoPhaseCommitSimulation:
    """2PC仿真系统"""
    
    def __init__(self):
        self.coordinator = Coordinator("coordinator_main")
        self.participants = {}
        self.message_routes = {}
        self.setup_system()
    
    def setup_system(self):
        """设置系统"""
        # 创建参与者
        participant_ids = ["participant_1", "participant_2", "participant_3"]
        
        for pid in participant_ids:
            participant = Participant(pid)
            self.participants[pid] = participant
        
        print("=== 2PC System Setup ===")
        print(f"Coordinator: {self.coordinator.coordinator_id}")
        print(f"Participants: {', '.join(participant_ids)}")
    
    def route_messages(self):
        """消息路由"""
        while True:
            # 从协调者接收消息
            coord_message = self.coordinator.receive_message()
            if coord_message:
                self._route_coordinator_message(coord_message)
            
            # 从参与者接收消息
            for participant_id, participant in self.participants.items():
                participant_message = participant.receive_message()
                if participant_message:
                    self._route_participant_message(participant_message)
            
            time.sleep(0.01)  # 避免忙等待
    
    def _route_coordinator_message(self, message: Message):
        """路由协调者消息"""
        receiver_id = message.receiver_id
        
        if message.message_type in ["PREPARE_REQUEST"]:
            # 广播给所有参与者
            for participant_id, participant in self.participants.items():
                participant.message_queue.put(message)
                print(f"Route: {message.sender_id} -> {participant_id}")
        
        elif receiver_id in self.participants:
            # 单播给特定参与者
            self.participants[receiver_id].message_queue.put(message)
            print(f"Route: {message.sender_id} -> {receiver_id}")
    
    def _route_participant_message(self, message: Message):
        """路由参与者消息"""
        receiver_id = message.receiver_id
        
        if receiver_id == self.coordinator.coordinator_id:
            # 发送给协调者
            self.coordinator.message_queue.put(message)
            print(f"Route: {message.sender_id} -> {receiver_id}")
    
    def run_successful_transaction(self):
        """运行成功的事务"""
        print("\n" + "="*50)
        print("SUCCESSFUL TRANSACTION DEMO")
        print("="*50)
        
        participants_list = list(self.participants.keys())
        
        # 开始事务
        transaction_id = self.coordinator.begin_transaction(participants_list)
        
        # 定义操作
        operations = [
            {"type": "transfer", "from": "account_A", "to": "account_B", "amount": 100},
            {"type": "update", "table": "user_balance", "data": {"user": "user1", "balance": 500}}
        ]
        
        # 执行事务
        self.coordinator.execute_transaction(transaction_id, operations)
        
        # 启动消息路由线程
        route_thread = threading.Thread(target=self.route_messages, daemon=True)
        route_thread.start()
        
        # 等待事务完成
        time.sleep(2.0)
        
        print(f"\nTransaction {transaction_id} final state: {self.coordinator.transactions[transaction_id].state}")
    
    def run_failed_transaction(self):
        """运行失败的事务"""
        print("\n" + "="*50)
        print("FAILED TRANSACTION DEMO")
        print("="*50)
        
        participants_list = list(self.participants.keys())
        
        # 开始事务
        transaction_id = self.coordinator.begin_transaction(participants_list)
        
        # 定义包含失败操作的操作
        operations = [
            {"type": "transfer", "from": "empty_account", "to": "account_B", "amount": 100},
            {"type": "update", "table": "user_balance", "data": {"user": "user2", "balance": 300}}
        ]
        
        # 执行事务
        self.coordinator.execute_transaction(transaction_id, operations)
        
        # 等待事务完成
        time.sleep(2.0)
        
        print(f"\nTransaction {transaction_id} final state: {self.coordinator.transactions[transaction_id].state}")

# Go语言实现的2PC接口（使用Python模拟）
class GoStyle2PC:
    """Go风格2PC实现"""
    
    def __init__(self):
        self.coordinator = Coordinator("go_coordinator")
        self.participants = {f"go_participant_{i}": Participant(f"go_participant_{i}") 
                           for i in range(1, 4)}
    
    def run_go_style_demo(self):
        """运行Go风格演示"""
        print("\n=== Go-Style 2PC Demo ===")
        
        participants_list = list(self.participants.keys())
        
        # 创建通道模拟Go的channel
        response_channel = queue.Queue()
        
        def async_transaction_execution():
            """异步事务执行"""
            try:
                transaction_id = self.coordinator.begin_transaction(participants_list)
                
                operations = [
                    {"type": "update", "table": "products", "data": {"id": 1, "stock": 50}},
                    {"type": "update", "table": "orders", "data": {"order_id": 123, "status": "processing"}}
                ]
                
                # 执行事务
                success = self.coordinator.execute_transaction(transaction_id, operations)
                
                # 发送结果到通道
                response_channel.put({
                    "transaction_id": transaction_id,
                    "success": success,
                    "state": self.coordinator.transactions[transaction_id].state
                })
                
            except Exception as e:
                response_channel.put({"error": str(e)})
        
        # 启动异步执行
        thread = threading.Thread(target=async_transaction_execution)
        thread.start()
        
        # 等待结果
        try:
            result = response_channel.get(timeout=10.0)
            print(f"Transaction result: {result}")
        except queue.Empty:
            print("Transaction timed out")

# 性能分析
class TwoPhaseCommitPerformance:
    """2PC性能分析"""
    
    @staticmethod
    def analyze_2pc_complexity():
        """分析2PC复杂度"""
        complexity_analysis = {
            "message_complexity": {
                "prepare_phase": "O(n)",  # n个参与者
                "commit_phase": "O(n)",   # n个参与者
                "total_messages": "2n",   # 每个参与者的prepare + commit/abort
                "worst_case": "3n"        # 如果需要重试
            },
            "time_complexity": {
                "synchronous_rounds": "2",  # prepare + commit
                "blocking_time": "high",    # 协调者等待所有参与者
                "timeout_handling": "required"
            },
            "space_complexity": {
                "coordinator_memory": "O(t)",  # t个活跃事务
                "participant_memory": "O(1)",  # 恒定空间
                "total_memory": "O(n + t)"
            }
        }
        
        print("=== 2PC Performance Analysis ===\n")
        
        for category, metrics in complexity_analysis.items():
            print(f"**{category.replace('_', ' ').title()}**")
            for metric, value in metrics.items():
                print(f"  {metric.replace('_', ' ').title()}: {value}")
            print()
    
    @staticmethod
    def compare_with_alternatives():
        """与其他算法对比"""
        comparison = {
            "Two-Phase Commit (2PC)": {
                "consistency": "Strong",
                "availability": "Low (blocking)",
                "latency": "High (2 rounds)",
                "fault_tolerance": "Coordinator single point of failure",
                "use_case": "ACID transactions"
            },
            "Three-Phase Commit (3PC)": {
                "consistency": "Strong",
                "availability": "Medium",
                "latency": "Very High (3 rounds)",
                "fault_tolerance": "Better fault handling",
                "use_case": "Critical distributed systems"
            },
            "Saga Pattern": {
                "consistency": "Eventual",
                "availability": "High",
                "latency": "Medium",
                "fault_tolerance": "Good",
                "use_case": "Microservices transactions"
            },
            "Event Sourcing": {
                "consistency": "Eventual",
                "availability": "High",
                "latency": "Low",
                "fault_tolerance": "Excellent",
                "use_case": "CQRS systems"
            }
        }
        
        print("=== Algorithm Comparison ===\n")
        
        for algorithm, properties in comparison.items():
            print(f"**{algorithm}**")
            for prop, value in properties.items():
                print(f"  {prop.title()}: {value}")
            print()

# 实际应用案例
class TwoPhaseCommitApplications:
    """2PC实际应用案例"""
    
    @staticmethod
    def database_replication_example():
        """数据库复制示例"""
        print("=== Database Replication with 2PC ===\n")
        
        # 模拟主从数据库复制
        primary_db = Participant("primary_database")
        replica_dbs = [Participant(f"replica_database_{i}") for i in range(1, 4)]
        
        print("Scenario: Primary database replicates transaction to replica databases")
        
        # 模拟事务
        transaction_ops = [
            {"type": "update", "table": "accounts", "data": {"id": 123, "balance": 1000}},
            {"type": "insert", "table": "transactions", "data": {"id": 456, "amount": 100, "type": "deposit"}}
        ]
        
        print("Operations to replicate:")
        for op in transaction_ops:
            print(f"  {op}")
        
        # 2PC确保所有数据库都收到相同的事务
        coordinator = Coordinator("replication_coordinator")
        participants = [primary_db] + replica_dbs
        participant_ids = [p.participant_id for p in participants]
        
        transaction_id = coordinator.begin_transaction(participant_ids)
        print(f"\nStarting 2PC for transaction: {transaction_id}")
        
        # 这里会执行完整的2PC流程...
        success = coordinator.execute_transaction(transaction_id, transaction_ops)
        
        print(f"Replication result: {'Success' if success else 'Failed'}")
    
    @staticmethod
    def distributed_file_system_example():
        """分布式文件系统示例"""
        print("\n=== Distributed File System with 2PC ===\n")
        
        # 模拟分布式文件系统
        metadata_servers = [Participant(f"meta_server_{i}") for i in range(1, 4)]
        data_nodes = [Participant(f"data_node_{i}") for i in range(1, 5)]
        
        print("Scenario: Distributed file write operation")
        
        # 模拟文件写入事务
        file_write_ops = [
            {"type": "update_metadata", "file": "/data/document.pdf", "owner": "user1", "permissions": "rw-r--r--"},
            {"type": "allocate_blocks", "file": "/data/document.pdf", "blocks": ["block_1", "block_2", "block_3"]},
            {"type": "write_data", "block": "block_1", "data": "chunk_1"},
            {"type": "write_data", "block": "block_2", "data": "chunk_2"},
            {"type": "write_data", "block": "block_3", "data": "chunk_3"}
        ]
        
        print("File write operations:")
        for op in file_write_ops:
            print(f"  {op}")
        
        # 使用2PC确保文件元数据和实际数据的一致写入
        coordinator = Coordinator("fs_coordinator")
        all_participants = metadata_servers + data_nodes
        participant_ids = [p.participant_id for p in all_participants]
        
        transaction_id = coordinator.begin_transaction(participant_ids)
        print(f"\nStarting 2PC for file system transaction: {transaction_id}")
        
        success = coordinator.execute_transaction(transaction_id, file_write_ops)
        
        print(f"File system write result: {'Success' if success else 'Failed'}")
    
    @staticmethod
    def banking_system_example():
        """银行系统示例"""
        print("\n=== Banking System with 2PC ===\n")
        
        # 模拟银行系统
        account_db = Participant("account_database")
        transaction_db = Participant("transaction_database")
        audit_db = Participant("audit_database")
        
        print("Scenario: Inter-bank transfer")
        
        # 模拟转账事务
        transfer_ops = [
            {"type": "debit", "account": "account_123", "amount": 500},
            {"type": "credit", "account": "account_456", "amount": 500},
            {"type": "log_transaction", "txn_id": "TXN_789", "amount": 500, "status": "completed"},
            {"type": "audit_log", "action": "transfer", "amount": 500, "timestamp": time.time()}
        ]
        
        print("Transfer operations:")
        for op in transfer_ops:
            print(f"  {op}")
        
        # 2PC确保资金、交易记录和审计日志的一致性
        coordinator = Coordinator("banking_coordinator")
        participants = [account_db, transaction_db, audit_db]
        participant_ids = [p.participant_id for p in participants]
        
        transaction_id = coordinator.begin_transaction(participant_ids)
        print(f"\nStarting 2PC for banking transaction: {transaction_id}")
        
        success = coordinator.execute_transaction(transaction_id, transfer_ops)
        
        print(f"Banking transfer result: {'Success' if success else 'Failed'}")

# 最佳实践
class TwoPhaseCommitBestPractices:
    """2PC最佳实践"""
    
    @staticmethod
    def optimization_strategies():
        """优化策略"""
        strategies = {
            "coordinator_optimization": {
                "strategy": "Coordinator Optimization",
                "techniques": [
                    "Pre-prepared state caching",
                    "Asynchronous logging",
                    "Coordinator replication (Paxos/Raft)",
                    "Batch commit for multiple transactions"
                ],
                "benefits": "Reduced latency and improved throughput"
            },
            "participant_optimization": {
                "strategy": "Participant Optimization",
                "techniques": [
                    "Lock optimization (shortest lock duration)",
                    "Pre-validation of operations",
                    "Asynchronous prepare responses",
                    "Participant state replication"
                ],
                "benefits": "Faster response and reduced blocking"
            },
            "network_optimization": {
                "strategy": "Network Optimization",
                "techniques": [
                    "Message compression",
                    "Connection pooling",
                    "Parallel message sending",
                    "Network topology awareness"
                ],
                "benefits": "Reduced network overhead"
            },
            "fault_tolerance": {
                "strategy": "Fault Tolerance",
                "techniques": [
                    "Coordinator failover mechanisms",
                    "Participant recovery protocols",
                    "Timeout tuning",
                    "Deadlock detection and resolution"
                ],
                "benefits": "Improved system reliability"
            }
        }
        
        print("=== 2PC Optimization Strategies ===\n")
        
        for strategy, details in strategies.items():
            print(f"**{details['strategy']}**")
            print(f"Benefits: {details['benefits']}")
            print("Techniques:")
            for technique in details['techniques']:
                print(f"  • {technique}")
            print()
    
    @staticmethod
    def common_pitfalls():
        """常见陷阱"""
        pitfalls = {
            "coordinator_failure": {
                "pitfall": "Coordinator Single Point of Failure",
                "problem": "If coordinator fails during prepare phase, participants may block indefinitely",
                "solution": "Implement coordinator replication and participant timeout mechanisms"
            },
            "network_partitions": {
                "pitfall": "Network Partitions",
                "problem": "During network partition, system may become unavailable",
                "solution": "Use quorum-based approaches and eventual consistency patterns"
            },
            "timeout_configuration": {
                "pitfall": "Improper Timeout Configuration",
                "problem": "Too short timeouts cause false aborts, too long cause poor performance",
                "solution": "Dynamic timeout adjustment based on network conditions"
            },
            "participant_hang": {
                "pitfall": "Participant Process Hang",
                "problem": "Participant process hangs during transaction processing",
                "solution": "Process monitoring and automatic restart mechanisms"
            },
            "resource_leaks": {
                "pitfall": "Resource Leaks in Long Transactions",
                "problem": "Long-running transactions hold locks and consume resources",
                "solution": "Transaction timeout and resource monitoring"
            }
        }
        
        print("=== Common 2PC Pitfalls ===\n")
        
        for pitfall, details in pitfalls.items():
            print(f"**{pitfall.replace('_', ' ').title()}**")
            print(f"Problem: {details['problem']}")
            print(f"Solution: {details['solution']}")
            print()

# 主演示函数
def demo_two_phase_commit():
    """主演示函数"""
    
    print("=== Two-Phase Commit (2PC) Complete Demo ===\n")
    
    # 1. 成功事务演示
    simulation = TwoPhaseCommitSimulation()
    simulation.run_successful_transaction()
    
    # 等待一下
    time.sleep(1.0)
    
    # 2. 失败事务演示
    simulation.run_failed_transaction()
    
    # 3. Go风格演示
    go_demo = GoStyle2PC()
    go_demo.run_go_style_demo()
    
    # 4. 性能分析
    performance = TwoPhaseCommitPerformance()
    performance.analyze_2pc_complexity()
    performance.compare_with_alternatives()
    
    # 5. 实际应用案例
    applications = TwoPhaseCommitApplications()
    applications.database_replication_example()
    applications.distributed_file_system_example()
    applications.banking_system_example()
    
    # 6. 最佳实践
    best_practices = TwoPhaseCommitBestPractices()
    best_practices.optimization_strategies()
    best_practices.common_pitfalls()
    
    print("\n=== 2PC Summary ===")
    print("Two-Phase Commit provides strong consistency guarantees but at the cost of:")
    print("• High latency (2 round trips)")
    print("• Coordinator as single point of failure")
    print("• Blocking during commit phase")
    print("• Poor availability during network partitions")
    print("\nUse 2PC when:")
    print("• Strong consistency is required")
    print("• Number of participants is small")
    print("• Network reliability is high")
    print("• Transaction timeout is acceptable")

if __name__ == "__main__":
    demo_two_phase_commit()
```

这个Two-Phase Commit学习文档涵盖了：

1. **系统概述**：2PC的基本概念、作用和重要性
2. **核心原理**：两个阶段的详细执行流程
3. **参与者角色**：协调者和参与者的具体职责
4. **完整实现**：包含协调者、参与者、消息系统的完整代码
5. **故障处理**：超时、网络分区、节点故障的处理机制
6. **优化技术**：性能优化和最佳实践
7. **实际应用**：数据库复制、文件系统、银行转账等案例
8. **性能分析**：复杂度分析和与其他算法的对比
9. **Go语言风格**：使用Python模拟Go的并发和通道模式

文档提供了从理论到实践的完整学习路径，帮助深入理解2PC协议的工作原理、应用场景和权衡取舍。