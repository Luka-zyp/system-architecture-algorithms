# Resource-Based 负载均衡算法详解

## 目录
1. [算法概述](#算法概述)
2. [算法原理](#算法原理)
3. [Python实现](#python实现)
4. [Go语言实现](#go-language实现)
5. [资源监控](#资源监控)
6. [容量管理](#容量管理)
7. [性能分析](#性能分析)
8. [适用场景](#适用场景)
9. [故障处理](#故障处理)
10. [监控指标](#监控指标)
11. [实战案例](#实战案例)

## 算法概述

### 什么是Resource-Based负载均衡

Resource-Based（基于资源）负载均衡算法是一种智能负载分发策略，它基于服务器的实际资源使用情况（CPU、内存、磁盘、网络等）来做出负载分配决策。该算法能够根据当前系统的实际负载状态，动态调整请求分配，确保资源的高效利用和系统的稳定运行。

### 核心特性

```python
from typing import List, Dict, Optional, Any, Tuple, Callable, Union, Deque
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import statistics
import random
import logging
import psutil
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor, as_completed
import copy
from abc import ABC, abstractmethod
import json
import math
import platform

@dataclass
class ResourceMetrics:
    """资源指标"""
    # CPU指标
    cpu_usage: float = 0.0
    cpu_load_1min: float = 0.0
    cpu_load_5min: float = 0.0
    cpu_load_15min: float = 0.0
    cpu_cores: int = 1
    cpu_frequency: float = 0.0
    
    # 内存指标
    memory_usage: float = 0.0
    memory_available: float = 0.0
    memory_total: float = 0.0
    memory_cache: float = 0.0
    memory_buffer: float = 0.0
    
    # 磁盘指标
    disk_usage: float = 0.0
    disk_read_speed: float = 0.0
    disk_write_speed: float = 0.0
    disk_io_utilization: float = 0.0
    
    # 网络指标
    network_in_bytes: float = 0.0
    network_out_bytes: float = 0.0
    network_in_packets: float = 0.0
    network_out_packets: float = 0.0
    network_utilization: float = 0.0
    
    # 进程指标
    process_count: int = 0
    thread_count: int = 0
    file_descriptor_count: int = 0
    
    # 连接指标
    active_connections: int = 0
    connection_utilization: float = 0.0
    
    # 时间戳
    timestamp: float = field(default_factory=time.time)
    
    def update_from_psutil(self):
        """从psutil更新指标"""
        try:
            # CPU指标
            self.cpu_usage = psutil.cpu_percent(interval=0.1)
            load_avg = psutil.getloadavg() if hasattr(psutil, 'getloadavg') else (0, 0, 0)
            self.cpu_load_1min = load_avg[0] if len(load_avg) > 0 else 0
            self.cpu_load_5min = load_avg[1] if len(load_avg) > 1 else 0
            self.cpu_load_15min = load_avg[2] if len(load_avg) > 2 else 0
            self.cpu_cores = psutil.cpu_count()
            self.cpu_frequency = psutil.cpu_freq().current if psutil.cpu_freq() else 0
            
            # 内存指标
            memory = psutil.virtual_memory()
            self.memory_usage = memory.percent
            self.memory_available = memory.available
            self.memory_total = memory.total
            self.memory_cache = getattr(memory, 'cached', 0)
            self.memory_buffer = getattr(memory, 'buffers', 0)
            
            # 磁盘指标
            disk = psutil.disk_usage('/')
            self.disk_usage = disk.used / disk.total * 100
            
            # 获取磁盘IO统计
            disk_io = psutil.disk_io_counters()
            if disk_io:
                self.disk_read_speed = disk_io.read_bytes
                self.disk_write_speed = disk_io.write_bytes
            
            # 网络指标
            net_io = psutil.net_io_counters()
            if net_io:
                self.network_in_bytes = net_io.bytes_recv
                self.network_out_bytes = net_io.bytes_sent
                self.network_in_packets = net_io.packets_recv
                self.network_out_packets = net_io.packets_sent
            
            # 进程指标
            self.process_count = len(psutil.pids())
            
            self.timestamp = time.time()
            
        except Exception as e:
            logging.error(f"Failed to update metrics from psutil: {e}")
    
    def get_resource_score(self, weights: Dict[str, float] = None) -> float:
        """计算综合资源分数"""
        if weights is None:
            weights = {
                "cpu": 0.3,
                "memory": 0.3,
                "disk": 0.2,
                "network": 0.2
            }
        
        # CPU分数（使用率越低分数越高）
        cpu_score = max(0, 100 - self.cpu_usage)
        
        # 内存分数
        memory_score = max(0, 100 - self.memory_usage)
        
        # 磁盘分数
        disk_score = max(0, 100 - self.disk_usage)
        
        # 网络分数（基于当前活动连接）
        network_score = max(0, 100 - self.connection_utilization)
        
        # 加权计算总分
        total_score = (
            cpu_score * weights["cpu"] +
            memory_score * weights["memory"] +
            disk_score * weights["disk"] +
            network_score * weights["network"]
        )
        
        return total_score
    
    def is_overloaded(self, thresholds: Dict[str, float] = None) -> bool:
        """检查是否过载"""
        if thresholds is None:
            thresholds = {
                "cpu": 80.0,
                "memory": 85.0,
                "disk": 90.0,
                "network": 75.0
            }
        
        return (
            self.cpu_usage > thresholds["cpu"] or
            self.memory_usage > thresholds["memory"] or
            self.disk_usage > thresholds["disk"] or
            self.connection_utilization > thresholds["network"]
        )
    
    def get_available_capacity(self, total_capacity: float = 100.0) -> float:
        """获取可用容量"""
        resource_score = self.get_resource_score()
        return (resource_score / 100.0) * total_capacity
    
    def get_resource_pressure(self) -> str:
        """获取资源压力等级"""
        score = self.get_resource_score()
        
        if score >= 80:
            return "Low"
        elif score >= 60:
            return "Medium"
        elif score >= 40:
            return "High"
        else:
            return "Critical"

@dataclass
class ServerResource:
    """服务器资源信息"""
    server_id: str
    hostname: str
    port: int
    
    # 基础配置
    max_capacity: float = 1000.0
    reserved_capacity: float = 100.0  # 预留容量
    
    # 当前指标
    current_metrics: ResourceMetrics = field(default_factory=ResourceMetrics)
    historical_metrics: List[ResourceMetrics] = field(default_factory=list)
    
    # 应用级指标
    active_requests: int = 0
    request_queue_size: int = 0
    average_request_duration: float = 0.0
    request_throughput: float = 0.0
    
    # 健康状态
    is_healthy: bool = True
    last_health_check: float = field(default_factory=time.time)
    health_check_failures: int = 0
    
    # 性能历史
    performance_history: Deque[float] = field(default_factory=lambda: deque(maxlen=100))
    
    def update_metrics(self):
        """更新资源指标"""
        self.current_metrics.update_from_psutil()
        self.historical_metrics.append(copy.deepcopy(self.current_metrics))
        
        # 保持历史记录不超过1000条
        if len(self.historical_metrics) > 1000:
            self.historical_metrics = self.historical_metrics[-1000:]
    
    def get_capacity_utilization(self) -> float:
        """获取容量利用率"""
        available_capacity = self.current_metrics.get_available_capacity(self.max_capacity)
        used_capacity = self.max_capacity - available_capacity
        return used_capacity / self.max_capacity
    
    def get_effective_capacity(self) -> float:
        """获取有效容量（考虑健康状态）"""
        if not self.is_healthy:
            return 0.0
        
        base_capacity = self.current_metrics.get_available_capacity(self.max_capacity)
        health_factor = min(1.0, self.performance_health_factor())
        
        return base_capacity * health_factor
    
    def performance_health_factor(self) -> float:
        """性能健康因子"""
        if not self.performance_history:
            return 1.0
        
        recent_performance = list(self.performance_history)[-10:]
        if not recent_performance:
            return 1.0
        
        avg_performance = sum(recent_performance) / len(recent_performance)
        return max(0.1, min(1.0, avg_performance / 100.0))
    
    def can_handle_request(self, request_cost: float = 1.0) -> bool:
        """检查是否可以处理请求"""
        if not self.is_healthy:
            return False
        
        effective_capacity = self.get_effective_capacity()
        required_capacity = request_cost + self.reserved_capacity
        
        return effective_capacity >= required_capacity
    
    def update_performance(self, request_duration: float, request_cost: float = 1.0):
        """更新性能指标"""
        # 更新请求计数
        self.active_requests += 1
        
        # 更新平均请求持续时间
        if self.active_requests == 1:
            self.average_request_duration = request_duration
        else:
            self.average_request_duration = (
                (self.average_request_duration * (self.active_requests - 1) + request_duration) /
                self.active_requests
            )
        
        # 更新性能历史
        # 请求持续时间越短，性能分数越高
        performance_score = max(0, 100 - (request_duration / 1000.0))
        self.performance_history.append(performance_score)
        
        # 模拟完成请求
        self.active_requests = max(0, self.active_requests - 1)
    
    def get_resource_recommendations(self) -> List[str]:
        """获取资源优化建议"""
        recommendations = []
        metrics = self.current_metrics
        
        # CPU建议
        if metrics.cpu_usage > 80:
            recommendations.append("Consider reducing CPU-intensive operations")
            recommendations.append("Scale out to add more CPU cores")
        
        if metrics.cpu_load_1min > metrics.cpu_cores * 2:
            recommendations.append("High CPU load detected - investigate running processes")
        
        # 内存建议
        if metrics.memory_usage > 85:
            recommendations.append("High memory usage - check for memory leaks")
            recommendations.append("Consider adding more RAM")
        
        if metrics.memory_available < metrics.memory_total * 0.1:
            recommendations.append("Low memory available - restart services or scale up")
        
        # 磁盘建议
        if metrics.disk_usage > 90:
            recommendations.append("Disk space critically low - clean up or scale storage")
        
        # 网络建议
        if metrics.connection_utilization > 75:
            recommendations.append("High network utilization - check for network bottlenecks")
        
        return recommendations

class ResourceWeightStrategy(Enum):
    """资源权重策略"""
    EQUAL_WEIGHT = "equal"          # 相等权重
    CPU_HEAVY = "cpu_heavy"        # CPU密集型
    MEMORY_HEAVY = "memory_heavy"  # 内存密集型
    IO_HEAVY = "io_heavy"          # IO密集型
    CUSTOM = "custom"              # 自定义

class LoadBalancingStrategy(Enum):
    """负载均衡策略"""
    LEAST_LOADED = "least_loaded"           # 最小负载
    ROUND_ROBIN_WEIGHTED = "rr_weighted"   # 加权轮询
    RESOURCE_AWARE = "resource_aware"      # 资源感知
    PREDICTIVE = "predictive"              # 预测性

class ResourceBasedLoadBalancer:
    """基于资源的负载均衡器"""
    
    def __init__(self,
                 weight_strategy: ResourceWeightStrategy = ResourceWeightStrategy.EQUAL_WEIGHT,
                 load_strategy: LoadBalancingStrategy = LoadBalancingStrategy.RESOURCE_AWARE,
                 health_check_interval: float = 30.0,
                 metrics_update_interval: float = 5.0):
        
        self.weight_strategy = weight_strategy
        self.load_strategy = load_strategy
        self.health_check_interval = health_check_interval
        self.metrics_update_interval = metrics_update_interval
        
        # 服务器管理
        self.servers: Dict[str, ServerResource] = {}
        
        # 状态管理
        self.mutex = threading.RLock()
        self.last_metrics_update = 0
        self.last_health_check = 0
        
        # 性能统计
        self.metrics = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "resource_violations": 0,
            "server_selections": 0,
            "average_selection_time": 0.0,
            "capacity_utilization": {}
        }
        
        # 权重配置
        self.resource_weights = self._get_default_weights()
        
        # 设置日志
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("ResourceBased")
        
        # 启动监控线程
        self._start_monitoring()
    
    def _get_default_weights(self) -> Dict[str, float]:
        """获取默认权重配置"""
        if self.weight_strategy == ResourceWeightStrategy.EQUAL_WEIGHT:
            return {"cpu": 0.25, "memory": 0.25, "disk": 0.25, "network": 0.25}
        elif self.weight_strategy == ResourceWeightStrategy.CPU_HEAVY:
            return {"cpu": 0.5, "memory": 0.2, "disk": 0.15, "network": 0.15}
        elif self.weight_strategy == ResourceWeightStrategy.MEMORY_HEAVY:
            return {"cpu": 0.2, "memory": 0.5, "disk": 0.15, "network": 0.15}
        elif self.weight_strategy == ResourceWeightStrategy.IO_HEAVY:
            return {"cpu": 0.15, "memory": 0.15, "disk": 0.35, "network": 0.35}
        else:
            return {"cpu": 0.25, "memory": 0.25, "disk": 0.25, "network": 0.25}
    
    def add_server(self, server_id: str, hostname: str, port: int, max_capacity: float = 1000.0):
        """添加服务器"""
        with self.mutex:
            if server_id not in self.servers:
                self.servers[server_id] = ServerResource(
                    server_id=server_id,
                    hostname=hostname,
                    port=port,
                    max_capacity=max_capacity
                )
                
                # 立即更新一次指标
                self.servers[server_id].update_metrics()
                
                self.logger.info(f"Added server {hostname}:{port} with capacity {max_capacity}")
            else:
                self.logger.warning(f"Server {server_id} already exists")
    
    def remove_server(self, server_id: str):
        """移除服务器"""
        with self.mutex:
            if server_id in self.servers:
                del self.servers[server_id]
                self.logger.info(f"Removed server {server_id}")
    
    def _start_monitoring(self):
        """启动监控线程"""
        def monitor_loop():
            while True:
                try:
                    self._update_all_metrics()
                    self._perform_health_checks()
                    time.sleep(self.metrics_update_interval)
                except Exception as e:
                    self.logger.error(f"Monitoring error: {e}")
                    time.sleep(5)
        
        monitor_thread = threading.Thread(target=monitor_loop, daemon=True)
        monitor_thread.start()
        self.logger.info("Started resource monitoring thread")
    
    def _update_all_metrics(self):
        """更新所有服务器指标"""
        current_time = time.time()
        
        if current_time - self.last_metrics_update < self.metrics_update_interval:
            return
        
        with self.mutex:
            for server in self.servers.values():
                try:
                    server.update_metrics()
                except Exception as e:
                    self.logger.error(f"Failed to update metrics for {server.server_id}: {e}")
            
            self.last_metrics_update = current_time
    
    def _perform_health_checks(self):
        """执行健康检查"""
        current_time = time.time()
        
        if current_time - self.last_health_check < self.health_check_interval:
            return
        
        with self.mutex:
            for server in self.servers.values():
                self._check_server_health(server)
            
            self.last_health_check = current_time
    
    def _check_server_health(self, server: ServerResource):
        """检查服务器健康状态"""
        try:
            metrics = server.current_metrics
            
            # 基于资源使用情况判断健康状态
            was_healthy = server.is_healthy
            
            # 健康状态检查
            server.is_healthy = not metrics.is_overloaded()
            
            if not server.is_healthy:
                server.health_check_failures += 1
                if was_healthy:
                    self.logger.warning(f"Server {server.server_id} marked unhealthy due to resource overload")
            else:
                if not was_healthy:
                    self.logger.info(f"Server {server.server_id} recovered to healthy state")
                server.health_check_failures = 0
            
        except Exception as e:
            self.logger.error(f"Health check failed for {server.server_id}: {e}")
            server.is_healthy = False
            server.health_check_failures += 1
    
    def select_server(self, request_cost: float = 1.0) -> Optional[ServerResource]:
        """选择服务器"""
        start_time = time.time()
        
        with self.mutex:
            if not self.servers:
                self.logger.warning("No servers available")
                return None
            
            # 获取候选服务器
            candidates = self._get_candidate_servers(request_cost)
            
            if not candidates:
                self.logger.warning("No healthy servers can handle the request")
                return None
            
            # 根据策略选择服务器
            selected_server = self._apply_selection_strategy(candidates, request_cost)
            
            if selected_server:
                self.metrics["server_selections"] += 1
                
                # 更新选择时间统计
                selection_time = time.time() - start_time
                current_avg = self.metrics["average_selection_time"]
                total_selections = self.metrics["server_selections"]
                
                if total_selections == 1:
                    self.metrics["average_selection_time"] = selection_time
                else:
                    self.metrics["average_selection_time"] = (
                        (current_avg * (total_selections - 1) + selection_time) / total_selections
                    )
                
                self.logger.debug(f"Selected server {selected_server.server_id} "
                                f"(effective capacity: {selected_server.get_effective_capacity():.1f})")
            
            return selected_server
    
    def _get_candidate_servers(self, request_cost: float) -> List[ServerResource]:
        """获取候选服务器列表"""
        candidates = []
        
        for server in self.servers.values():
            if server.can_handle_request(request_cost):
                candidates.append(server)
        
        return candidates
    
    def _apply_selection_strategy(self, candidates: List[ServerResource], 
                                request_cost: float) -> Optional[ServerResource]:
        """应用选择策略"""
        if not candidates:
            return None
        
        if self.load_strategy == LoadBalancingStrategy.LEAST_LOADED:
            return self._select_least_loaded(candidates)
        elif self.load_strategy == LoadBalancingStrategy.ROUND_ROBIN_WEIGHTED:
            return self._select_weighted_round_robin(candidates)
        elif self.load_strategy == LoadBalancingStrategy.RESOURCE_AWARE:
            return self._select_resource_aware(candidates)
        elif self.load_strategy == LoadBalancingStrategy.PREDICTIVE:
            return self._select_predictive(candidates)
        else:
            return candidates[0]
    
    def _select_least_loaded(self, candidates: List[ServerResource]) -> ServerResource:
        """选择负载最轻的服务器"""
        return min(candidates, key=lambda s: s.get_capacity_utilization())
    
    def _select_weighted_round_robin(self, candidates: List[ServerResource]) -> ServerResource:
        """选择加权轮询"""
        # 计算每台服务器的权重
        weights = []
        total_weight = 0
        
        for server in candidates:
            effective_capacity = server.get_effective_capacity()
            if effective_capacity > 0:
                weight = effective_capacity / server.max_capacity
                weights.append(weight)
                total_weight += weight
            else:
                weights.append(0)
        
        if total_weight == 0:
            return candidates[0]
        
        # 生成随机数选择服务器
        import random
        random_weight = random.uniform(0, total_weight)
        cumulative_weight = 0
        
        for i, (server, weight) in enumerate(zip(candidates, weights)):
            cumulative_weight += weight
            if random_weight <= cumulative_weight:
                return server
        
        return candidates[-1]
    
    def _select_resource_aware(self, candidates: List[ServerResource]) -> ServerResource:
        """选择资源感知（最佳资源分数）"""
        best_server = candidates[0]
        best_score = best_server.current_metrics.get_resource_score(self.resource_weights)
        
        for server in candidates[1:]:
            score = server.current_metrics.get_resource_score(self.resource_weights)
            if score > best_score:
                best_score = score
                best_server = server
        
        return best_server
    
    def _select_predictive(self, candidates: List[ServerResource]) -> ServerResource:
        """选择预测性（考虑趋势）"""
        best_server = candidates[0]
        best_predictive_score = self._calculate_predictive_score(best_server)
        
        for server in candidates[1:]:
            score = self._calculate_predictive_score(server)
            if score > best_predictive_score:
                best_predictive_score = score
                best_server = server
        
        return best_server
    
    def _calculate_predictive_score(self, server: ServerResource) -> float:
        """计算预测性分数"""
        # 当前资源分数
        current_score = server.current_metrics.get_resource_score(self.resource_weights)
        
        # 历史趋势分数
        if len(server.historical_metrics) >= 10:
            recent_scores = []
            for metrics in server.historical_metrics[-10:]:
                score = metrics.get_resource_score(self.resource_weights)
                recent_scores.append(score)
            
            # 计算趋势（简单线性回归）
            if len(recent_scores) >= 5:
                n = len(recent_scores)
                x_mean = (n - 1) / 2
                y_mean = sum(recent_scores) / n
                
                numerator = sum((i - x_mean) * (recent_scores[i] - y_mean) for i in range(n))
                denominator = sum((i - x_mean) ** 2 for i in range(n))
                
                trend_slope = numerator / denominator if denominator != 0 else 0
                
                # 趋势预测（预测下一个时间点的分数）
                predicted_score = current_score + trend_slope
                
                # 权衡当前分数和预测分数
                if trend_slope > 0:  # 性能在改善
                    combined_score = current_score * 0.7 + predicted_score * 0.3
                else:  # 性能在恶化或稳定
                    combined_score = current_score * 0.9 + predicted_score * 0.1
                
                return combined_score
        
        return current_score
    
    def process_request(self, server: ServerResource, request_duration: float, 
                       request_cost: float = 1.0) -> bool:
        """处理请求"""
        try:
            # 更新服务器性能指标
            server.update_performance(request_duration, request_cost)
            
            # 更新全局统计
            with self.mutex:
                self.metrics["total_requests"] += 1
                self.metrics["successful_requests"] += 1
            
            # 检查资源违规
            if server.current_metrics.is_overloaded():
                with self.mutex:
                    self.metrics["resource_violations"] += 1
                    self.logger.warning(f"Resource violation on {server.server_id}: "
                                      f"CPU={server.current_metrics.cpu_usage:.1f}%, "
                                      f"Memory={server.current_metrics.memory_usage:.1f}%")
            
            return True
            
        except Exception as e:
            with self.mutex:
                self.metrics["failed_requests"] += 1
            self.logger.error(f"Request processing failed: {e}")
            return False
    
    def get_system_overview(self) -> Dict[str, Any]:
        """获取系统概览"""
        with self.mutex:
            if not self.servers:
                return {"error": "No servers registered"}
            
            # 计算全局统计
            total_capacity = sum(server.max_capacity for server in self.servers.values())
            total_effective_capacity = sum(server.get_effective_capacity() 
                                         for server in self.servers.values())
            total_requests = sum(server.active_requests for server in self.servers.values())
            
            # 健康状态统计
            healthy_servers = sum(1 for server in self.servers.values() if server.is_healthy)
            overloaded_servers = sum(1 for server in self.servers.values() 
                                   if server.current_metrics.is_overloaded())
            
            # 资源聚合
            avg_cpu = statistics.mean(server.current_metrics.cpu_usage 
                                    for server in self.servers.values())
            avg_memory = statistics.mean(server.current_metrics.memory_usage 
                                       for server in self.servers.values())
            avg_disk = statistics.mean(server.current_metrics.disk_usage 
                                     for server in self.servers.values())
            avg_network = statistics.mean(server.current_metrics.connection_utilization 
                                        for server in self.servers.values())
            
            return {
                "timestamp": time.time(),
                "system_stats": {
                    "total_servers": len(self.servers),
                    "healthy_servers": healthy_servers,
                    "overloaded_servers": overloaded_servers,
                    "system_health_score": (healthy_servers / len(self.servers)) * 100
                },
                "capacity_stats": {
                    "total_capacity": total_capacity,
                    "effective_capacity": total_effective_capacity,
                    "capacity_utilization": 1.0 - (total_effective_capacity / total_capacity),
                    "active_requests": total_requests
                },
                "resource_stats": {
                    "average_cpu_usage": avg_cpu,
                    "average_memory_usage": avg_memory,
                    "average_disk_usage": avg_disk,
                    "average_network_utilization": avg_network
                },
                "performance_metrics": {
                    "total_requests": self.metrics["total_requests"],
                    "success_rate": (self.metrics["successful_requests"] / 
                                   max(1, self.metrics["total_requests"])) * 100,
                    "resource_violations": self.metrics["resource_violations"],
                    "average_selection_time": self.metrics["average_selection_time"]
                },
                "configuration": {
                    "weight_strategy": self.weight_strategy.value,
                    "load_strategy": self.load_strategy.value,
                    "resource_weights": self.resource_weights
                }
            }
    
    def get_server_details(self) -> Dict[str, Any]:
        """获取服务器详细信息"""
        with self.mutex:
            server_details = {}
            
            for server_id, server in self.servers.items():
                metrics = server.current_metrics
                
                # 计算资源压力
                resource_pressure = metrics.get_resource_pressure()
                
                # 获取性能趋势
                performance_trend = "stable"
                if len(server.historical_metrics) >= 5:
                    recent_avg = statistics.mean([m.get_resource_score(self.resource_weights) 
                                                for m in list(server.historical_metrics)[-5:]])
                    historical_avg = statistics.mean([m.get_resource_score(self.resource_weights) 
                                                    for m in list(server.historical_metrics)[-10:-5]])
                    
                    if recent_avg > historical_avg * 1.1:
                        performance_trend = "improving"
                    elif recent_avg < historical_avg * 0.9:
                        performance_trend = "degrading"
                
                server_details[server_id] = {
                    "basic_info": {
                        "hostname": server.hostname,
                        "port": server.port,
                        "max_capacity": server.max_capacity,
                        "reserved_capacity": server.reserved_capacity,
                        "is_healthy": server.is_healthy,
                        "health_check_failures": server.health_check_failures
                    },
                    "resource_metrics": {
                        "cpu_usage": metrics.cpu_usage,
                        "cpu_load_1min": metrics.cpu_load_1min,
                        "memory_usage": metrics.memory_usage,
                        "memory_available": metrics.memory_available,
                        "disk_usage": metrics.disk_usage,
                        "network_utilization": metrics.connection_utilization,
                        "active_connections": metrics.active_connections
                    },
                    "capacity_info": {
                        "capacity_utilization": server.get_capacity_utilization(),
                        "effective_capacity": server.get_effective_capacity(),
                        "available_capacity": (server.get_effective_capacity() - server.active_requests),
                        "resource_pressure": resource_pressure
                    },
                    "performance_info": {
                        "active_requests": server.active_requests,
                        "average_request_duration": server.average_request_duration,
                        "performance_history_size": len(server.performance_history),
                        "performance_health_factor": server.performance_health_factor(),
                        "performance_trend": performance_trend
                    },
                    "recommendations": server.get_resource_recommendations()
                }
            
            return server_details
    
    def simulate_system_load(self, duration: float = 60.0, requests_per_second: int = 100,
                           request_cost_variance: float = 0.3) -> Dict[str, Any]:
        """仿真系统负载"""
        print(f"Starting system load simulation: {requests_per_second} req/s for {duration} seconds")
        
        start_time = time.time()
        request_count = 0
        server_request_counts = defaultdict(int)
        request_durations = []
        resource_violations = 0
        failed_requests = 0
        
        while time.time() - start_time < duration:
            request_start = time.time()
            
            # 选择服务器
            # 随机请求成本
            request_cost = max(0.1, random.normalvariate(1.0, request_cost_variance))
            
            selected_server = self.select_server(request_cost)
            
            if selected_server:
                server_id = selected_server.server_id
                server_request_counts[server_id] += 1
                
                # 模拟请求持续时间
                # 基于当前资源使用情况
                base_duration = random.uniform(50, 500)  # 基础50-500ms
                
                # 资源影响因子
                resource_factor = (
                    (selected_server.current_metrics.cpu_usage / 100.0) * 0.3 +
                    (selected_server.current_metrics.memory_usage / 100.0) * 0.3 +
                    (selected_server.current_metrics.connection_utilization / 100.0) * 0.2 +
                    (selected_server.get_capacity_utilization()) * 0.2
                )
                
                request_duration = base_duration * (1 + resource_factor)
                
                # 处理请求
                success = self.process_request(selected_server, request_duration, request_cost)
                
                if success:
                    request_durations.append(request_duration)
                else:
                    failed_requests += 1
                
                request_count += 1
                
                # 检查资源违规
                if selected_server.current_metrics.is_overloaded():
                    resource_violations += 1
                
                # 模拟请求处理时间
                processing_time = request_duration / 1000.0
                time.sleep(min(0.1, processing_time / 10))  # 加速仿真
            
            else:
                failed_requests += 1
                request_count += 1
            
            # 控制请求频率
            elapsed = time.time() - request_start
            sleep_time = max(0, (1.0 / requests_per_second) - elapsed)
            time.sleep(sleep_time)
        
        # 收集结果
        end_time = time.time()
        actual_duration = end_time - start_time
        
        # 获取最终系统状态
        system_overview = self.get_system_overview()
        server_details = self.get_server_details()
        
        return {
            "simulation_config": {
                "duration": duration,
                "requested_rps": requests_per_second,
                "actual_duration": actual_duration,
                "request_cost_variance": request_cost_variance
            },
            "results": {
                "total_requests": request_count,
                "successful_requests": request_count - failed_requests,
                "failed_requests": failed_requests,
                "success_rate": ((request_count - failed_requests) / request_count * 100) if request_count > 0 else 0,
                "actual_rps": request_count / actual_duration,
                "request_durations": {
                    "count": len(request_durations),
                    "mean": statistics.mean(request_durations) if request_durations else 0,
                    "median": statistics.median(request_durations) if request_durations else 0,
                    "min": min(request_durations) if request_durations else 0,
                    "max": max(request_durations) if request_durations else 0,
                    "std": statistics.stdev(request_durations) if len(request_durations) > 1 else 0
                },
                "server_distribution": dict(server_request_counts),
                "resource_violations": resource_violations,
                "resource_violation_rate": (resource_violations / request_count * 100) if request_count > 0 else 0
            },
            "final_system_state": system_overview,
            "server_details": server_details
        }

class GoStyleResourceLoadBalancer:
    """Go语言风格的资源负载均衡器"""
    
    def __init__(self, servers: List[Dict[str, Any]]):
        self.servers = servers
        self.metrics = {server["id"]: ResourceMetrics() for server in servers}
        self.lock = threading.Lock()
        self.next_server_index = 0
    
    def UpdateMetrics(self, server_id: str, metrics: ResourceMetrics):
        """更新指标（Go风格）"""
        with self.lock:
            if server_id in self.metrics:
                self.metrics[server_id] = metrics
    
    def GetBestServer(self, request_cost: float = 1.0) -> Optional[str]:
        """获取最佳服务器"""
        with self.lock:
            if not self.metrics:
                return None
            
            best_server = None
            best_score = -1
            
            for server in self.servers:
                server_id = server["id"]
                if server_id in self.metrics:
                    metrics = self.metrics[server_id]
                    
                    if not metrics.is_overloaded():
                        score = metrics.get_resource_score()
                        
                        if score > best_score:
                            best_score = score
                            best_server = server_id
            
            return best_server
    
    def GetServerWithRoundRobin(self) -> Optional[str]:
        """轮询获取服务器"""
        with self.lock:
            if not self.servers:
                return None
            
            # 尝试找到下一个健康的服务器
            for i in range(len(self.servers)):
                index = (self.next_server_index + i) % len(self.servers)
                server_id = self.servers[index]["id"]
                
                if server_id in self.metrics:
                    metrics = self.metrics[server_id]
                    if not metrics.is_overloaded():
                        self.next_server_index = (index + 1) % len(self.servers)
                        return server_id
            
            # 如果没有健康的服务器，返回第一个（降级处理）
            self.next_server_index = (self.next_server_index + 1) % len(self.servers)
            return self.servers[0]["id"] if self.servers else None
    
    def GetSystemStatus(self) -> Dict[str, Any]:
        """获取系统状态"""
        with self.lock:
            total_servers = len(self.servers)
            healthy_servers = 0
            total_resource_score = 0
            
            for server_id, metrics in self.metrics.items():
                if not metrics.is_overloaded():
                    healthy_servers += 1
                total_resource_score += metrics.get_resource_score()
            
            avg_resource_score = total_resource_score / total_servers if total_servers > 0 else 0
            
            return {
                "total_servers": total_servers,
                "healthy_servers": healthy_servers,
                "health_percentage": (healthy_servers / total_servers * 100) if total_servers > 0 else 0,
                "average_resource_score": avg_resource_score,
                "system_status": "healthy" if healthy_servers == total_servers else "degraded" if healthy_servers > 0 else "unhealthy"
            }

# 主演示函数
def demo_resource_based_load_balancing():
    """主演示函数"""
    
    print("=== Resource-Based Load Balancer Demo ===\n")
    
    # 1. 基础资源负载均衡器演示
    print("1. Basic Resource-Based Load Balancer")
    print("="*50)
    
    lb = ResourceBasedLoadBalancer(
        weight_strategy=ResourceWeightStrategy.EQUAL_WEIGHT,
        load_strategy=LoadBalancingStrategy.RESOURCE_AWARE
    )
    
    # 添加测试服务器
    servers = [
        ("server1", "web1.example.com", 8080, 1000.0),
        ("server2", "web2.example.com", 8080, 1500.0),
        ("server3", "web3.example.com", 8080, 800.0),
        ("server4", "web4.example.com", 8080, 1200.0)
    ]
    
    for server_id, hostname, port, capacity in servers:
        lb.add_server(server_id, hostname, port, capacity)
    
    print("Added servers:")
    for server_id, hostname, port, capacity in servers:
        print(f"  {server_id}: {hostname}:{port} (capacity: {capacity})")
    
    # 等待指标更新
    print("\nWaiting for metrics collection...")
    time.sleep(2)
    
    # 2. 系统状态监控
    print("\n2. System Status Monitoring")
    print("="*50)
    
    # 获取系统概览
    system_overview = lb.get_system_overview()
    
    print("System Overview:")
    print(f"  Total Servers: {system_overview['system_stats']['total_servers']}")
    print(f"  Healthy Servers: {system_overview['system_stats']['healthy_servers']}")
    print(f"  System Health Score: {system_overview['system_stats']['system_health_score']:.1f}%")
    
    print(f"\nCapacity Stats:")
    cap_stats = system_overview['capacity_stats']
    print(f"  Total Capacity: {cap_stats['total_capacity']:.0f}")
    print(f"  Effective Capacity: {cap_stats['effective_capacity']:.0f}")
    print(f"  Capacity Utilization: {cap_stats['capacity_utilization']:.1%}")
    
    print(f"\nResource Stats:")
    res_stats = system_overview['resource_stats']
    print(f"  Average CPU Usage: {res_stats['average_cpu_usage']:.1f}%")
    print(f"  Average Memory Usage: {res_stats['average_memory_usage']:.1f}%")
    print(f"  Average Disk Usage: {res_stats['average_disk_usage']:.1f}%")
    print(f"  Average Network Utilization: {res_stats['average_network_utilization']:.1f}%")
    
    # 3. 服务器详细分析
    print("\n3. Server Detailed Analysis")
    print("="*50)
    
    server_details = lb.get_server_details()
    
    print("Server Resource Analysis:")
    print(f"{'Server':<12} {'CPU%':<8} {'Mem%':<8} {'Disk%':<8} {'Net%':<8} {'Capacity':<12} {'Pressure':<10} {'Health':<8}")
    print("-" * 90)
    
    for server_id, details in server_details.items():
        cpu = details['resource_metrics']['cpu_usage']
        memory = details['resource_metrics']['memory_usage']
        disk = details['resource_metrics']['disk_usage']
        network = details['resource_metrics']['network_utilization']
        capacity = details['capacity_info']['effective_capacity']
        pressure = details['capacity_info']['resource_pressure']
        health = "✓" if details['basic_info']['is_healthy'] else "✗"
        
        print(f"{server_id:<12} {cpu:<8.1f} {memory:<8.1f} {disk:<8.1f} {network:<8.1f} {capacity:<12.0f} {pressure:<10} {health:<8}")
    
    # 4. 不同权重策略演示
    print("\n4. Different Weight Strategies")
    print("="*50)
    
    strategies = [
        ResourceWeightStrategy.EQUAL_WEIGHT,
        ResourceWeightStrategy.CPU_HEAVY,
        ResourceWeightStrategy.MEMORY_HEAVY,
        ResourceWeightStrategy.IO_HEAVY
    ]
    
    for strategy in strategies:
        print(f"\n--- {strategy.value} Strategy ---")
        
        # 创建新的负载均衡器实例
        strategy_lb = ResourceBasedLoadBalancer(weight_strategy=strategy)
        
        for server_id, hostname, port, capacity in servers:
            strategy_lb.add_server(server_id, hostname, port, capacity)
        
        # 等待指标收集
        time.sleep(1)
        
        # 显示权重配置
        weights = strategy_lb.resource_weights
        print(f"Weights: CPU={weights['cpu']:.2f}, Memory={weights['memory']:.2f}, "
              f"Disk={weights['disk']:.2f}, Network={weights['network']:.2f}")
        
        # 分析服务器选择
        selection_counts = defaultdict(int)
        
        for i in range(100):
            server = strategy_lb.select_server()
            if server:
                selection_counts[server.server_id] += 1
        
        print(f"Server selection distribution (100 requests):")
        for server_id in [s[0] for s in servers]:
            count = selection_counts[server_id]
            percentage = count / 100 * 100
            print(f"  {server_id}: {count} requests ({percentage:.0f}%)")
    
    # 5. 不同负载均衡策略演示
    print("\n5. Different Load Balancing Strategies")
    print("="*50)
    
    load_strategies = [
        LoadBalancingStrategy.LEAST_LOADED,
        LoadBalancingStrategy.ROUND_ROBIN_WEIGHTED,
        LoadBalancingStrategy.RESOURCE_AWARE,
        LoadBalancingStrategy.PREDICTIVE
    ]
    
    for load_strategy in load_strategies:
        print(f"\n--- {load_strategy.value} Strategy ---")
        
        # 创建新的负载均衡器实例
        strategy_lb = ResourceBasedLoadBalancer(load_strategy=load_strategy)
        
        for server_id, hostname, port, capacity in servers:
            strategy_lb.add_server(server_id, hostname, port, capacity)
        
        # 等待指标收集
        time.sleep(1)
        
        # 生成请求并统计分布
        selection_counts = defaultdict(int)
        total_requests = 200
        
        for i in range(total_requests):
            # 模拟不同请求成本
            request_cost = random.uniform(0.5, 2.0)
            server = strategy_lb.select_server(request_cost)
            
            if server:
                selection_counts[server.server_id] += 1
                
                # 模拟请求处理
                request_duration = random.uniform(100, 1000)
                strategy_lb.process_request(server, request_duration, request_cost)
        
        print(f"Strategy: {load_strategy.value}")
        print(f"Request distribution ({total_requests} requests):")
        
        for server_id in [s[0] for s in servers]:
            count = selection_counts[server_id]
            percentage = count / total_requests * 100
            print(f"  {server_id}: {count} requests ({percentage:.1f}%)")
    
    # 6. Go风格实现演示
    print("\n6. Go-Style Implementation")
    print("="*50)
    
    go_servers = [
        {"id": "go1", "host": "go-server1", "port": 8080},
        {"id": "go2", "host": "go-server2", "port": 8080},
        {"id": "go3", "host": "go-server3", "port": 8080}
    ]
    
    go_lb = GoStyleResourceLoadBalancer(go_servers)
    
    # 初始化一些指标
    for i, server in enumerate(go_servers):
        metrics = ResourceMetrics()
        metrics.cpu_usage = 20 + i * 10  # 不同CPU使用率
        metrics.memory_usage = 30 + i * 15
        metrics.connection_utilization = 40 + i * 10
        
        go_lb.UpdateMetrics(server["id"], metrics)
    
    print("Go-style resource-based load balancing:")
    
    # 测试最佳服务器选择
    for i in range(10):
        best_server = go_lb.GetBestServer()
        round_robin_server = go_lb.GetServerWithRoundRobin()
        print(f"  Request {i+1}: Best={best_server}, RR={round_robin_server}")
    
    # 显示系统状态
    system_status = go_lb.GetSystemStatus()
    print(f"\nGo-style system status:")
    print(f"  Total servers: {system_status['total_servers']}")
    print(f"  Healthy servers: {system_status['healthy_servers']}")
    print(f"  Health percentage: {system_status['health_percentage']:.1f}%")
    print(f"  Average resource score: {system_status['average_resource_score']:.1f}")
    print(f"  System status: {system_status['system_status']}")
    
    # 7. 性能优化建议
    print("\n7. Performance Optimization Recommendations")
    print("="*50)
    
    # 获取当前负载均衡器的建议
    recommendations = []
    
    for server_id, details in server_details.items():
        if details['recommendations']:
            recommendations.append({
                "server": server_id,
                "recommendations": details['recommendations']
            })
    
    if recommendations:
        print("Server-specific recommendations:")
        for rec in recommendations:
            print(f"\n  {rec['server']}:")
            for recommendation in rec['recommendations']:
                print(f"    - {recommendation}")
    else:
        print("No immediate recommendations - all servers are performing well!")
    
    # 8. 系统负载仿真
    print("\n8. System Load Simulation")
    print("="*50)
    
    # 使用当前负载均衡器进行仿真
    print("Running system load simulation...")
    simulation_results = lb.simulate_system_load(
        duration=30.0,
        requests_per_second=20,  # 较慢的请求频率以观察效果
        request_cost_variance=0.5
    )
    
    print("Simulation Results:")
    config = simulation_results['simulation_config']
    results = simulation_results['results']
    
    print(f"  Configuration:")
    print(f"    Duration: {config['actual_duration']:.1f}s")
    print(f"    Requested RPS: {config['requested_rps']}")
    print(f"    Actual RPS: {results['actual_rps']:.1f}")
    
    print(f"  Performance:")
    print(f"    Total Requests: {results['total_requests']}")
    print(f"    Success Rate: {results['success_rate']:.1f}%")
    print(f"    Resource Violations: {results['resource_violations']}")
    print(f"    Violation Rate: {results['resource_violation_rate']:.1f}%")
    
    if results['request_durations']['count'] > 0:
        print(f"  Response Times:")
        rt = results['request_durations']
        print(f"    Mean: {rt['mean']:.1f}ms")
        print(f"    Median: {rt['median']:.1f}ms")
        print(f"    Min: {rt['min']:.1f}ms")
        print(f"    Max: {rt['max']:.1f}ms")
    
    print(f"  Server Distribution:")
    for server_id, count in results['server_distribution'].items():
        percentage = count / results['total_requests'] * 100
        print(f"    {server_id}: {count} requests ({percentage:.1f}%)")
    
    # 9. 资源压力分析
    print("\n9. Resource Pressure Analysis")
    print("="*50)
    
    final_server_details = simulation_results['server_details']
    
    print("Final resource pressure analysis:")
    for server_id, details in final_server_details.items():
        pressure = details['capacity_info']['resource_pressure']
        utilization = details['capacity_info']['capacity_utilization']
        health = details['basic_info']['is_healthy']
        
        status = "HEALTHY" if health else "UNHEALTHY"
        
        print(f"  {server_id}: {pressure} pressure, {utilization:.1%} utilized, {status}")
    
    print("\n=== Resource-Based Load Balancing Summary ===")
    print("Resource-Based Load Balancing provides:")
    print("• Real-time resource monitoring and analysis")
    print("• Intelligent server selection based on system resources")
    print("• Multiple weight strategies for different workload types")
    print("• Predictive load balancing with trend analysis")
    print("• Automatic health detection and recovery")
    print("\nKey Advantages:")
    print("• Optimizes resource utilization across servers")
    print("• Prevents resource exhaustion and bottlenecks")
    print("• Adapts to changing workload characteristics")
    print("• Provides detailed system observability")
    print("• Supports various workload optimization strategies")
    print("\nUse Cases:")
    print("• High-load web applications")
    print("• Data processing pipelines")
    print("• Microservices with varying resource requirements")
    print("• Container orchestration systems")
    print("• Real-time data streaming platforms")
    print("\nWeight Strategies:")
    print("• Equal Weight: Balanced resource consideration")
    print("• CPU Heavy: Optimized for CPU-intensive workloads")
    print("• Memory Heavy: Optimized for memory-intensive workloads")
    print("• IO Heavy: Optimized for I/O-intensive workloads")
    print("• Custom: User-defined weight configuration")
    print("\nLoad Balancing Strategies:")
    print("• Least Loaded: Select server with lowest utilization")
    print("• Weighted Round Robin: Capacity-based selection")
    print("• Resource Aware: Best resource score selection")
    print("• Predictive: Trend-based future performance prediction")

if __name__ == "__main__":
    demo_resource_based_load_balancing()