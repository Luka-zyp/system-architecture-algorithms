# 设计模式在系统架构中的应用

## 概述

设计模式是软件开发中反复出现的问题的解决方案，是前人经验的总结。在大规模分布式系统架构中，合理运用设计模式能够显著提高系统的可扩展性、可维护性和可靠性。本文档将探讨经典设计模式在现代系统架构中的实际应用，以及如何结合微服务、事件驱动等架构模式构建高质量的软件系统。

## 创建型模式

### 工厂模式 (Factory Pattern)

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List, Type
import asyncio
import time

class Database(ABC):
    """数据库抽象"""
    
    @abstractmethod
    async def connect(self):
        """连接数据库"""
        pass
    
    @abstractmethod
    async def query(self, sql: str, params: Dict = None) -> List[Dict]:
        """执行查询"""
        pass
    
    @abstractmethod
    async def execute(self, sql: str, params: Dict = None) -> bool:
        """执行命令"""
        pass

class PostgreSQLDatabase(Database):
    """PostgreSQL数据库实现"""
    
    def __init__(self, host: str, port: int, database: str, user: str, password: str):
        self.host = host
        self.port = port
        self.database = database
        self.user = user
        self.password = password
        self.connected = False
    
    async def connect(self):
        print(f"连接PostgreSQL数据库: {self.host}:{self.port}/{self.database}")
        # 模拟连接过程
        await asyncio.sleep(0.1)
        self.connected = True
        print("PostgreSQL连接成功")
    
    async def query(self, sql: str, params: Dict = None) -> List[Dict]:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"PostgreSQL查询: {sql}")
        # 模拟查询结果
        return [{'id': 1, 'name': 'Alice', 'email': 'alice@example.com'}]
    
    async def execute(self, sql: str, params: Dict = None) -> bool:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"PostgreSQL执行: {sql}")
        return True

class MySQLDatabase(Database):
    """MySQL数据库实现"""
    
    def __init__(self, host: str, port: int, database: str, user: str, password: str):
        self.host = host
        self.port = port
        self.database = database
        self.user = user
        self.password = password
        self.connected = False
    
    async def connect(self):
        print(f"连接MySQL数据库: {self.host}:{self.port}/{self.database}")
        await asyncio.sleep(0.1)
        self.connected = True
        print("MySQL连接成功")
    
    async def query(self, sql: str, params: Dict = None) -> List[Dict]:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"MySQL查询: {sql}")
        return [{'id': 2, 'name': 'Bob', 'email': 'bob@example.com'}]
    
    async def execute(self, sql: str, params: Dict = None) -> bool:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"MySQL执行: {sql}")
        return True

class MongoDBDatabase(Database):
    """MongoDB数据库实现"""
    
    def __init__(self, connection_string: str, database: str):
        self.connection_string = connection_string
        self.database = database
        self.connected = False
    
    async def connect(self):
        print(f"连接MongoDB数据库: {self.connection_string}/{self.database}")
        await asyncio.sleep(0.1)
        self.connected = True
        print("MongoDB连接成功")
    
    async def query(self, sql: str, params: Dict = None) -> List[Dict]:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"MongoDB查询: {sql}")
        return [{'_id': '3', 'name': 'Charlie', 'email': 'charlie@example.com'}]
    
    async def execute(self, sql: str, params: Dict = None) -> bool:
        if not self.connected:
            raise Exception("数据库未连接")
        print(f"MongoDB执行: {sql}")
        return True

class DatabaseFactory:
    """数据库工厂模式"""
    
    _database_types = {
        'postgresql': PostgreSQLDatabase,
        'mysql': MySQLDatabase,
        'mongodb': MongoDBDatabase
    }
    
    @classmethod
    def create_database(cls, db_type: str, config: Dict[str, Any]) -> Database:
        """创建数据库实例"""
        if db_type not in cls._database_types:
            raise ValueError(f"不支持的数据库类型: {db_type}")
        
        database_class = cls._database_types[db_type]
        return database_class(**config)
    
    @classmethod
    def register_database_type(cls, name: str, database_class: Type[Database]):
        """注册新的数据库类型"""
        cls._database_types[name] = database_class
    
    @classmethod
    def get_supported_types(cls) -> List[str]:
        """获取支持的数据库类型"""
        return list(cls._database_types.keys())
```

## 单例模式 (Singleton Pattern)

```python
class ServiceRegistry:
    """服务注册中心 - 单例模式"""
    
    _instance = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not ServiceRegistry._initialized:
            self.services = {}
            self.service_configs = {}
            ServiceRegistry._initialized = True
    
    def register(self, service_name: str, service_instance: Any, config: Dict = None):
        """注册服务"""
        self.services[service_name] = service_instance
        self.service_configs[service_name] = config or {}
        print(f"服务已注册: {service_name}")
    
    def get(self, service_name: str) -> Optional[Any]:
        """获取服务"""
        return self.services.get(service_name)
    
    def get_all(self) -> Dict[str, Any]:
        """获取所有服务"""
        return self.services.copy()
    
    def is_registered(self, service_name: str) -> bool:
        """检查服务是否已注册"""
        return service_name in self.services

    def get_service_stats(self) -> Dict[str, Any]:
        """获取服务统计"""
        return {
            'total_services': len(self.services),
            'service_names': list(self.services.keys()),
            'services_with_config': len([s for s in self.service_configs.values() if s])
        }

class ServiceConfig:
    """服务配置"""
    
    def __init__(self, name: str, version: str, port: int, health_check_url: str, dependencies: List[str] = None):
        self.name = name
        self.version = version
        self.port = port
        self.health_check_url = health_check_url
        self.dependencies = dependencies or []

class ServiceLocator:
    """服务定位器模式"""
    
    def __init__(self, service_registry: ServiceRegistry):
        self.service_registry = service_registry
        self.service_factories = {}
        self.cache = {}
    
    def register_factory(self, service_name: str, factory: callable):
        """注册服务工厂"""
        self.service_factories[service_name] = factory
    
    def get_service(self, service_name: str) -> Optional[Any]:
        """获取服务（先检查缓存，再通过工厂创建）"""
        # 先检查缓存
        if service_name in self.cache:
            return self.cache[service_name]
        
        # 检查注册中心
        service = self.service_registry.get(service_name)
        if service:
            self.cache[service_name] = service
            return service
        
        # 通过工厂创建
        if service_name in self.service_factories:
            service = self.service_factories[service_name]()
            self.cache[service_name] = service
            self.service_registry.register(service_name, service)
            return service
        
        return None
    
    def invalidate_cache(self, service_name: str = None):
        """失效缓存"""
        if service_name:
            self.cache.pop(service_name, None)
        else:
            self.cache.clear()
        print(f"缓存已失效: {service_name or '全部'}")
```

## 构建者模式 (Builder Pattern)

```python
class DatabaseConnectionBuilder:
    """数据库连接构建器"""
    
    def __init__(self):
        self._host = None
        self._port = None
        self._database = None
        self._user = None
        self._password = None
        self._timeout = 30
        self._max_connections = 10
        self._ssl_enabled = False
        self._compression = False
    
    def set_host(self, host: str) -> 'DatabaseConnectionBuilder':
        """设置主机"""
        self._host = host
        return self
    
    def set_port(self, port: int) -> 'DatabaseConnectionBuilder':
        """设置端口"""
        self._port = port
        return self
    
    def set_database(self, database: str) -> 'DatabaseConnectionBuilder':
        """设置数据库名"""
        self._database = database
        return self
    
    def set_user(self, user: str) -> 'DatabaseConnectionBuilder':
        """设置用户名"""
        self._user = user
        return self
    
    def set_password(self, password: str) -> 'DatabaseConnectionBuilder':
        """设置密码"""
        self._password = password
        return self
    
    def set_timeout(self, timeout: int) -> 'DatabaseConnectionBuilder':
        """设置超时时间"""
        self._timeout = timeout
        return self
    
    def set_max_connections(self, max_connections: int) -> 'DatabaseConnectionBuilder':
        """设置最大连接数"""
        self._max_connections = max_connections
        return self
    
    def enable_ssl(self, enabled: bool = True) -> 'DatabaseConnectionBuilder':
        """启用SSL"""
        self._ssl_enabled = enabled
        return self
    
    def enable_compression(self, enabled: bool = True) -> 'DatabaseConnectionBuilder':
        """启用压缩"""
        self._compression = enabled
        return self
    
    def build(self) -> Dict[str, Any]:
        """构建连接配置"""
        if not all([self._host, self._port, self._database, self._user]):
            raise ValueError("缺少必要的连接参数")
        
        return {
            'host': self._host,
            'port': self._port,
            'database': self._database,
            'user': self._user,
            'password': self._password,
            'timeout': self._timeout,
            'max_connections': self._max_connections,
            'ssl_enabled': self._ssl_enabled,
            'compression': self._compression
        }

class ServiceBuilder:
    """服务构建器"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        self._config = {}
        self._dependencies = []
        self._middlewares = []
        self._health_check = None
        self._auto_scale = False
        self._load_balancer = None
    
    def set_config(self, config: Dict) -> 'ServiceBuilder':
        """设置服务配置"""
        self._config.update(config)
        return self
    
    def add_dependency(self, dependency: str) -> 'ServiceBuilder':
        """添加依赖服务"""
        self._dependencies.append(dependency)
        return self
    
    def add_middleware(self, middleware: callable) -> 'ServiceBuilder':
        """添加中间件"""
        self._middlewares.append(middleware)
        return self
    
    def set_health_check(self, health_check: callable) -> 'ServiceBuilder':
        """设置健康检查"""
        self._health_check = health_check
        return self
    
    def enable_auto_scale(self, enabled: bool = True) -> 'ServiceBuilder':
        """启用自动缩放"""
        self._auto_scale = enabled
        return self
    
    def set_load_balancer(self, load_balancer: str) -> 'ServiceBuilder':
        """设置负载均衡器"""
        self._load_balancer = load_balancer
        return self
    
    def build(self) -> Dict[str, Any]:
        """构建服务配置"""
        return {
            'name': self.service_name,
            'config': self._config,
            'dependencies': self._dependencies,
            'middlewares': self._middlewares,
            'health_check': self._health_check,
            'auto_scale': self._auto_scale,
            'load_balancer': self._load_balancer
        }
```

## 原型模式 (Prototype Pattern)

```python
class ServiceTemplate:
    """服务模板 - 原型模式"""
    
    def __init__(self, name: str, template_type: str):
        self.name = name
        self.template_type = template_type
        self.config = {}
        self.dependencies = []
        self.capabilities = []
        self.metadata = {}
    
    def clone(self, new_name: str = None) -> 'ServiceTemplate':
        """克隆服务模板"""
        new_template = ServiceTemplate(
            name=new_name or f"{self.name}_copy",
            template_type=self.template_type
        )
        
        # 深度复制配置和属性
        new_template.config = self.config.copy()
        new_template.dependencies = self.dependencies.copy()
        new_template.capabilities = self.capabilities.copy()
        new_template.metadata = self.metadata.copy()
        
        return new_template
    
    def customize(self, customizations: Dict) -> 'ServiceTemplate':
        """自定义模板"""
        self.config.update(customizations.get('config', {}))
        self.dependencies.extend(customizations.get('dependencies', []))
        self.capabilities.extend(customizations.get('capabilities', []))
        return self

class ServiceTemplateRegistry:
    """服务模板注册表"""
    
    def __init__(self):
        self.templates = {}
    
    def register_template(self, template: ServiceTemplate):
        """注册服务模板"""
        self.templates[template.name] = template
        print(f"服务模板已注册: {template.name}")
    
    def get_template(self, name: str) -> Optional[ServiceTemplate]:
        """获取服务模板"""
        return self.templates.get(name)
    
    def create_service_from_template(self, template_name: str, service_name: str, customizations: Dict = None) -> ServiceTemplate:
        """从模板创建服务"""
        template = self.get_template(template_name)
        if not template:
            raise ValueError(f"模板不存在: {template_name}")
        
        service = template.clone(service_name)
        if customizations:
            service.customize(customizations)
        
        return service
    
    def list_templates(self) -> List[str]:
        """列出所有模板"""
        return list(self.templates.keys())
```

## 装饰器模式 (Decorator Pattern)

```python
class ServiceComponent(ABC):
    """服务组件抽象"""
    
    @abstractmethod
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """执行服务"""
        pass

class BaseService(ServiceComponent):
    """基础服务"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        print(f"基础服务 {self.service_name} 执行中...")
        await asyncio.sleep(0.1)  # 模拟服务执行时间
        
        return {
            'service': self.service_name,
            'result': f"处理完成: {request.get('data', 'unknown')}",
            'timestamp': time.time()
        }

class ServiceDecorator(ServiceComponent):
    """服务装饰器基类"""
    
    def __init__(self, wrapped_service: ServiceComponent):
        self.wrapped_service = wrapped_service
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        return await self.wrapped_service.execute(request)

class LoggingDecorator(ServiceDecorator):
    """日志装饰器"""
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        print(f"[LOG] 调用服务: {self.wrapped_service.service_name}")
        start_time = time.time()
        
        try:
            result = await self.wrapped_service.execute(request)
            execution_time = time.time() - start_time
            print(f"[LOG] 服务执行完成，耗时: {execution_time:.3f}秒")
            return result
        except Exception as e:
            execution_time = time.time() - start_time
            print(f"[LOG] 服务执行失败，耗时: {execution_time:.3f}秒，错误: {str(e)}")
            raise

class CachingDecorator(ServiceDecorator):
    """缓存装饰器"""
    
    def __init__(self, wrapped_service: ServiceComponent, cache_ttl: int = 300):
        super().__init__(wrapped_service)
        self.cache = {}
        self.cache_ttl = cache_ttl
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        # 生成缓存键
        cache_key = self._generate_cache_key(request)
        
        # 检查缓存
        if cache_key in self.cache:
            cached_result, timestamp = self.cache[cache_key]
            if time.time() - timestamp < self.cache_ttl:
                print(f"[CACHE] 缓存命中: {cache_key}")
                return cached_result
        
        # 执行服务并缓存结果
        result = await self.wrapped_service.execute(request)
        self.cache[cache_key] = (result, time.time())
        print(f"[CACHE] 结果已缓存: {cache_key}")
        
        return result
    
    def _generate_cache_key(self, request: Dict[str, Any]) -> str:
        """生成缓存键"""
        import hashlib
        import json
        
        cache_data = {
            'service': self.wrapped_service.service_name,
            'request': request
        }
        
        cache_string = json.dumps(cache_data, sort_keys=True)
        return hashlib.md5(cache_string.encode()).hexdigest()

class RetryDecorator(ServiceDecorator):
    """重试装饰器"""
    
    def __init__(self, wrapped_service: ServiceComponent, max_retries: int = 3, delay: float = 1.0):
        super().__init__(wrapped_service)
        self.max_retries = max_retries
        self.delay = delay
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                return await self.wrapped_service.execute(request)
            except Exception as e:
                last_exception = e
                if attempt < self.max_retries:
                    print(f"[RETRY] 第{attempt + 1}次尝试失败，{self.delay}秒后重试...")
                    await asyncio.sleep(self.delay)
                else:
                    print(f"[RETRY] 重试{self.max_retries}次后仍失败")
        
        raise last_exception

class AuthenticationDecorator(ServiceDecorator):
    """认证装饰器"""
    
    def __init__(self, wrapped_service: ServiceComponent, auth_provider: callable):
        super().__init__(wrapped_service)
        self.auth_provider = auth_provider
    
    async def execute(self, request: Dict[str, Any]) -> Dict[str, Any]:
        # 检查认证
        auth_token = request.get('auth_token')
        if not auth_token:
            raise ValueError("缺少认证令牌")
        
        user_info = await self.auth_provider(auth_token)
        if not user_info:
            raise ValueError("认证失败")
        
        print(f"[AUTH] 用户认证成功: {user_info['username']}")
        
        # 将用户信息添加到请求中
        request_with_user = request.copy()
        request_with_user['user'] = user_info
        
        return await self.wrapped_service.execute(request_with_user)
```

## 策略模式 (Strategy Pattern)

```python
class LoadBalancingStrategy(ABC):
    """负载均衡策略抽象"""
    
    @abstractmethod
    def select_server(self, servers: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        """选择服务器"""
        pass

class RoundRobinStrategy(LoadBalancingStrategy):
    """轮询策略"""
    
    def __init__(self):
        self.current_index = 0
    
    def select_server(self, servers: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if not servers:
            return None
        
        server = servers[self.current_index % len(servers)]
        self.current_index += 1
        return server

class LeastConnectionsStrategy(LoadBalancingStrategy):
    """最少连接策略"""
    
    def select_server(self, servers: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if not servers:
            return None
        
        # 选择连接数最少的服务器
        return min(servers, key=lambda s: s.get('active_connections', 0))

class WeightedRoundRobinStrategy(LoadBalancingStrategy):
    """加权轮询策略"""
    
    def __init__(self):
        self.current_weights = {}
    
    def select_server(self, servers: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
        if not servers:
            return None
        
        # 初始化权重
        if not self.current_weights:
            for server in servers:
                self.current_weights[server['id']] = server.get('weight', 1)
        
        # 选择权重最高的服务器
        best_server = None
        best_weight = -1
        
        for server in servers:
            server_id = server['id']
            weight = self.current_weights[server_id]
            
            if weight > best_weight:
                best_weight = weight
                best_server = server
        
        # 更新权重
        self.current_weights[best_server['id']] -= sum(self.current_weights.values())
        
        for server_id in self.current_weights:
            self.current_weights[server_id] += server_id in [s['id'] for s in servers] and server_id in self.current_weights
        
        return best_server

class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self, strategy: LoadBalancingStrategy):
        self.strategy = strategy
        self.servers = []
        self.health_checker = None
    
    def set_servers(self, servers: List[Dict[str, Any]]):
        """设置服务器列表"""
        self.servers = servers
    
    def set_strategy(self, strategy: LoadBalancingStrategy):
        """设置负载均衡策略"""
        self.strategy = strategy
    
    def set_health_checker(self, health_checker: callable):
        """设置健康检查器"""
        self.health_checker = health_checker
    
    def get_server(self) -> Optional[Dict[str, Any]]:
        """获取服务器"""
        # 健康检查
        if self.health_checker:
            self.servers = [s for s in self.servers if self.health_checker(s)]
        
        return self.strategy.select_server(self.servers)
    
    def add_server(self, server: Dict[str, Any]):
        """添加服务器"""
        self.servers.append(server)
    
    def remove_server(self, server_id: str):
        """移除服务器"""
        self.servers = [s for s in self.servers if s['id'] != server_id]
    
    def get_stats(self) -> Dict[str, Any]:
        """获取负载均衡器统计"""
        return {
            'total_servers': len(self.servers),
            'servers': self.servers,
            'strategy': self.strategy.__class__.__name__
        }
```

## 观察者模式 (Observer Pattern)

```python
class Subject(ABC):
    """主题抽象"""
    
    def __init__(self):
        self._observers: List['Observer'] = []
    
    def attach(self, observer: 'Observer'):
        """添加观察者"""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: 'Observer'):
        """移除观察者"""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self, event: Dict[str, Any]):
        """通知观察者"""
        for observer in self._observers:
            observer.update(event)

class Observer(ABC):
    """观察者抽象"""
    
    @abstractmethod
    def update(self, event: Dict[str, Any]):
        """更新通知"""
        pass

class MetricsCollector(Observer):
    """指标收集器"""
    
    def __init__(self, collector_name: str):
        self.collector_name = collector_name
        self.metrics = {}
    
    def update(self, event: Dict[str, Any]):
        """收集指标"""
        event_type = event.get('type')
        timestamp = event.get('timestamp', time.time())
        
        if event_type not in self.metrics:
            self.metrics[event_type] = []
        
        self.metrics[event_type].append({
            'timestamp': timestamp,
            'data': event.get('data', {})
        })
        
        print(f"[指标收集器 {self.collector_name}] 收集事件: {event_type}")
    
    def get_metrics(self, event_type: str = None) -> Dict[str, Any]:
        """获取指标"""
        if event_type:
            return self.metrics.get(event_type, [])
        return self.metrics.copy()
    
    def clear_metrics(self, event_type: str = None):
        """清除指标"""
        if event_type:
            self.metrics[event_type] = []
        else:
            self.metrics.clear()

class AlertManager(Observer):
    """告警管理器"""
    
    def __init__(self, alert_rules: List[Dict[str, Any]]):
        self.alert_rules = alert_rules
        self.active_alerts = {}
    
    def update(self, event: Dict[str, Any]):
        """处理告警"""
        for rule in self.alert_rules:
            if self._should_alert(rule, event):
                alert_id = f"{rule['name']}_{int(time.time())}"
                
                alert = {
                    'id': alert_id,
                    'rule': rule,
                    'event': event,
                    'timestamp': time.time(),
                    'severity': rule.get('severity', 'warning')
                }
                
                self.active_alerts[alert_id] = alert
                print(f"[告警] {rule['name']}: {alert['severity']} - {event}")
    
    def _should_alert(self, rule: Dict[str, Any], event: Dict[str, Any]) -> bool:
        """判断是否应该告警"""
        condition = rule.get('condition', {})
        event_type = event.get('type')
        
        # 检查事件类型
        if event_type != condition.get('type'):
            return False
        
        # 检查数值条件
        if 'threshold' in condition:
            threshold = condition['threshold']
            value = event.get('data', {}).get('value', 0)
            
            if condition.get('operator') == '>':
                return value > threshold
            elif condition.get('operator') == '<':
                return value < threshold
            elif condition.get('operator') == '>=':
                return value >= threshold
            elif condition.get('operator') == '<=':
                return value <= threshold
        
        return False
    
    def get_active_alerts(self) -> List[Dict[str, Any]]:
        """获取活跃告警"""
        return list(self.active_alerts.values())
    
    def resolve_alert(self, alert_id: str) -> bool:
        """解决告警"""
        if alert_id in self.active_alerts:
            del self.active_alerts[alert_id]
            return True
        return False

class EventBus(Subject):
    """事件总线 - 观察者模式应用"""
    
    def __init__(self):
        super().__init__()
        self.event_history = []
        self.max_history_size = 1000
    
    def publish_event(self, event: Dict[str, Any]):
        """发布事件"""
        event['timestamp'] = time.time()
        event['event_id'] = f"evt_{int(event['timestamp'] * 1000000)}"
        
        # 添加到历史记录
        self.event_history.append(event)
        if len(self.event_history) > self.max_history_size:
            self.event_history.pop(0)
        
        # 通知观察者
        self.notify(event)
        
        print(f"[事件总线] 发布事件: {event['type']}")
    
    def get_recent_events(self, count: int = 10) -> List[Dict[str, Any]]:
        """获取最近的事件"""
        return self.event_history[-count:] if self.event_history else []
    
    def get_event_statistics(self) -> Dict[str, Any]:
        """获取事件统计"""
        event_counts = {}
        for event in self.event_history:
            event_type = event.get('type', 'unknown')
            event_counts[event_type] = event_counts.get(event_type, 0) + 1
        
        return {
            'total_events': len(self.event_history),
            'event_types': event_counts,
            'unique_event_types': len(event_counts)
        }
```

## 架构模式整合

### 微服务架构中的设计模式应用

```python
class MicroserviceArchitecture:
    """微服务架构中的设计模式整合"""
    
    def __init__(self):
        self.service_registry = ServiceRegistry()
        self.load_balancer = LoadBalancer(RoundRobinStrategy())
        self.event_bus = EventBus()
        self.command_invoker = CommandInvoker()
        self.infrastructure_analyzer = InfrastructureAnalyzer()
        
        # 注册观察者
        self.metrics_collector = MetricsCollector("main")
        self.alert_manager = AlertManager([
            {
                'name': 'high_cpu_usage',
                'condition': {
                    'type': 'cpu_usage',
                    'operator': '>',
                    'threshold': 80
                },
                'severity': 'critical'
            }
        ])
        
        self.event_bus.attach(self.metrics_collector)
        self.event_bus.attach(self.alert_manager)
    
    async def deploy_microservice(self, service_config: Dict[str, Any]) -> str:
        """部署微服务"""
        print(f"部署微服务: {service_config['name']}")
        
        # 使用构建器模式创建服务
        service_builder = ServiceBuilder(service_config['name'])
        service_builder.set_config(service_config)
        built_config = service_builder.build()
        
        # 创建服务实例
        service_instance = Microservice(
            name=service_config['name'],
            version=service_config.get('version', '1.0.0'),
            port=service_config.get('port', 8080)
        )
        
        # 使用命令模式部署
        deploy_cmd = DeployCommand(
            service_config['name'],
            service_config.get('version', '1.0.0'),
            service_config
        )
        
        result = await self.command_invoker.execute_command(deploy_cmd)
        
        # 发布部署事件
        self.event_bus.publish_event({
            'type': 'service_deployed',
            'data': {
                'service_name': service_config['name'],
                'version': service_config.get('version', '1.0.0'),
                'deployment_id': result['deployment_id']
            }
        })
        
        # 注册到服务注册中心
        await self.service_registry.register_service(
            ServiceConfig(
                name=service_config['name'],
                version=service_config.get('version', '1.0.0'),
                port=service_config.get('port', 8080),
                health_check_url="/health",
                dependencies=service_config.get('dependencies', [])
            )
        )
        
        return result['deployment_id']
    
    async def scale_service(self, service_name: str, target_replicas: int):
        """扩缩容服务"""
        print(f"扩缩容服务: {service_name} -> {target_replicas} 副本")
        
        # 获取当前副本数（简化实现）
        current_replicas = 2  # 默认值
        scale_cmd = ScaleCommand(service_name, target_replicas, current_replicas)
        
        result = await self.command_invoker.execute_command(scale_cmd)
        
        # 发布扩缩容事件
        self.event_bus.publish_event({
            'type': 'service_scaled',
            'data': {
                'service_name': service_name,
                'previous_replicas': current_replicas,
                'target_replicas': target_replicas
            }
        })
        
        return result
    
    def add_load_balancing_rule(self, service_name: str, servers: List[Dict[str, Any]]):
        """添加负载均衡规则"""
        self.load_balancer.set_servers(servers)
        print(f"负载均衡规则已添加: {service_name}")
    
    async def handle_database_operation(self, db_type: str, db_config: Dict[str, Any], sql: str) -> Any:
        """处理数据库操作"""
        print(f"执行数据库操作: {db_type}")
        
        # 使用工厂模式创建数据库
        db_factory = DatabaseFactory()
        database = db_factory.create_database(db_type, db_config)
        
        # 使用代理模式包装数据库
        db_proxy = DatabaseServiceProxy(
            DatabaseService(),
            max_connections=10
        )
        
        # 执行命令
        db_cmd = DatabaseCommand(
            database,
            sql,
            db_config
        )
        
        result = await self.command_invoker.execute_command(db_cmd)
        
        # 发布数据库事件
        self.event_bus.publish_event({
            'type': 'database_operation',
            'data': {
                'db_type': db_type,
                'sql': sql,
                'result': result
            }
        })
        
        return result
    
    def get_architecture_metrics(self) -> Dict[str, Any]:
        """获取架构指标"""
        return {
            'service_registry': self.service_registry.get_service_stats(),
            'command_history': self.command_invoker.get_command_history(),
            'event_statistics': self.event_bus.get_event_statistics(),
            'active_alerts': self.alert_manager.get_active_alerts(),
            'load_balancer': self.load_balancer.get_stats()
        }
```

## 总结

设计模式在现代系统架构中发挥着重要作用：

1. **创建型模式**帮助管理对象的创建过程，在微服务架构中实现服务的灵活配置和管理。

2. **结构型模式**优化系统的结构设计，提高代码的可维护性和可扩展性。

3. **行为型模式**定义了对象间的交互方式，在分布式系统中实现复杂的工作流程。

4. **组合使用**多种设计模式能够构建出既灵活又可靠的系统架构。

在实际应用中，需要根据具体的业务场景和需求选择合适的设计模式，并考虑性能、可维护性、可测试性等多个因素。设计模式不是银弹，它们是为了解决特定问题而设计的工具，正确的使用才能发挥最大的价值。