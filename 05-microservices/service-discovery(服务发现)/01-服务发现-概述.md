# 服务发现与注册概述

## 目录
1. [什么是服务发现](#什么是服务发现)
2. [核心概念](#核心概念)
3. [架构模式](#架构模式)
4. [实现方案](#实现方案)
5. [健康检查机制](#健康检查机制)
6. [负载均衡集成](#负载均衡集成)
7. [最佳实践](#最佳实践)

## 什么是服务发现

服务发现（Service Discovery）是微服务架构中的关键组件，它解决了"如何动态找到服务实例"的问题。在分布式系统中，服务实例可能动态启动、停止、扩展或迁移，客户端需要能够自动发现可用的服务实例。

### 基本概念
- **服务注册表**：存储所有可用服务实例信息的数据存储
- **服务注册**：服务实例启动时向注册表注册自己的信息
- **服务发现**：客户端查询注册表获取可用服务实例列表
- **健康检查**：定期检查服务实例的健康状态

### 问题背景
```
传统架构：           微服务架构：
Client → Service    Client → Service Discovery → Service
                   (需要动态发现多个Service实例)
```

## 核心概念

### 1. 服务标识
```python
class ServiceInstance:
    def __init__(self, service_id, host, port, metadata=None):
        self.service_id = service_id      # 服务唯一标识
        self.host = host                  # 主机地址
        self.port = port                  # 端口号
        self.metadata = metadata or {}    # 元数据
        self.health_check_url = f"http://{host}:{port}/health"
        self.last_heartbeat = None        # 最后心跳时间
        self.status = "UP"               # UP/DOWN/OUT_OF_SERVICE
    
    def get_endpoint(self):
        return f"http://{self.host}:{self.port}"
    
    def is_healthy(self, max_stale_seconds=30):
        """检查实例是否健康"""
        if self.status != "UP":
            return False
        
        if self.last_heartbeat:
            from datetime import datetime, timedelta
            stale_time = datetime.now() - self.last_heartbeat
            return stale_time.total_seconds() < max_stale_seconds
        
        return False
    
    def to_dict(self):
        return {
            'service_id': self.service_id,
            'host': self.host,
            'port': self.port,
            'metadata': self.metadata,
            'health_check_url': self.health_check_url,
            'status': self.status
        }
```

### 2. 服务注册表
```python
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Set

class ServiceRegistry:
    def __init__(self):
        self._services: Dict[str, List[ServiceInstance]] = {}
        self._lock = threading.RLock()
        self._listeners = []
    
    def register(self, instance: ServiceInstance):
        """注册服务实例"""
        with self._lock:
            if instance.service_id not in self._services:
                self._services[instance.service_id] = []
            
            # 检查是否已存在相同实例
            existing_instances = self._services[instance.service_id]
            for existing in existing_instances:
                if existing.host == instance.host and existing.port == instance.port:
                    # 更新现有实例
                    existing.metadata.update(instance.metadata)
                    existing.status = instance.status
                    return
            
            # 添加新实例
            instance.last_heartbeat = datetime.now()
            existing_instances.append(instance)
            
            # 通知监听器
            self._notify_listeners('register', instance.service_id, [instance])
    
    def deregister(self, service_id: str, host: str, port: int):
        """注销服务实例"""
        with self._lock:
            if service_id not in self._services:
                return
            
            instances = self._services[service_id]
            for instance in instances[:]:
                if instance.host == host and instance.port == port:
                    instances.remove(instance)
                    self._notify_listeners('deregister', service_id, [instance])
                    
                    # 如果没有实例了，删除服务
                    if not instances:
                        del self._services[service_id]
                    break
    
    def get_all_services(self) -> Dict[str, List[ServiceInstance]]:
        """获取所有服务"""
        with self._lock:
            return {k: v.copy() for k, v in self._services.items()}
    
    def get_instances(self, service_id: str) -> List[ServiceInstance]:
        """获取指定服务的实例"""
        with self._lock:
            return self._services.get(service_id, []).copy()
    
    def heartbeat(self, service_id: str, host: str, port: int):
        """发送心跳"""
        with self._lock:
            if service_id not in self._services:
                return False
            
            instances = self._services[service_id]
            for instance in instances:
                if instance.host == host and instance.port == port:
                    instance.last_heartbeat = datetime.now()
                    if instance.status == "OUT_OF_SERVICE":
                        instance.status = "UP"
                    return True
            return False
    
    def add_listener(self, listener):
        """添加监听器"""
        with self._lock:
            self._listeners.append(listener)
    
    def _notify_listeners(self, event_type, service_id, instances):
        """通知监听器"""
        for listener in self._listeners:
            try:
                listener.on_event(event_type, service_id, instances)
            except Exception as e:
                print(f"Listener error: {e}")
    
    def cleanup_stale_instances(self, stale_threshold_seconds=90):
        """清理过期实例"""
        with self._lock:
            stale_instances = []
            cutoff_time = datetime.now() - timedelta(seconds=stale_threshold_seconds)
            
            for service_id, instances in self._services.items():
                for instance in instances[:]:
                    if instance.last_heartbeat and instance.last_heartbeat < cutoff_time:
                        instances.remove(instance)
                        stale_instances.append(instance)
            
            if stale_instances:
                for instance in stale_instances:
                    self._notify_listeners('stale', instance.service_id, [instance])
```

## 架构模式

### 1. 客户端发现模式
```
Client → Service Discovery Registry → Services
```
- 客户端直接查询注册表
- 客户端负责负载均衡
- 简单但客户端耦合度高

```python
class ClientServiceDiscovery:
    def __init__(self, registry: ServiceRegistry, load_balancer):
        self.registry = registry
        self.load_balancer = load_balancer
    
    def get_service_endpoint(self, service_id: str):
        """获取服务端点"""
        instances = self.registry.get_instances(service_id)
        healthy_instances = [inst for inst in instances if inst.is_healthy()]
        
        if not healthy_instances:
            raise Exception(f"No healthy instances found for service {service_id}")
        
        # 客户端负载均衡
        selected_instance = self.load_balancer.select(healthy_instances)
        return selected_instance.get_endpoint()
    
    def call_service(self, service_id: str, path: str):
        """调用服务"""
        endpoint = self.get_service_endpoint(service_id)
        response = requests.get(f"{endpoint}/{path}")
        return response.json()
```

### 2. 服务端发现模式
```
Client → Load Balancer/Gateway → Service Discovery Registry → Services
```
- 负载均衡器查询注册表
- 客户端透明
- 集中式管理

```python
class GatewayServiceDiscovery:
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.route_cache = {}
    
    def get_route_for_service(self, service_id: str):
        """获取路由信息"""
        if service_id in self.route_cache:
            return self.route_cache[service_id]
        
        instances = self.registry.get_instances(service_id)
        healthy_instances = [inst for inst in instances if inst.is_healthy()]
        
        if not healthy_instances:
            raise Exception(f"No healthy instances for service {service_id}")
        
        # 缓存路由信息
        route = {
            'service_id': service_id,
            'instances': [inst.to_dict() for inst in healthy_instances],
            'updated_at': datetime.now().isoformat()
        }
        
        self.route_cache[service_id] = route
        return route
    
    def forward_request(self, request, service_id: str):
        """转发请求"""
        route = self.get_route_for_service(service_id)
        
        # 在网关层进行负载均衡
        instance_info = self._select_instance(route['instances'])
        endpoint = f"http://{instance_info['host']}:{instance_info['port']}"
        
        return requests.get(f"{endpoint}{request.path}", headers=request.headers)
    
    def _select_instance(self, instances):
        """选择实例（简单轮询）"""
        import random
        return random.choice(instances)
```

## 实现方案

### 1. 基于Consul的实现
```python
import requests
import consul

class ConsulServiceDiscovery:
    def __init__(self, consul_host='localhost', consul_port=8500):
        self.consul = consul.Consul(host=consul_host, port=consul_port)
    
    def register_service(self, service_id, host, port, health_check=None):
        """注册服务到Consul"""
        service_definition = {
            'ID': service_id,
            'Name': service_id,
            'Address': host,
            'Port': port,
            'Check': {
                'HTTP': f'http://{host}:{port}/health',
                'Interval': '10s',
                'Timeout': '3s'
            } if health_check else None
        }
        
        return self.consul.agent.service.register(**service_definition)
    
    def discover_service(self, service_id):
        """发现服务"""
        _, services = self.consul.health.service(service_id, passing=True)
        instances = []
        
        for service in services:
            instance = ServiceInstance(
                service_id=service_id,
                host=service['Service']['Address'],
                port=service['Service']['Port'],
                metadata=service['Service']['Meta']
            )
            instances.append(instance)
        
        return instances
    
    def deregister_service(self, service_id):
        """注销服务"""
        return self.consul.agent.service.deregister(service_id)
```

### 2. 基于Eureka的实现
```python
import requests
import json
from urllib.parse import urljoin

class EurekaServiceDiscovery:
    def __init__(self, eureka_server_url):
        self.eureka_server_url = eureka_server_url.rstrip('/')
        self.app_name = None
    
    def register_instance(self, app_name, host, port, health_check_url=None):
        """注册实例到Eureka"""
        self.app_name = app_name.upper()
        
        instance_data = {
            'instance': {
                'instanceId': f"{host}:{app_name}:{port}",
                'hostName': host,
                'app': self.app_name,
                'ipAddr': host,
                'status': 'UP',
                'port': {
                    '$': port,
                    '@enabled': 'true'
                },
                'healthCheckUrl': health_check_url or f"http://{host}:{port}/health",
                'vipAddress': app_name,
                'secureVipAddress': app_name,
                'metadata': {
                    'management.port': str(port)
                }
            }
        }
        
        url = urljoin(self.eureka_server_url, f"/apps/{self.app_name}")
        headers = {'Content-Type': 'application/json'}
        
        response = requests.post(url, json=instance_data, headers=headers)
        return response.status_code == 204
    
    def get_instances(self, app_name):
        """获取应用实例"""
        url = urljoin(self.eureka_server_url, f"/apps/{app_name.upper()}")
        response = requests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            instances = []
            
            for instance in data['application']['instance']:
                service_instance = ServiceInstance(
                    service_id=app_name,
                    host=instance['hostName'],
                    port=int(instance['port']['$']),
                    metadata=instance.get('metadata', {})
                )
                service_instance.status = instance['status']
                instances.append(service_instance)
            
            return instances
        
        return []
    
    def send_heartbeat(self, app_name, host, port):
        """发送心跳"""
        url = urljoin(
            self.eureka_server_url, 
            f"/apps/{app_name.upper()}/{host}:{app_name}:{port}"
        )
        
        # Eureka心跳通过PUT请求，不需要body
        response = requests.put(url)
        return response.status_code == 200
```

### 3. 基于Etcd的实现
```python
import etcd3
import json
from datetime import datetime

class EtcdServiceDiscovery:
    def __init__(self, etcd_endpoints=['localhost:2379']):
        self.etcd = etcd3.client(host=etcd_endpoints[0].split(':')[0], 
                               port=int(etcd_endpoints[0].split(':')[1]))
        self.prefix = "/services/"
    
    def register_service(self, service_id, host, port, metadata=None):
        """注册服务"""
        instance = ServiceInstance(service_id, host, port, metadata)
        
        key = f"{self.prefix}{service_id}/{host}:{port}"
        value = json.dumps({
            'service_id': service_id,
            'host': host,
            'port': port,
            'metadata': metadata or {},
            'registered_at': datetime.now().isoformat()
        })
        
        # 设置TTL为30秒
        return self.etcd.put(key, value, lease=30)
    
    def watch_service_changes(self, service_id):
        """监听服务变更"""
        prefix = f"{self.prefix}{service_id}/"
        
        for event in self.etcd.watch_prefix(prefix):
            if event.events:
                event_type = event.events[0].type
                key = event.events[0].key.decode()
                value = json.loads(event.events[0].value.decode())
                
                yield {
                    'type': event_type,
                    'key': key,
                    'value': value
                }
    
    def get_instances(self, service_id):
        """获取服务实例"""
        prefix = f"{self.prefix}{service_id}/"
        instances = []
        
        for key, value in self.etcd.get_prefix(prefix):
            data = json.loads(value.decode())
            instance = ServiceInstance(
                service_id=data['service_id'],
                host=data['host'],
                port=data['port'],
                metadata=data.get('metadata', {})
            )
            instances.append(instance)
        
        return instances
```

### 4. 基于ZooKeeper的实现
```python
from kazoo.client import KazooClient
from kazoo.recipe.watchers import DataWatch
import json

class ZooKeeperServiceDiscovery:
    def __init__(self, zk_hosts='localhost:2181'):
        self.zk = KazooClient(hosts=zk_hosts)
        self.zk.start()
        self.base_path = "/services"
        
        # 确保基础路径存在
        if self.zk.exists(self.base_path) is None:
            self.zk.create(self.base_path)
    
    def register_service(self, service_id, host, port, metadata=None):
        """注册服务"""
        service_path = f"{self.base_path}/{service_id}"
        
        # 确保服务路径存在
        if self.zk.exists(service_path) is None:
            self.zk.create(service_path)
        
        # 创建实例节点
        instance_id = f"{host}:{port}"
        instance_path = f"{service_path}/{instance_id}"
        
        instance_data = json.dumps({
            'host': host,
            'port': port,
            'metadata': metadata or {},
            'registered_at': datetime.now().isoformat()
        })
        
        # 创建临时节点，服务下线时自动删除
        return self.zk.create(instance_path, instance_data.encode(), 
                             ephemeral=True, makepath=True)
    
    def get_instances(self, service_id):
        """获取服务实例"""
        service_path = f"{self.base_path}/{service_id}"
        
        if self.zk.exists(service_path) is None:
            return []
        
        instances = []
        children = self.zk.get_children(service_path)
        
        for child in children:
            instance_path = f"{service_path}/{child}"
            data, _ = self.zk.get(instance_path)
            
            instance_info = json.loads(data.decode())
            instance = ServiceInstance(
                service_id=service_id,
                host=instance_info['host'],
                port=instance_info['port'],
                metadata=instance_info.get('metadata', {})
            )
            instances.append(instance)
        
        return instances
    
    def watch_service(self, service_id, callback):
        """监听服务变更"""
        service_path = f"{self.base_path}/{service_id}"
        
        @DataWatch(self.zk, service_path)
        def watch_children(data, stat):
            if stat:
                callback(service_id)
```

## 健康检查机制

### 1. 主动健康检查
```python
import asyncio
import aiohttp
from datetime import datetime, timedelta

class ActiveHealthChecker:
    def __init__(self, registry: ServiceRegistry, check_interval=10):
        self.registry = registry
        self.check_interval = check_interval
        self.running = False
        self._tasks = []
    
    async def start(self):
        """启动健康检查"""
        self.running = True
        while self.running:
            await self._check_all_services()
            await asyncio.sleep(self.check_interval)
    
    async def stop(self):
        """停止健康检查"""
        self.running = False
        for task in self._tasks:
            task.cancel()
    
    async def _check_all_services(self):
        """检查所有服务"""
        services = self.registry.get_all_services()
        
        for service_id, instances in services.items():
            for instance in instances:
                task = asyncio.create_task(
                    self._check_instance(instance)
                )
                self._tasks.append(task)
    
    async def _check_instance(self, instance: ServiceInstance):
        """检查单个实例"""
        try:
            async with aiohttp.ClientSession() as session:
                timeout = aiohttp.ClientTimeout(total=5)
                async with session.get(
                    instance.health_check_url, 
                    timeout=timeout
                ) as response:
                    if response.status == 200:
                        self._mark_instance_healthy(instance)
                    else:
                        self._mark_instance_unhealthy(instance)
        except Exception as e:
            self._mark_instance_unhealthy(instance)
    
    def _mark_instance_healthy(self, instance: ServiceInstance):
        """标记实例为健康"""
        if instance.status != "UP":
            instance.status = "UP"
            instance.last_heartbeat = datetime.now()
            print(f"Instance {instance.service_id} - {instance.host}:{instance.port} is healthy")
    
    def _mark_instance_unhealthy(self, instance: ServiceInstance):
        """标记实例为不健康"""
        if instance.status == "UP":
            instance.status = "DOWN"
            print(f"Instance {instance.service_id} - {instance.host}:{instance.port} is unhealthy")
```

### 2. 心跳机制
```python
import time
import threading

class HeartbeatManager:
    def __init__(self, registry: ServiceRegistry):
        self.registry = registry
        self.service_instances = {}
        self.running = False
        self._thread = None
    
    def register_instance(self, instance: ServiceInstance, heartbeat_interval=30):
        """注册实例并设置心跳"""
        self.service_instances[instance] = heartbeat_interval
        self.registry.register(instance)
    
    def start(self):
        """启动心跳管理"""
        self.running = True
        self._thread = threading.Thread(target=self._heartbeat_loop)
        self._thread.start()
    
    def stop(self):
        """停止心跳管理"""
        self.running = False
        if self._thread:
            self._thread.join()
    
    def _heartbeat_loop(self):
        """心跳循环"""
        while self.running:
            current_time = time.time()
            
            for instance, interval in self.service_instances.items():
                if current_time - instance.last_heartbeat.timestamp() >= interval:
                    self.registry.heartbeat(
                        instance.service_id, 
                        instance.host, 
                        instance.port
                    )
                    print(f"Heartbeat sent for {instance.service_id} - {instance.host}:{instance.port}")
            
            time.sleep(5)  # 每5秒检查一次
```

## 负载均衡集成

### 1. 服务发现负载均衡器
```python
from abc import ABC, abstractmethod
import random
import time
from collections import defaultdict

class LoadBalancer(ABC):
    @abstractmethod
    def select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        pass

class RoundRobinLoadBalancer(LoadBalancer):
    def __init__(self):
        self.counters = defaultdict(int)
    
    def select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        if not instances:
            raise ValueError("No instances available")
        
        service_id = instances[0].service_id
        index = self.counters[service_id] % len(instances)
        self.counters[service_id] += 1
        
        return instances[index]

class LeastConnectionsLoadBalancer(LoadBalancer):
    def __init__(self):
        self.connection_counts = defaultdict(int)
    
    def select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        if not instances:
            raise ValueError("No instances available")
        
        # 选择连接数最少的实例
        min_connections = min(
            self.connection_counts[instance.get_endpoint()] 
            for instance in instances
        )
        
        available_instances = [
            instance for instance in instances
            if self.connection_counts[instance.get_endpoint()] == min_connections
        ]
        
        selected = random.choice(available_instances)
        self.connection_counts[selected.get_endpoint()] += 1
        
        return selected

class WeightedRoundRobinLoadBalancer(LoadBalancer):
    def __init__(self):
        self.weights = {}
        self.current_weights = defaultdict(float)
    
    def set_weights(self, instances: List[ServiceInstance]):
        """设置实例权重"""
        self.weights = {}
        for instance in instances:
            weight = float(instance.metadata.get('weight', 1))
            self.weights[instance.get_endpoint()] = weight
    
    def select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        if not instances:
            raise ValueError("No instances available")
        
        if not self.weights:
            self.set_weights(instances)
        
        service_id = instances[0].service_id
        total_weight = sum(self.weights.values())
        
        # 更新当前权重
        for instance in instances:
            endpoint = instance.get_endpoint()
            self.current_weights[endpoint] += self.weights[endpoint]
        
        # 选择权重最高的实例
        selected_endpoint = max(
            self.current_weights.keys(),
            key=lambda x: self.current_weights[x]
        )
        
        # 减少选中实例的权重
        self.current_weights[selected_endpoint] -= total_weight
        
        # 返回对应的实例
        for instance in instances:
            if instance.get_endpoint() == selected_endpoint:
                return instance
        
        return instances[0]
```

## 最佳实践

### 1. 服务注册最佳实践
```python
class ServiceRegistrationManager:
    def __init__(self, discovery: ServiceDiscovery):
        self.discovery = discovery
        self.heartbeat_manager = HeartbeatManager(discovery.registry)
    
    def register_with_cleanup(self, service_config):
        """注册服务并设置清理"""
        try:
            instance = ServiceInstance(**service_config)
            self.discovery.register(instance)
            self.heartbeat_manager.register_instance(instance)
            
            # 注册信号处理器，确保服务下线时清理
            import atexit
            atexit.register(self.deregister, service_config)
            
        except Exception as e:
            print(f"Failed to register service: {e}")
            raise
    
    def deregister(self, service_config):
        """注销服务"""
        try:
            self.discovery.deregister(
                service_config['service_id'],
                service_config['host'],
                service_config['port']
            )
        except Exception as e:
            print(f"Failed to deregister service: {e}")
```

### 2. 客户端缓存策略
```python
import time
from typing import Optional

class ServiceDiscoveryClient:
    def __init__(self, discovery: ServiceDiscovery, cache_ttl=30):
        self.discovery = discovery
        self.cache_ttl = cache_ttl
        self.cache = {}
        self.cache_timestamps = {}
    
    def get_cached_instances(self, service_id: str) -> Optional[List[ServiceInstance]]:
        """获取缓存的服务实例"""
        cache_key = f"instances_{service_id}"
        current_time = time.time()
        
        # 检查缓存是否有效
        if (cache_key in self.cache and 
            cache_key in self.cache_timestamps and
            current_time - self.cache_timestamps[cache_key] < self.cache_ttl):
            return self.cache[cache_key]
        
        # 缓存过期，重新获取
        try:
            instances = self.discovery.get_instances(service_id)
            self.cache[cache_key] = instances
            self.cache_timestamps[cache_key] = current_time
            return instances
        except Exception as e:
            # 如果获取失败，返回过期缓存
            return self.cache.get(cache_key)
    
    def invalidate_cache(self, service_id: str):
        """使缓存失效"""
        cache_key = f"instances_{service_id}"
        if cache_key in self.cache:
            del self.cache[cache_key]
        if cache_key in self.cache_timestamps:
            del self.cache_timestamps[cache_key]
```

### 3. 容错和重试机制
```python
import asyncio
import random
from typing import List

class FaultTolerantServiceClient:
    def __init__(self, service_discovery: ServiceDiscovery, 
                 max_retries=3, retry_delay=1.0):
        self.service_discovery = service_discovery
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.load_balancer = RoundRobinLoadBalancer()
    
    async def call_service_with_retry(self, service_id: str, 
                                    request_func, *args, **kwargs):
        """带重试的服务调用"""
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                # 获取健康的实例
                instances = self.service_discovery.get_healthy_instances(service_id)
                if not instances:
                    raise Exception(f"No healthy instances for {service_id}")
                
                # 负载均衡选择实例
                selected_instance = self.load_balancer.select(instances)
                
                # 执行请求
                return await request_func(selected_instance, *args, **kwargs)
                
            except Exception as e:
                last_exception = e
                
                if attempt < self.max_retries:
                    # 指数退避重试
                    delay = self.retry_delay * (2 ** attempt) + random.uniform(0, 1)
                    await asyncio.sleep(delay)
                else:
                    break
        
        raise last_exception
```

## 总结

服务发现是微服务架构的基础设施，正确选择和实现服务发现机制对于构建可靠、可扩展的微服务系统至关重要。

### 选择建议

1. **Consul**：功能完整，强大健康检查，适合复杂场景
2. **Eureka**：Spring Cloud生态，适合Java应用
3. **Etcd**：高性能KV存储，适合Kubernetes环境
4. **ZooKeeper**：成熟稳定，适合大规模系统

### 下一步学习
- [服务间通信模式](02-service-communication.md)
- [容错和断路器](03-fault-tolerance.md)
- [服务网格](04-service-mesh.md)

---

*本文档是微服务架构学习系列的核心内容，建议结合实际项目进行深入实践。*