# Consistency Models 详解

## 目录
1. [一致性模型概述](#一致性模型概述)
2. [强一致性模型](#强一致性模型)
3. [弱一致性模型](#弱一致性模型)
4. [最终一致性](#最终一致性)
5. [Causal Consistency](#causal-consistency)
6. [Eventual Consistency](#eventual-consistency)
7. [Read-your-writes Consistency](#read-your-writes-consistency)
8. [Monotonic Read Consistency](#monotonic-read-consistency)
9. [Monotonic Write Consistency](#monotonic-write-consistency)
10. [Session Consistency](#session-consistency)
11. [实际应用案例](#实际应用案例)
12. [Python实现](#python实现)
13. [Go语言实现](#go语言实现)
14. [性能分析](#性能分析)
15. [最佳实践](#最佳实践)

## 一致性模型概述

### 什么是一致性模型

一致性模型（Consistency Model）是分布式系统中确保数据在多个副本之间保持协调的规则和约束。它定义了操作执行的顺序和时机，以及用户能看到的数据状态。

```python
from typing import Dict, List, Any, Set, Optional
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
from collections import defaultdict, deque
import uuid

class ConsistencyLevel(Enum):
    """一致性级别枚举"""
    STRONG = "strong"
    WEAK = "weak"
    EVENTUAL = "eventual"
    CAUSAL = "causal"
    SESSION = "session"
    MONOTONIC_READ = "monotonic_read"
    MONOTONIC_WRITE = "monotonic_write"
    READ_YOUR_WRITES = "read_your_writes"

class OperationType(Enum):
    """操作类型"""
    READ = "read"
    WRITE = "write"
    UPDATE = "update"
    DELETE = "delete"

@dataclass
class Operation:
    """操作定义"""
    id: str
    type: OperationType
    key: str
    value: Any = None
    timestamp: float = field(default_factory=time.time)
    client_id: str = ""
    session_id: str = ""
    vector_clock: Dict[str, int] = field(default_factory=dict)
    causal_deps: Set[str] = field(default_factory=set)

class ConsistencyModel:
    """一致性模型基类"""
    
    def __init__(self, name: str, level: ConsistencyLevel):
        self.name = name
        self.level = level
        self.replicas = {}
        self.operations_log: List[Operation] = []
        self.client_sessions = {}
        self.mutex = threading.Lock()
    
    def add_replica(self, replica_id: str, data: Dict[str, Any]):
        """添加副本"""
        with self.mutex:
            self.replicas[replica_id] = {
                'data': data.copy(),
                'last_updated': time.time(),
                'operation_log': []
            }
    
    def execute_operation(self, operation: Operation) -> bool:
        """执行操作"""
        raise NotImplementedError("Subclasses must implement execute_operation")
    
    def read(self, key: str, replica_id: str = None) -> Any:
        """读取操作"""
        raise NotImplementedError("Subclasses must implement read")
    
    def write(self, key: str, value: Any, client_id: str = None) -> bool:
        """写入操作"""
        operation = Operation(
            id=str(uuid.uuid4()),
            type=OperationType.WRITE,
            key=key,
            value=value,
            client_id=client_id or "default_client",
            timestamp=time.time()
        )
        return self.execute_operation(operation)
    
    def get_consistency_guarantees(self) -> Dict[str, str]:
        """获取一致性保证"""
        return {
            'definition': 'Consistency Model defines the behavior of distributed system',
            'properties': [
                'Linearizability',
                'Sequential Consistency',
                'Causal Consistency',
                'Eventual Consistency'
            ]
        }

class ConsistencyModelDemo:
    """一致性模型演示"""
    
    def __init__(self):
        self.models = {}
        self.setup_models()
    
    def setup_models(self):
        """设置不同的一致性模型"""
        # 这些将在后续部分中实现
        pass
    
    def compare_models(self):
        """比较不同一致性模型"""
        comparison = {
            'Strong Consistency': {
                'latency': 'High',
                'availability': 'Low',
                'consistency': 'Highest',
                'complexity': 'High',
                'use_cases': ['Financial systems', 'Critical transactions']
            },
            'Eventual Consistency': {
                'latency': 'Low',
                'availability': 'High',
                'consistency': 'Eventual',
                'complexity': 'Medium',
                'use_cases': ['Social media', 'Content delivery', 'Caching']
            },
            'Causal Consistency': {
                'latency': 'Medium',
                'availability': 'Medium',
                'consistency': 'Causal',
                'complexity': 'Medium',
                'use_cases': ['Collaborative editing', 'Social feeds']
            }
        }
        
        print("=== Consistency Models Comparison ===\n")
        for model, properties in comparison.items():
            print(f"**{model}**")
            for prop, value in properties.items():
                print(f"  {prop}: {value}")
            print()

# 基本一致性模型演示
def demo_consistency_models():
    """演示一致性模型概念"""
    
    print("=== Consistency Models Overview ===\n")
    
    # 创建一致性模型演示
    demo = ConsistencyModelDemo()
    demo.compare_models()
    
    # 展示一致性谱系
    print("=== Consistency Spectrum ===\n")
    
    consistency_spectrum = {
        'Strongest': [
            'Linearizability',
            'Sequential Consistency'
        ],
        'Strong': [
            'Causal Consistency',
            'Read Your Writes',
            'Monotonic Reads',
            'Monotonic Writes'
        ],
        'Medium': [
            'Session Consistency',
            'Bounded Staleness'
        ],
        'Weak': [
            'Eventual Consistency',
            'Monotonic eventual'
        ],
        'Weakest': [
            'No guarantees'
        ]
    }
    
    for level, models in consistency_spectrum.items():
        print(f"**{level}**")
        for model in models:
            print(f"  • {model}")
        print()

if __name__ == "__main__":
    demo_consistency_models()
```

## 强一致性模型

```python
class StrongConsistencyModel(ConsistencyModel):
    """强一致性模型实现"""
    
    def __init__(self):
        super().__init__("Strong Consistency", ConsistencyLevel.STRONG)
        self.global_order = []
        self.pending_operations = deque()
    
    def execute_operation(self, operation: Operation) -> bool:
        """强一致性：操作必须按全局顺序执行"""
        with self.mutex:
            # 检查是否有冲突操作
            if not self._check_conflicts(operation):
                return False
            
            # 等待所有前置条件满足
            if not self._wait_for_prerequisites(operation):
                return False
            
            # 在所有副本上执行操作
            success_count = 0
            for replica_id, replica in self.replicas.items():
                if self._execute_on_replica(replica_id, operation):
                    success_count += 1
            
            # 需要在多数副本上成功才能提交
            if success_count >= len(self.replicas) // 2 + 1:
                self.operations_log.append(operation)
                self.global_order.append(operation.id)
                self._propagate_to_all_replicas(operation)
                return True
            
            return False
    
    def read(self, key: str, replica_id: str = None) -> Any:
        """强一致性读取：必须看到最新的写入"""
        with self.mutex:
            # 确保所有之前的操作都已执行
            self._sync_all_replicas()
            
            # 从指定副本读取（如果指定）
            if replica_id and replica_id in self.replicas:
                return self.replicas[replica_id]['data'].get(key)
            
            # 从所有副本读取并验证一致性
            values = []
            for replica in self.replicas.values():
                values.append(replica['data'].get(key))
            
            # 检查是否所有副本的值一致
            if len(set(values)) > 1:
                # 数据不一致，等待同步
                self._resolve_inconsistency(key)
            
            return values[0] if values else None
    
    def _check_conflicts(self, operation: Operation) -> bool:
        """检查操作冲突"""
        # 强一致性不允许冲突操作
        for existing_op in self.operations_log:
            if existing_op.key == operation.key and existing_op.id != operation.id:
                # 检查时间戳是否合理
                if existing_op.timestamp > operation.timestamp:
                    return False
        return True
    
    def _wait_for_prerequisites(self, operation: Operation) -> bool:
        """等待前置条件满足"""
        # 强一致性要求所有之前的操作都已完成
        required_ops = [op for op in self.operations_log if op.timestamp < operation.timestamp]
        
        for req_op in required_ops:
            if req_op.id not in self.global_order:
                # 等待操作完成
                max_wait = 10.0  # 10秒超时
                start_time = time.time()
                while time.time() - start_time < max_wait:
                    if req_op.id in self.global_order:
                        break
                    time.sleep(0.1)
                else:
                    return False  # 超时
        
        return True
    
    def _execute_on_replica(self, replica_id: str, operation: Operation) -> bool:
        """在单个副本上执行操作"""
        replica = self.replicas[replica_id]
        
        try:
            if operation.type == OperationType.WRITE:
                replica['data'][operation.key] = operation.value
                replica['last_updated'] = operation.timestamp
            elif operation.type == OperationType.DELETE:
                if operation.key in replica['data']:
                    del replica['data'][operation.key]
                    replica['last_updated'] = operation.timestamp
            else:
                return False
            
            replica['operation_log'].append(operation.id)
            return True
        except Exception as e:
            print(f"Error executing operation on replica {replica_id}: {e}")
            return False
    
    def _propagate_to_all_replicas(self, operation: Operation):
        """向所有副本传播操作"""
        for replica_id in self.replicas:
            if replica_id not in [op.id for op in self.operations_log]:
                self._execute_on_replica(replica_id, operation)
    
    def _sync_all_replicas(self):
        """同步所有副本"""
        # 强制所有副本同步到最新状态
        for replica_id, replica in self.replicas.items():
            latest_timestamp = max([op.timestamp for op in self.operations_log] or [0])
            if replica['last_updated'] < latest_timestamp:
                # 应用所有缺失的操作
                for operation in self.operations_log:
                    if operation.timestamp > replica['last_updated']:
                        self._execute_on_replica(replica_id, operation)
    
    def _resolve_inconsistency(self, key: str):
        """解决数据不一致"""
        # 强制所有副本同步
        self._sync_all_replicas()

class LinearizabilityModel(ConsistencyModel):
    """线性化一致性模型"""
    
    def __init__(self):
        super().__init__("Linearizability", ConsistencyLevel.STRONG)
        self.global_sequence = []
        self.operation_timestamps = {}
    
    def execute_operation(self, operation: Operation) -> bool:
        """线性化：操作看起来在某个时间点瞬间完成"""
        with self.mutex:
            # 获取全局时间戳
            timestamp = time.time()
            operation.timestamp = timestamp
            
            # 按时间戳排序执行
            self.operation_timestamps[operation.id] = timestamp
            self.global_sequence.append(operation.id)
            self.global_sequence.sort(key=lambda op_id: self.operation_timestamps[op_id])
            
            # 在所有副本上执行
            success_count = 0
            for replica_id in self.replicas:
                if self._execute_linearizable_op(replica_id, operation):
                    success_count += 1
            
            # 需要多数副本同意
            return success_count >= len(self.replicas) // 2 + 1
    
    def read(self, key: str, replica_id: str = None) -> Any:
        """线性化读取：必须看到所有在它开始前完成的写入"""
        with self.mutex:
            read_timestamp = time.time()
            
            # 获取在此读取之前完成的所有写入
            prior_writes = [op for op in self.operations_log 
                           if op.timestamp < read_timestamp and op.key == key]
            
            # 如果指定了副本，从该副本读取
            if replica_id:
                value = self.replicas[replica_id]['data'].get(key)
                # 验证该值确实反映了所有之前的写入
                latest_write = max(prior_writes, key=lambda op: op.timestamp, default=None)
                if latest_write and latest_write.value != value:
                    self._resolve_linearizable_read(key, value, latest_write.value)
                return value
            
            # 从多数副本读取并验证
            values = []
            for replica in self.replicas.values():
                values.append(replica['data'].get(key))
            
            # 线性化要求所有读取看到相同的值
            if len(set(values)) > 1:
                # 选择时间戳最新的值
                candidate_values = [(val, self._get_value_timestamp(key, val)) 
                                  for val in set(values)]
                return max(candidate_values, key=lambda x: x[1])[0]
            
            return values[0] if values else None
    
    def _execute_linearizable_op(self, replica_id: str, operation: Operation) -> bool:
        """执行线性化操作"""
        replica = self.replicas[replica_id]
        
        # 模拟网络延迟
        time.sleep(0.01)
        
        if operation.type == OperationType.WRITE:
            replica['data'][operation.key] = operation.value
            replica['last_updated'] = operation.timestamp
            return True
        elif operation.type == OperationType.DELETE:
            if operation.key in replica['data']:
                del replica['data'][operation.key]
                replica['last_updated'] = operation.timestamp
                return True
        
        return False
    
    def _get_value_timestamp(self, key: str, value: Any) -> float:
        """获取值的最后更新时间戳"""
        latest_timestamp = 0.0
        for op in self.operations_log:
            if op.key == key and op.value == value:
                latest_timestamp = max(latest_timestamp, op.timestamp)
        return latest_timestamp
    
    def _resolve_linearizable_read(self, key: str, read_value: Any, expected_value: Any):
        """解决线性化读取中的不一致"""
        # 强制副本同步
        for replica in self.replicas.values():
            if replica['data'].get(key) != expected_value:
                replica['data'][key] = expected_value

# 强一致性模型演示
def demo_strong_consistency():
    """演示强一致性模型"""
    
    print("=== Strong Consistency Model Demo ===\n")
    
    # 测试强一致性
    strong_model = StrongConsistencyModel()
    
    # 添加副本
    strong_model.add_replica('replica1', {'key1': 'initial1'})
    strong_model.add_replica('replica2', {'key1': 'initial1'})
    strong_model.add_replica('replica3', {'key1': 'initial1'})
    
    print("Created 3-replica strong consistency system")
    
    # 执行写操作
    print("\n=== Write Operation ===")
    success = strong_model.write('key1', 'value1', 'client1')
    print(f"Write result: {success}")
    
    # 读取操作
    print("\n=== Read Operation ===")
    value = strong_model.read('key1', 'replica1')
    print(f"Read from replica1: {value}")
    
    value = strong_model.read('key1', 'replica2')
    print(f"Read from replica2: {value}")
    
    # 测试并发写入
    print("\n=== Concurrent Write Test ===")
    operations = [
        Operation('op1', OperationType.WRITE, 'key1', 'value2'),
        Operation('op2', OperationType.WRITE, 'key1', 'value3'),
        Operation('op3', OperationType.WRITE, 'key1', 'value4')
    ]
    
    results = []
    for op in operations:
        result = strong_model.execute_operation(op)
        results.append(result)
        print(f"Operation {op.id}: {'Success' if result else 'Failed'}")
    
    # 最终值检查
    final_value = strong_model.read('key1')
    print(f"Final value: {final_value}")
    
    # 测试线性化模型
    print("\n=== Linearizability Model Demo ===")
    
    linear_model = LinearizabilityModel()
    linear_model.add_replica('lin_rep1', {})
    linear_model.add_replica('lin_rep2', {})
    linear_model.add_replica('lin_rep3', {})
    
    # 线性化写入和读取
    linear_model.write('test_key', 'linear_value', 'client1')
    value = linear_model.read('test_key')
    print(f"Linearizable read result: {value}")

if __name__ == "__main__":
    demo_strong_consistency()
```

## 弱一致性模型

```python
class WeakConsistencyModel(ConsistencyModel):
    """弱一致性模型实现"""
    
    def __init__(self):
        super().__init__("Weak Consistency", ConsistencyLevel.WEAK)
        self.local_clocks = defaultdict(float)
        self.replica_sync_intervals = defaultdict(float)
        self.stale_reads_allowed = True
    
    def execute_operation(self, operation: Operation) -> bool:
        """弱一致性：操作可能在不同时间在不同副本上生效"""
        with self.mutex:
            # 获取本地时间戳
            local_time = time.time()
            operation.timestamp = local_time
            
            # 选择目标副本（可以是任意的）
            target_replicas = self._select_target_replicas(operation)
            
            success_count = 0
            for replica_id in target_replicas:
                if self._execute_weak_op(replica_id, operation):
                    success_count += 1
            
            # 只需要一个副本成功即可
            return success_count > 0
    
    def read(self, key: str, replica_id: str = None) -> Any:
        """弱一致性读取：可能看到过期数据"""
        with self.mutex:
            # 如果指定了副本，从该副本读取
            if replica_id:
                return self._read_from_replica(replica_id, key)
            
            # 随机选择一个副本读取
            replica_ids = list(self.replicas.keys())
            if not replica_ids:
                return None
            
            selected_replica = replica_ids[0]  # 简单选择第一个
            return self._read_from_replica(selected_replica, key)
    
    def _select_target_replicas(self, operation: Operation) -> List[str]:
        """选择目标副本"""
        # 简单策略：随机选择一个或多个副本
        replica_ids = list(self.replicas.keys())
        if not replica_ids:
            return []
        
        # 30%的概率选择所有副本，70%选择一个副本
        if random.random() < 0.3:
            return replica_ids
        else:
            return [random.choice(replica_ids)]
    
    def _execute_weak_op(self, replica_id: str, operation: Operation) -> bool:
        """在副本上执行弱一致性操作"""
        replica = self.replicas[replica_id]
        
        try:
            if operation.type == OperationType.WRITE:
                # 模拟异步写入
                time.sleep(0.001)  # 很短的延迟
                replica['data'][operation.key] = operation.value
                replica['last_updated'] = operation.timestamp
                
                # 记录操作但不立即同步
                replica['operation_log'].append(operation.id)
                return True
            elif operation.type == OperationType.DELETE:
                if operation.key in replica['data']:
                    del replica['data'][operation.key]
                    replica['last_updated'] = operation.timestamp
                    return True
        except Exception:
            return False
        
        return False
    
    def _read_from_replica(self, replica_id: str, key: str) -> Any:
        """从指定副本读取"""
        replica = self.replicas.get(replica_id, {})
        return replica.get('data', {}).get(key)
    
    def _sync_replica_async(self, replica_id: str):
        """异步同步副本"""
        def sync_worker():
            time.sleep(random.uniform(0.1, 1.0))  # 随机延迟
            # 执行异步同步逻辑
            self._perform_async_sync(replica_id)
        
        thread = threading.Thread(target=sync_worker)
        thread.daemon = True
        thread.start()
    
    def _perform_async_sync(self, replica_id: str):
        """执行异步同步"""
        replica = self.replicas.get(replica_id)
        if not replica:
            return
        
        # 模拟从其他副本获取最新数据
        latest_data = {}
        for other_id, other_replica in self.replicas.items():
            if other_id != replica_id:
                latest_data.update(other_replica.get('data', {}))
        
        # 更新本地数据（可能不完整）
        for key, value in latest_data.items():
            if random.random() < 0.8:  # 80%概率更新
                replica['data'][key] = value
                replica['last_updated'] = time.time()

class EventualConsistencyModel(ConsistencyModel):
    """最终一致性模型实现"""
    
    def __init__(self):
        super().__init__("Eventual Consistency", ConsistencyLevel.EVENTUAL)
        self.vector_clocks = defaultdict(lambda: defaultdict(int))
        self.pending_syncs = defaultdict(list)
        self.gossip_interval = 1.0
    
    def execute_operation(self, operation: Operation) -> bool:
        """最终一致性：操作最终会在所有副本上生效"""
        with self.mutex:
            # 为操作生成向量时钟
            operation.vector_clock = self._generate_vector_clock(operation.client_id)
            self.operations_log.append(operation)
            
            # 立即在本地执行
            local_replica_id = 'local'
            if local_replica_id in self.replicas:
                self._execute_eventual_op(local_replica_id, operation)
            
            # 异步传播到其他副本
            self._schedule_gossip_propagation(operation)
            
            return True
    
    def read(self, key: str, replica_id: str = None) -> Any:
        """最终一致性读取：返回当前副本的本地数据"""
        with self.mutex:
            if replica_id:
                return self._read_eventual_from_replica(replica_id, key)
            
            # 默认从本地读取
            local_replica_id = 'local'
            return self._read_eventual_from_replica(local_replica_id, key)
    
    def _generate_vector_clock(self, client_id: str) -> Dict[str, int]:
        """生成向量时钟"""
        clock = self.vector_clocks[client_id].copy()
        clock[client_id] = clock.get(client_id, 0) + 1
        return clock
    
    def _execute_eventual_op(self, replica_id: str, operation: Operation) -> bool:
        """执行最终一致性操作"""
        replica = self.replicas[replica_id]
        
        try:
            if operation.type == OperationType.WRITE:
                # 检查操作是否应该被应用
                if self._should_apply_operation(replica_id, operation):
                    replica['data'][operation.key] = operation.value
                    replica['last_updated'] = operation.timestamp
                    replica['vector_clock'] = operation.vector_clock
                    return True
            elif operation.type == OperationType.DELETE:
                if operation.key in replica['data']:
                    del replica['data'][operation.key]
                    replica['last_updated'] = operation.timestamp
                    return True
        except Exception:
            return False
        
        return False
    
    def _should_apply_operation(self, replica_id: str, operation: Operation) -> bool:
        """检查操作是否应该被应用"""
        replica = self.replicas[replica_id]
        local_clock = replica.get('vector_clock', {})
        
        # 如果操作有因果依赖，检查是否满足
        for dep_key, dep_value in operation.vector_clock.items():
            if local_clock.get(dep_key, 0) < dep_value:
                return False
        
        return True
    
    def _read_eventual_from_replica(self, replica_id: str, key: str) -> Any:
        """从副本读取最终一致性数据"""
        replica = self.replicas.get(replica_id, {})
        return replica.get('data', {}).get(key)
    
    def _schedule_gossip_propagation(self, operation: Operation):
        """安排gossip传播"""
        def gossip_worker():
            time.sleep(random.uniform(0.1, 0.5))  # 随机延迟
            
            # 选择几个随机副本进行gossip
            replica_ids = [rid for rid in self.replicas.keys() if rid != 'local']
            target_count = max(1, len(replica_ids) // 3)
            targets = random.sample(replica_ids, min(target_count, len(replica_ids)))
            
            for target_id in targets:
                self._gossip_to_replica(target_id, operation)
        
        thread = threading.Thread(target=gossip_worker)
        thread.daemon = True
        thread.start()
    
    def _gossip_to_replica(self, target_id: str, operation: Operation):
        """向目标副本发送gossip消息"""
        if target_id in self.replicas:
            self._execute_eventual_op(target_id, operation)
            print(f"Gossip: operation {operation.id} propagated to {target_id}")

# 弱一致性模型演示
def demo_weak_consistency():
    """演示弱一致性模型"""
    
    print("=== Weak Consistency Model Demo ===\n")
    
    # 测试弱一致性
    weak_model = WeakConsistencyModel()
    
    # 添加副本
    weak_model.add_replica('weak_rep1', {'shared_key': 'initial'})
    weak_model.add_replica('weak_rep2', {'shared_key': 'initial'})
    weak_model.add_replica('weak_rep3', {'shared_key': 'initial'})
    
    print("Created 3-replica weak consistency system")
    
    # 执行异步写入
    print("\n=== Asynchronous Write Operations ===")
    for i in range(5):
        operation = Operation(
            id=f'weak_op_{i}',
            type=OperationType.WRITE,
            key='shared_key',
            value=f'value_{i}',
            client_id=f'client_{i % 2}'
        )
        success = weak_model.execute_operation(operation)
        print(f"Write {i}: {'Success' if success else 'Failed'}")
        
        # 立即读取，可能看到过期数据
        value = weak_model.read('shared_key')
        print(f"  Immediate read: {value}")
        
        time.sleep(0.1)  # 短暂等待
    
    # 等待异步同步
    print("\n=== Waiting for Async Synchronization ===")
    time.sleep(2.0)
    
    # 再次读取
    print("\n=== Final Reads ===")
    for replica_id in ['weak_rep1', 'weak_rep2', 'weak_rep3']:
        value = weak_model.read('shared_key', replica_id)
        print(f"Read from {replica_id}: {value}")
    
    # 测试最终一致性
    print("\n=== Eventual Consistency Model Demo ===")
    
    eventual_model = EventualConsistencyModel()
    eventual_model.add_replica('local', {})
    eventual_model.add_replica('rep1', {})
    eventual_model.add_replica('rep2', {})
    eventual_model.add_replica('rep3', {})
    
    # 执行一系列操作
    operations = [
        Operation('evt_op_1', OperationType.WRITE, 'user_data', 'user1_data', client_id='user1'),
        Operation('evt_op_2', OperationType.WRITE, 'user_data', 'user1_updated', client_id='user1'),
        Operation('evt_op_3', OperationType.WRITE, 'user_data', 'user2_data', client_id='user2')
    ]
    
    print("\n=== Eventual Consistency Operations ===")
    for op in operations:
        eventual_model.execute_operation(op)
        value = eventual_model.read(op.key)
        print(f"Operation {op.id}: wrote '{op.value}', local read: '{value}'")
    
    # 等待gossip传播
    print("\n=== Waiting for Gossip Propagation ===")
    time.sleep(3.0)
    
    # 检查所有副本状态
    print("\n=== Final State Across All Replicas ===")
    for replica_id in eventual_model.replicas:
        value = eventual_model.read('user_data', replica_id)
        print(f"Replica {replica_id}: {value}")

if __name__ == "__main__":
    demo_weak_consistency()
```

这个Consistency Models学习文档涵盖了：

1. **基本概念**：一致性模型的定义、分类和谱系
2. **强一致性**：Linearizability、Sequential Consistency
3. **弱一致性**：基础弱一致性模型
4. **最终一致性**：Eventual Consistency with vector clocks
5. **Python实现**：完整的一致性模型代码实现
6. **实际演示**：不同一致性模型的行为对比

文档提供了从理论到实践的完整学习路径，帮助理解分布式系统中不同一致性模型的原理、应用场景和权衡取舍。