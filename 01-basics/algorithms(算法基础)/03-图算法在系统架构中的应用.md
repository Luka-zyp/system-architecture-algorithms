# 图算法在系统架构中的应用

## 概述

图算法在分布式系统、网络路由、社交网络、推荐系统等领域有着广泛的应用。理解和应用图算法对于构建高效、可扩展的系统架构至关重要。

## 核心图算法

### 最短路径算法

#### Dijkstra算法 - 网络路由

```python
import heapq
from typing import Dict, List, Tuple
import networkx as nx

class NetworkRouter:
    """网络路由优化器 - 使用Dijkstra算法"""
    
    def __init__(self):
        self.graph = nx.Graph()
        self.routing_table = {}
    
    def add_network_node(self, node_id: str, latency: float = 0):
        """添加网络节点"""
        self.graph.add_node(node_id, latency=latency)
    
    def add_network_link(self, node1: str, node2: str, bandwidth: float, latency: float):
        """添加网络连接"""
        # 权重使用延迟/带宽的比率
        weight = latency / bandwidth
        self.graph.add_edge(node1, node2, weight=weight, bandwidth=bandwidth, latency=latency)
    
    def find_shortest_path(self, source: str, destination: str) -> Tuple[List[str], float]:
        """使用Dijkstra算法找到最短路径"""
        distances = {node: float('inf') for node in self.graph.nodes()}
        distances[source] = 0
        previous = {}
        pq = [(0, source)]
        visited = set()
        
        while pq:
            current_distance, current_node = heapq.heappop(pq)
            
            if current_node in visited:
                continue
                
            visited.add(current_node)
            
            if current_node == destination:
                break
            
            for neighbor in self.graph.neighbors(current_node):
                if neighbor not in visited:
                    edge_weight = self.graph[current_node][neighbor]['weight']
                    new_distance = current_distance + edge_weight
                    
                    if new_distance < distances[neighbor]:
                        distances[neighbor] = new_distance
                        previous[neighbor] = current_node
                        heapq.heappush(pq, (new_distance, neighbor))
        
        # 重建路径
        path = []
        current = destination
        while current is not None:
            path.append(current)
            current = previous.get(current)
        path.reverse()
        
        return path, distances[destination]
    
    def optimize_routing_table(self):
        """优化整个网络的路由表"""
        all_nodes = list(self.graph.nodes())
        
        for source in all_nodes:
            self.routing_table[source] = {}
            for destination in all_nodes:
                if source != destination:
                    path, cost = self.find_shortest_path(source, destination)
                    if path:
                        self.routing_table[source][destination] = {
                            'next_hop': path[1] if len(path) > 1 else destination,
                            'path': path,
                            'cost': cost
                        }

# 实际应用示例
def setup_distributed_network():
    """设置分布式网络架构"""
    router = NetworkRouter()
    
    # 添加数据中心节点
    datacenters = ['dc-us-east', 'dc-us-west', 'dc-eu', 'dc-asia']
    for dc in datacenters:
        router.add_network_node(dc)
    
    # 添加网络连接
    connections = [
        ('dc-us-east', 'dc-us-west', 1000, 50),  # 带宽1000Mbps, 延迟50ms
        ('dc-us-east', 'dc-eu', 500, 100),
        ('dc-us-east', 'dc-asia', 200, 200),
        ('dc-us-west', 'dc-asia', 800, 150),
        ('dc-eu', 'dc-asia', 600, 180)
    ]
    
    for node1, node2, bandwidth, latency in connections:
        router.add_network_link(node1, node2, bandwidth, latency)
    
    # 优化路由表
    router.optimize_routing_table()
    
    return router

# 使用示例
network = setup_distributed_network()
path, cost = network.find_shortest_path('dc-us-east', 'dc-asia')
print(f"从dc-us-east到dc-asia的最优路径: {' -> '.join(path)}")
print(f"总成本: {cost}")
```

#### Floyd-Warshall算法 - 全源最短路径

```python
class GlobalNetworkOptimizer:
    """全局网络优化器 - 使用Floyd-Warshall算法"""
    
    def __init__(self, num_nodes: int):
        self.num_nodes = num_nodes
        self.distances = [[float('inf')] * num_nodes for _ in range(num_nodes)]
        self.next_hop = [[None] * num_nodes for _ in range(num_nodes)]
    
    def initialize_graph(self, node_ids: List[str]):
        """初始化图"""
        self.node_ids = node_ids
        self.node_index = {node_id: i for i, node_id in enumerate(node_ids)}
        
        # 初始化对角线为0
        for i in range(self.num_nodes):
            self.distances[i][i] = 0
            self.next_hop[i][i] = i
    
    def add_edge(self, node1: str, node2: str, weight: float):
        """添加边"""
        i, j = self.node_index[node1], self.node_index[node2]
        self.distances[i][j] = weight
        self.distances[j][i] = weight
        self.next_hop[i][j] = j
        self.next_hop[j][i] = i
    
    def floyd_warshall(self):
        """Floyd-Warshall算法实现"""
        for k in range(self.num_nodes):
            for i in range(self.num_nodes):
                for j in range(self.num_nodes):
                    if self.distances[i][k] + self.distances[k][j] < self.distances[i][j]:
                        self.distances[i][j] = self.distances[i][k] + self.distances[k][j]
                        self.next_hop[i][j] = self.next_hop[i][k]
    
    def get_path(self, source: str, destination: str) -> List[str]:
        """获取路径"""
        if source not in self.node_index or destination not in self.node_index:
            return []
        
        source_idx = self.node_index[source]
        dest_idx = self.node_index[destination]
        
        if self.next_hop[source_idx][dest_idx] is None:
            return []
        
        path = [source]
        current = source
        
        while current != destination:
            current_idx = self.node_index[current]
            next_idx = self.next_hop[current_idx][dest_idx]
            if next_idx is None:
                break
            current = self.node_ids[next_idx]
            path.append(current)
        
        return path
```

### 图遍历算法

#### BFS - 社交网络分析

```python
from collections import deque
import networkx as nx

class SocialNetworkAnalyzer:
    """社交网络分析器"""
    
    def __init__(self):
        self.graph = nx.Graph()
        self.user_profiles = {}
    
    def add_user(self, user_id: str, profile: Dict):
        """添加用户"""
        self.graph.add_node(user_id)
        self.user_profiles[user_id] = profile
    
    def add_friendship(self, user1: str, user2: str, strength: float = 1.0):
        """添加好友关系"""
        self.graph.add_edge(user1, user2, weight=strength)
    
    def find_mutual_friends(self, user1: str, user2: str) -> List[str]:
        """找到两个用户的共同好友"""
        if user1 not in self.graph or user2 not in self.graph:
            return []
        
        friends1 = set(self.graph.neighbors(user1))
        friends2 = set(self.graph.neighbors(user2))
        mutual_friends = friends1.intersection(friends2)
        
        return list(mutual_friends)
    
    def recommend_friends(self, user: str, max_recommendations: int = 5) -> List[Tuple[str, float]]:
        """好友推荐算法"""
        if user not in self.graph:
            return []
        
        # 获取二度好友（朋友的朋友）
        friends = set(self.graph.neighbors(user))
        recommendations = {}
        
        for friend in friends:
            for friend_of_friend in self.graph.neighbors(friend):
                if friend_of_friend != user and friend_of_friend not in friends:
                    # 计算推荐分数
                    common_friends = len(friends.intersection(set(self.graph.neighbors(friend_of_friend))))
                    connection_strength = self.graph[user][friend]['weight']
                    recommendation_score = common_friends * connection_strength
                    
                    if friend_of_friend not in recommendations:
                        recommendations[friend_of_friend] = 0
                    recommendations[friend_of_friend] += recommendation_score
        
        # 排序并返回top推荐
        sorted_recommendations = sorted(recommendations.items(), 
                                      key=lambda x: x[1], reverse=True)
        return sorted_recommendations[:max_recommendations]
    
    def find_influencers(self, min_degree: int = 10) -> List[str]:
        """识别影响者（高连接度用户）"""
        influencers = []
        
        for node in self.graph.nodes():
            degree = self.graph.degree(node)
            if degree >= min_degree:
                influencers.append((node, degree))
        
        # 按度排序
        influencers.sort(key=lambda x: x[1], reverse=True)
        return influencers
```

#### DFS - 依赖关系解析

```python
class DependencyResolver:
    """依赖关系解析器 - 使用DFS"""
    
    def __init__(self):
        self.dependencies = {}
        self.resolved = set()
        self.resolving = set()
        self.cycles = []
    
    def add_dependency(self, component: str, depends_on: List[str]):
        """添加依赖关系"""
        self.dependencies[component] = depends_on
    
    def resolve_dependencies(self, component: str) -> List[str]:
        """解析单个组件的依赖"""
        if component in self.resolved:
            return []
        
        if component in self.resolving:
            # 检测到循环依赖
            self.cycles.append(component)
            return []
        
        self.resolving.add(component)
        resolved_deps = []
        
        for dep in self.dependencies.get(component, []):
            dep_deps = self.resolve_dependencies(dep)
            resolved_deps.extend(dep_deps)
            if dep not in self.resolved:
                self.resolved.add(dep)
        
        self.resolving.remove(component)
        return resolved_deps
    
    def get_build_order(self, components: List[str]) -> List[str]:
        """获取构建顺序"""
        build_order = []
        
        for component in components:
            if component not in self.resolved:
                deps = self.resolve_dependencies(component)
                build_order.extend(deps)
                if component not in self.resolved:
                    self.resolved.add(component)
                build_order.append(component)
        
        return build_order
    
    def detect_cycles(self) -> List[List[str]]:
        """检测循环依赖"""
        self.cycles = []
        
        for component in self.dependencies:
            self.resolve_dependencies(component)
        
        return self.cycles

# 微服务依赖解析示例
def setup_microservice_dependencies():
    """设置微服务依赖关系"""
    resolver = DependencyResolver()
    
    # 添加微服务依赖
    dependencies = {
        'api-gateway': ['auth-service', 'user-service'],
        'user-service': ['database-service', 'notification-service'],
        'auth-service': ['database-service'],
        'order-service': ['inventory-service', 'payment-service', 'auth-service'],
        'inventory-service': ['database-service'],
        'payment-service': ['database-service', 'notification-service'],
        'notification-service': ['email-service', 'sms-service'],
        'database-service': [],
        'email-service': [],
        'sms-service': []
    }
    
    for service, deps in dependencies.items():
        resolver.add_dependency(service, deps)
    
    return resolver

# 使用示例
resolver = setup_microservice_dependencies()
build_order = resolver.get_build_order(list(resolver.dependencies.keys()))
cycles = resolver.detect_cycles()

print("构建顺序:", ' -> '.join(build_order))
if cycles:
    print("检测到循环依赖:", cycles)
```

### 最小生成树（MST）

#### Kruskal算法 - 网络拓扑优化

```python
class NetworkTopologyOptimizer:
    """网络拓扑优化器 - 使用Kruskal算法"""
    
    def __init__(self):
        self.edges = []
        self.nodes = set()
        self.parent = {}
        self.rank = {}
    
    def add_node(self, node: str):
        """添加节点"""
        self.nodes.add(node)
        self.parent[node] = node
        self.rank[node] = 0
    
    def add_link(self, node1: str, node2: str, cost: float):
        """添加网络连接"""
        self.edges.append((cost, node1, node2))
    
    def find(self, node: str) -> str:
        """并查集查找"""
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]
    
    def union(self, node1: str, node2: str):
        """并查集合并"""
        root1 = self.find(node1)
        root2 = self.find(node2)
        
        if root1 != root2:
            if self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
            elif self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            else:
                self.parent[root2] = root1
                self.rank[root1] += 1
    
    def kruskal_mst(self) -> List[Tuple[float, str, str]]:
        """Kruskal算法求最小生成树"""
        # 按权重排序
        self.edges.sort()
        mst = []
        edge_count = 0
        total_cost = 0
        
        for cost, node1, node2 in self.edges:
            if self.find(node1) != self.find(node2):
                self.union(node1, node2)
                mst.append((cost, node1, node2))
                total_cost += cost
                edge_count += 1
                
                if edge_count == len(self.nodes) - 1:
                    break
        
        return mst, total_cost
    
    def optimize_network_topology(self) -> Dict:
        """优化网络拓扑"""
        mst, total_cost = self.kruskal_mst()
        
        return {
            'optimal_topology': mst,
            'total_cost': total_cost,
            'cost_savings': self.calculate_cost_savings(mst),
            'reliability_analysis': self.analyze_reliability(mst)
        }
    
    def calculate_cost_savings(self, mst: List[Tuple[float, str, str]]) -> float:
        """计算成本节省"""
        original_cost = sum(cost for cost, _, _ in self.edges)
        mst_cost = sum(cost for cost, _, _ in mst)
        return ((original_cost - mst_cost) / original_cost) * 100
    
    def analyze_reliability(self, mst: List[Tuple[float, str, str]]) -> Dict:
        """分析可靠性"""
        # 分析关键节点和链路
        node_usage = {}
        for _, node1, node2 in mst:
            node_usage[node1] = node_usage.get(node1, 0) + 1
            node_usage[node2] = node_usage.get(node2, 0) + 1
        
        critical_nodes = [node for node, count in node_usage.items() if count > 2]
        
        return {
            'critical_nodes': critical_nodes,
            'redundancy_level': 'low',  # MST本身冗余度较低
            'failure_impact': 'high' if critical_nodes else 'medium'
        }
```

### 拓扑排序

#### 任务调度优化

```python
from collections import defaultdict, deque

class TaskScheduler:
    """任务调度器 - 使用拓扑排序"""
    
    def __init__(self):
        self.graph = defaultdict(list)
        self.in_degree = defaultdict(int)
        self.tasks = {}
    
    def add_task(self, task_id: str, duration: int, resource_requirements: List[str] = None):
        """添加任务"""
        self.tasks[task_id] = {
            'duration': duration,
            'resources': resource_requirements or [],
            'status': 'pending'
        }
        if task_id not in self.in_degree:
            self.in_degree[task_id] = 0
    
    def add_dependency(self, task: str, depends_on: str):
        """添加任务依赖"""
        self.graph[depends_on].append(task)
        self.in_degree[task] += 1
    
    def topological_sort(self) -> List[str]:
        """拓扑排序"""
        # 初始化队列
        queue = deque([task for task in self.tasks if self.in_degree[task] == 0])
        result = []
        
        while queue:
            current_task = queue.popleft()
            result.append(current_task)
            
            # 更新依赖任务的入度
            for dependent_task in self.graph[current_task]:
                self.in_degree[dependent_task] -= 1
                if self.in_degree[dependent_task] == 0:
                    queue.append(dependent_task)
        
        return result
    
    def schedule_tasks(self, max_parallel_tasks: int = 3) -> Dict:
        """调度任务"""
        topological_order = self.topological_sort()
        
        if len(topological_order) != len(self.tasks):
            return {'error': '存在循环依赖，无法调度'}
        
        # 按时间槽安排任务
        schedule = defaultdict(list)
        current_time = 0
        task_start_times = {}
        
        for task in topological_order:
            # 检查资源可用性
            available_resources = self.check_resource_availability(task, current_time, max_parallel_tasks)
            
            if available_resources:
                task_start_times[task] = current_time
                schedule[current_time].append(task)
                
                # 更新时间
                end_time = current_time + self.tasks[task]['duration']
                self.update_resource_usage(task, current_time, end_time)
                
                # 寻找下一个可用时间
                current_time = self.find_next_available_time(current_time + 1)
            else:
                current_time += 1
        
        # 计算关键路径
        critical_path = self.calculate_critical_path(topological_order)
        
        return {
            'schedule': dict(schedule),
            'task_start_times': task_start_times,
            'total_duration': max(task_start_times.values()) + max(self.tasks[t]['duration'] for t in self.tasks),
            'critical_path': critical_path
        }
    
    def check_resource_availability(self, task: str, start_time: int, max_parallel: int) -> bool:
        """检查资源可用性"""
        # 简化的资源检查逻辑
        concurrent_tasks = len([t for t, start in task_start_times.items() 
                              if start <= start_time < start + self.tasks[t]['duration']])
        return concurrent_tasks < max_parallel
    
    def calculate_critical_path(self, topological_order: List[str]) -> List[str]:
        """计算关键路径"""
        # 简化的关键路径计算
        earliest_start = {}
        
        for task in topological_order:
            if not self.graph[task]:  # 没有依赖的任务
                earliest_start[task] = 0
            else:
                earliest_start[task] = max(
                    earliest_start[dep] + self.tasks[dep]['duration']
                    for dep in self.tasks if task in self.graph[dep]
                )
        
        # 找到最长的路径
        total_durations = {task: earliest_start[task] + self.tasks[task]['duration'] 
                          for task in topological_order}
        critical_path = [task for task in topological_order 
                        if total_durations[task] == max(total_durations.values())]
        
        return critical_path
```

## 图算法在分布式系统中的应用

### 一致性哈希

```python
import hashlib
from bisect import bisect_left

class ConsistentHash:
    """一致性哈希实现"""
    
    def __init__(self, nodes: List[str], virtual_nodes: int = 150):
        self.virtual_nodes = virtual_nodes
        self.ring = {}
        self.sorted_keys = []
        
        for node in nodes:
            self.add_node(node)
    
    def _hash(self, key: str) -> int:
        """计算哈希值"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node: str):
        """添加节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            self.ring[hash_value] = node
        
        self.sorted_keys = sorted(self.ring.keys())
    
    def remove_node(self, node: str):
        """移除节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            hash_value = self._hash(virtual_key)
            if hash_value in self.ring:
                del self.ring[hash_value]
        
        self.sorted_keys = sorted(self.ring.keys())
    
    def get_node(self, key: str) -> str:
        """获取key对应的节点"""
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        
        # 找到第一个大于等于hash_value的节点
        index = bisect_left(self.sorted_keys, hash_value)
        if index == len(self.sorted_keys):
            index = 0  # 环形结构，回到第一个节点
        
        return self.ring[self.sorted_keys[index]]
    
    def get_nodes(self, key: str, count: int) -> List[str]:
        """获取多个节点用于副本"""
        if not self.ring or count <= 0:
            return []
        
        hash_value = self._hash(key)
        index = bisect_left(self.sorted_keys, hash_value)
        
        nodes = []
        for i in range(count):
            ring_index = (index + i) % len(self.sorted_keys)
            node = self.ring[self.sorted_keys[ring_index]]
            if node not in nodes:
                nodes.append(node)
        
        return nodes
```

## 总结

图算法在系统架构中有着广泛的应用，从网络路由优化到分布式系统的节点管理，从任务调度到社交网络分析。理解和应用这些算法对于构建高效、可扩展的系统至关重要。

### 关键应用场景

1. **网络路由优化**：使用最短路径算法优化数据传输路径
2. **分布式负载均衡**：利用一致性哈希进行数据分片和负载分配
3. **依赖关系管理**：通过拓扑排序解决服务依赖和任务调度
4. **社交网络分析**：使用图遍历算法进行好友推荐和影响力分析
5. **网络拓扑优化**：应用最小生成树算法优化网络成本

### 性能考虑

1. **时间复杂度**：根据应用场景选择合适的算法
2. **空间复杂度**：考虑大规模图结构的存储和内存使用
3. **实时性要求**：在线算法vs离线算法的权衡
4. **可扩展性**：分布式图计算的处理策略

通过合理应用图算法，可以显著提升系统的性能、可靠性和可扩展性。