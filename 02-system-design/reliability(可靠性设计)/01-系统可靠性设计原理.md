# 系统可靠性设计原理

## 概述

可靠性是软件系统最重要的非功能性需求之一，它确保系统在各种异常情况下仍能正常提供服务。深入理解可靠性设计的原理和方法，是构建生产级系统的核心技能。

## 可靠性的本质与定义

### 可靠性的基本概念

**可靠性（Reliability）**：
- 系统在给定时间间隔内和规定条件下执行其所需功能的能力
- 衡量系统无故障运行的能力
- 直接影响用户体验和业务连续性

**可用性（Availability）**：
- 系统在给定时间内处于可操作状态的比例
- 公式：可用性 = 正常运行时间 / (正常运行时间 + 故障时间)
- 常用指标：99.9%、99.99%、99.999%

**容错性（Fault Tolerance）**：
- 系统在发生故障时仍能继续提供服务的能力
- 包括硬件容错、软件容错、网络容错等

**恢复性（Resilience）**：
- 系统从故障状态中快速恢复的能力
- 包括自动恢复、人工恢复、渐进式恢复等

### 可靠性度量指标

**故障率（Failure Rate）**：
- 单位时间内发生故障的概率
- 通常用λ（lambda）表示
- 单位：次/小时、次/天

**平均故障间隔时间（MTBF）**：
- Mean Time Between Failures
- 两次故障之间的平均时间间隔
- 公式：MTBF = 总运行时间 / 故障次数

**平均修复时间（MTTR）**：
- Mean Time To Repair
- 从故障发生到修复完成的平均时间
- 包括故障检测、定位、修复时间

**可用性计算**：
- 可用性 = MTBF / (MTBF + MTTR)
- 99.9%可用性：年故障时间约8.76小时
- 99.99%可用性：年故障时间约52.6分钟
- 99.999%可用性：年故障时间约5.26分钟

## 容错设计原理

### 冗余设计

**硬件冗余**：
```java
// 硬件冗余示例：数据库主从复制
@Configuration
public class DatabaseReplicationConfig {
    
    @Primary
    @Bean("masterDataSource")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://master-db:3306/app")
            .build();
    }
    
    @Bean("slaveDataSource")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:mysql://slave-db:3306/app")
            .build();
    }
    
    @Bean
    public DataSource replicatedDataSource() {
        return new ReplicatedDataSource(
            masterDataSource(),
            List.of(slaveDataSource())
        );
    }
}

public class ReplicatedDataSource implements DataSource {
    
    private final DataSource masterDataSource;
    private final List<DataSource> slaveDataSources;
    private final AtomicReference<DataSource> currentMaster = new AtomicReference<>();
    
    public ReplicatedDataSource(DataSource master, List<DataSource> slaves) {
        this.masterDataSource = master;
        this.slaveDataSources = slaves;
        this.currentMaster.set(master);
        
        // 启动健康检查
        startHealthCheck();
    }
    
    private void startHealthCheck() {
        ScheduledExecutorService executor = 
            Executors.newSingleThreadScheduledExecutor();
        
        executor.scheduleWithFixedDelay(() -> {
            // 检查主库状态
            if (!isHealthy(masterDataSource)) {
                // 主库故障，切换到备库
                DataSource newMaster = selectNewMaster();
                if (newMaster != null) {
                    currentMaster.set(newMaster);
                    log.warn("主库故障，已切换到备库: {}", newMaster);
                }
            }
        }, 30, 30, TimeUnit.SECONDS);
    }
}
```

**软件冗余**：
```python
# 软件冗余示例：多实例部署
import threading
import logging
from typing import List, Optional

# 设置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ServiceInstanceManager:
    def __init__(self):
        self._instances = []
        self._round_robin_counter = 0
        self._lock = threading.RLock()
    
    def register_instance(self, instance):
        """注册服务实例"""
        with self._lock:
            self._instances.append(instance)
            logger.info(f"注册服务实例: {instance.get_id()}")
    
    def unregister_instance(self, instance_id):
        """注销服务实例"""
        with self._lock:
            self._instances = [inst for inst in self._instances 
                             if inst.get_id() != instance_id]
            logger.info(f"注销服务实例: {instance_id}")
    
    def select_instance(self, strategy):
        """选择健康的服务实例"""
        with self._lock:
            healthy_instances = [inst for inst in self._instances 
                               if inst.is_healthy()]
            
        if not healthy_instances:
            raise RuntimeError("没有可用的服务实例")
        
        with self._lock:
            selected = strategy.select(healthy_instances, self._round_robin_counter)
            self._round_robin_counter = (self._round_robin_counter + 1) % len(healthy_instances)
        
        return selected
    
    def mark_instance_unhealthy(self, instance_id, cause):
        """标记实例为不健康状态"""
        with self._lock:
            for instance in self._instances:
                if instance.get_id() == instance_id:
                    instance.mark_unhealthy(cause)
                    logger.warning(f"标记实例不健康: {instance_id}, 原因: {str(cause)}")
                    break


# 简单的服务实例类示例
class ServiceInstance:
    def __init__(self, instance_id, host, port):
        self._instance_id = instance_id
        self._host = host
        self._port = port
        self._healthy = True
    
    def get_id(self):
        return self._instance_id
    
    def is_healthy(self):
        return self._healthy
    
    def mark_unhealthy(self, cause):
        self._healthy = False
```
```

### 故障检测机制

**健康检查设计**：
```python
# 健康检查结果类
class HealthStatus:
    def __init__(self, is_healthy, message=""):
        self.is_healthy = is_healthy
        self.message = message
    
    @classmethod
    def healthy(cls):
        return cls(True, "健康")
    
    @classmethod
    def unhealthy(cls, message):
        return cls(False, message)

# 健康检查接口设计
class HealthChecker:
    def check(self):
        pass
    
    def is_critical(self):
        pass
    
    def get_check_interval(self):
        pass

class DatabaseHealthChecker(HealthChecker):
    
    def __init__(self, data_source):
        self.data_source = data_source
    
    def check(self):
        try:
            # 模拟数据库连接和查询
            conn = self.data_source.get_connection()
            stmt = conn.create_statement()
            rs = stmt.execute_query("SELECT 1")
            
            if rs.next() and rs.get_int(1) == 1:
                return HealthStatus.healthy()
            else:
                return HealthStatus.unhealthy("数据库响应异常")
        except Exception as e:
            return HealthStatus.unhealthy(f"数据库连接失败: {e}")
    
    def is_critical(self):
        return True
    
    def get_check_interval(self):
        return 30  # 30秒

# 复合健康检查
class CompositeHealthChecker(HealthChecker):
    def __init__(self):
        self.checkers = []
    
    def add_checker(self, checker):
        self.checkers.append(checker)
    
    def check(self):
        results = []
        for checker in self.checkers:
            result = checker.check()
            results.append((checker.__class__.__name__, result))
            if not result.is_healthy and checker.is_critical():
                return result
        return HealthStatus.healthy()
    
    def is_critical(self):
        return any(checker.is_critical() for checker in self.checkers)
    
    def get_check_interval(self):
        return min(checker.get_check_interval() for checker in self.checkers) if self.checkers else 30
```
}
```

**心跳检测机制**：
```java
// 心跳检测实现
@Component
public class HeartbeatManager {
    
    private final Map<String, HeartbeatRecord> heartbeatRecords = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = 
        Executors.newSingleThreadScheduledExecutor();
    
    public void registerService(String serviceId, HeartbeatConfig config) {
        HeartbeatRecord record = new HeartbeatRecord(serviceId, config);
        heartbeatRecords.put(serviceId, record);
        
        // 启动心跳检测
        scheduler.scheduleWithFixedDelay(() -> {
            checkHeartbeat(serviceId);
        }, 0, config.getCheckInterval().toMillis(), TimeUnit.MILLISECONDS);
        
        log.info("注册服务心跳检测: {}", serviceId);
    }
    
    private void checkHeartbeat(String serviceId) {
        HeartbeatRecord record = heartbeatRecords.get(serviceId);
        if (record == null) return;
        
        long now = System.currentTimeMillis();
        long lastHeartbeat = record.getLastHeartbeatTime();
        
        // 检查心跳超时
        if (now - lastHeartbeat > record.getConfig().getTimeout().toMillis()) {
            handleHeartbeatTimeout(serviceId);
        }
    }
    
    private void handleHeartbeatTimeout(String serviceId) {
        HeartbeatRecord record = heartbeatRecords.get(serviceId);
        int currentFailures = record.incrementFailures();
        
        if (currentFailures >= record.getConfig().getMaxFailures()) {
            // 心跳失败次数过多，标记服务不健康
            markServiceUnhealthy(serviceId, "心跳超时");
        } else {
            log.warn("心跳检测失败: {}, 失败次数: {}", serviceId, currentFailures);
        }
    }
    
    public void recordHeartbeat(String serviceId) {
        HeartbeatRecord record = heartbeatRecords.get(serviceId);
        if (record != null) {
            record.updateHeartbeatTime();
            record.resetFailures();
        }
    }
    
    private void markServiceUnhealthy(String serviceId, String reason) {
        HeartbeatRecord record = heartbeatRecords.get(serviceId);
        if (record != null) {
            record.markUnhealthy(reason);
            log.error("服务心跳超时，标记不健康: {}, 原因: {}", serviceId, reason);
            
            // 触发故障处理
            handleServiceFailure(serviceId, reason);
        }
    }
    
    private void handleServiceFailure(String serviceId, String reason) {
        // 触发服务故障处理逻辑
        // 可以包括：负载均衡移除、告警通知、故障转移等
        eventPublisher.publishEvent(new ServiceFailureEvent(serviceId, reason));
    }
}
```

### 故障隔离与降级

**熔断器模式**：
```java
// 熔断器实现
import enum
import time
import logging
import threading

# 设置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class CircuitBreaker:
    """熔断器实现"""
    
    class State(enum.Enum):
        CLOSED = "closed"    # 正常状态
        OPEN = "open"       # 熔断状态
        HALF_OPEN = "half_open"  # 半开状态
    
    def __init__(self, config):
        self._state = self.State.CLOSED
        self.config = config
        self._failure_count = 0
        self._success_count = 0
        self._last_failure_time = 0
        self._lock = threading.Lock()
    
    def execute(self, supplier):
        """执行受熔断器保护的操作"""
        with self._lock:
            current_state = self._state
        
        if current_state == self.State.CLOSED:
            return self._execute_closed(supplier)
        elif current_state == self.State.OPEN:
            return self._execute_open(supplier)
        elif current_state == self.State.HALF_OPEN:
            return self._execute_half_open(supplier)
        else:
            raise ValueError("未知状态")
    
    def _execute_closed(self, supplier):
        """关闭状态下的执行逻辑"""
        try:
            result = supplier()
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise e
    
    def _execute_open(self, supplier):
        """熔断状态下的执行逻辑"""
        with self._lock:
            time_since_last_failure = time.time() - self._last_failure_time
        
        if time_since_last_failure >= self.config.timeout:
            # 尝试切换到半开状态
            with self._lock:
                if self._state == self.State.OPEN:
                    self._state = self.State.HALF_OPEN
            return self._execute_half_open(supplier)
        
        raise RuntimeError("熔断器处于开启状态")
    
    def _execute_half_open(self, supplier):
        """半开状态下的执行逻辑"""
        try:
            result = supplier()
            self._on_half_open_success()
            return result
        except Exception as e:
            self._on_half_open_failure()
            raise e
    
    def _on_success(self):
        """执行成功时的处理"""
        with self._lock:
            self._failure_count = 0
            self._success_count += 1
    
    def _on_failure(self):
        """执行失败时的处理"""
        with self._lock:
            self._failure_count += 1
            self._last_failure_time = time.time()
            
            if self._failure_count >= self.config.failure_threshold:
                self._state = self.State.OPEN
                logger.warning("熔断器开启，失败次数: %d", self._failure_count)
    
    def _on_half_open_success(self):
        """半开状态执行成功时的处理"""
        with self._lock:
            self._state = self.State.CLOSED
            self._success_count = 0
            self._failure_count = 0
            logger.info("熔断器恢复，切换到关闭状态")
    
    def _on_half_open_failure(self):
        """半开状态执行失败时的处理"""
        with self._lock:
            self._state = self.State.OPEN
            self._last_failure_time = time.time()
            logger.warning("半开状态测试失败，重新开启熔断器")


# 熔断器配置
class CircuitBreakerConfig:
    """熔断器配置类"""
    
    def __init__(self, timeout=60, failure_threshold=5, 
                 monitoring_period=60, success_threshold=3):
        self.timeout = timeout  # 熔断器开启后的超时时间（秒）
        self.failure_threshold = failure_threshold  # 失败阈值
        self.monitoring_period = monitoring_period  # 监控周期（秒）
        self.success_threshold = success_threshold  # 半开状态成功阈值
    
    @classmethod
    def default_config(cls):
        """获取默认配置"""
        return cls(
            timeout=60,
            failure_threshold=5,
            monitoring_period=60,
            success_threshold=3
        )
```

**舱壁隔离模式**：
```java
// 线程池隔离
@Configuration
public class ThreadPoolIsolationConfig {
    
    @Bean("criticalServiceExecutor")
    public ThreadPoolTaskExecutor criticalServiceExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(100);
        executor.setKeepAliveSeconds(60);
        executor.setThreadNamePrefix("Critical-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());
        return executor;
    }
    
    @Bean("normalServiceExecutor")
    public ThreadPoolTaskExecutor normalServiceExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(50);
        executor.setKeepAliveSeconds(30);
        executor.setThreadNamePrefix("Normal-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        return executor;
    }
    
    @Bean("batchServiceExecutor")
    public ThreadPoolTaskExecutor batchServiceExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(4);
        executor.setQueueCapacity(1000);
        executor.setKeepAliveSeconds(300);
        executor.setThreadNamePrefix("Batch-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());
        return executor;
    }
}

// 服务隔离示例
@Service
public class IsolatedOrderService {
    
    private final OrderRepository orderRepository;
    private final EmailService emailService;
    private final NotificationService notificationService;
    
    // 使用独立的线程池处理订单创建
    @Async("criticalServiceExecutor")
    public CompletableFuture<Order> createOrder(OrderCreateRequest request) {
        try {
            // 核心业务逻辑
            Order order = processOrderCreation(request);
            
            // 非核心功能使用不同线程池异步处理
            @Async("normalServiceExecutor")
            CompletableFuture<Void> sendEmail = emailService.sendOrderConfirmation(order);
            
            @Async("batchServiceExecutor")  
            CompletableFuture<Void> sendNotification = notificationService.sendOrderNotification(order);
            
            return CompletableFuture.completedFuture(order);
        } catch (Exception e) {
            log.error("订单创建失败: {}", request, e);
            return CompletableFuture.failedFuture(e);
        }
    }
}
```

**服务降级策略**：
```java
// 降级策略配置
@Component
public class DegradationStrategy {
    
    private final Map<String, DegradationConfig> strategies = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // 初始化降级策略
        strategies.put("userService", DegradationConfig.builder()
            .primaryStrategy("getUserFromDB")
            .fallbackStrategy("getUserFromCache")
            .circuitBreakerEnabled(true)
            .timeout(Duration.ofMillis(500))
            .build());
            
        strategies.put("paymentService", DegradationConfig.builder()
            .primaryStrategy("processPaymentOnline")
            .fallbackStrategy("queuePaymentForLater")
            .circuitBreakerEnabled(true)
            .timeout(Duration.ofMillis(2000))
            .build());
    }
    
    public <T> T executeWithDegradation(String service, 
                                       Supplier<T> primarySupplier,
                                       Supplier<T> fallbackSupplier) {
        
        DegradationConfig config = strategies.get(service);
        if (config == null) {
            throw new IllegalArgumentException("未找到降级配置: " + service);
        }
        
        // 创建熔断器
        CircuitBreaker circuitBreaker = new CircuitBreaker(config.getCircuitBreakerConfig());
        
        try {
            // 尝试主要策略
            return circuitBreaker.execute(() -> {
                TimeoutExecutor executor = TimeoutExecutor.withTimeout(config.getTimeout());
                return executor.execute(primarySupplier);
            });
        } catch (Exception e) {
            log.warn("主要策略失败，启用降级策略: {}", service, e);
            
            try {
                // 执行降级策略
                return fallbackSupplier.get();
            } catch (Exception fallbackException) {
                log.error("降级策略也失败: {}", service, fallbackException);
                throw new ServiceDegradationException("服务降级失败", fallbackException);
            }
        }
    }
}

// 降级策略注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface DegradedService {
    
    String serviceName();
    
    Class<? extends Supplier> fallbackClass();
    
    boolean enableCircuitBreaker() default true;
    
    Duration timeout() default Duration.ofMillis(1000);
}

// 降级服务切面
@Component
@Aspect
public class DegradationAspect {
    
    @Around("@annotation(degradedService)")
    public Object handleDegradation(ProceedingJoinPoint joinPoint, 
                                   DegradedService degradedService) throws Throwable {
        
        String serviceName = degradedService.serviceName();
        
        // 创建降级处理器
        DegradationHandler handler = createHandler(degradedService);
        
        return handler.handle(joinPoint);
    }
    
    private DegradationHandler createHandler(DegradedService config) {
        return DegradationHandler.builder()
            .serviceName(config.serviceName())
            .fallbackClass(config.fallbackClass())
            .enableCircuitBreaker(config.enableCircuitBreaker())
            .timeout(config.timeout())
            .build();
    }
}

// 使用示例
@Service
public class UserService {
    
    @DegradedService(
        serviceName = "userService",
        fallbackClass = UserServiceFallback.class,
        timeout = @Duration(millis = 500)
    )
    public User getUserById(Long userId) {
        // 主要服务逻辑
        return userRepository.findById(userId)
            .orElseThrow(() -> new UserNotFoundException(userId));
    }
}

// 降级实现类
@Component
public class UserServiceFallback implements Supplier<User> {
    
    @Override
    public User get() {
        // 降级策略：从缓存获取默认用户
        return getDefaultUser();
    }
    
    private User getDefaultUser() {
        // 返回默认用户或匿名用户
        return User.createDefaultUser();
    }
}
```

## 故障恢复机制

### 自动故障检测与恢复

**分布式健康检查**：
```java
// 分布式健康检查协调器
@Component
public class DistributedHealthChecker {
    
    private final Map<String, ServiceHealthStatus> serviceStatuses = new ConcurrentHashMap<>();
    private final ConsulClient consulClient;
    private final ScheduledExecutorService scheduler = 
        Executors.newSingleThreadScheduledExecutor();
    
    @PostConstruct
    public void init() {
        // 启动分布式健康检查
        scheduler.scheduleWithFixedDelay(this::performDistributedHealthCheck, 
            0, 30, TimeUnit.SECONDS);
    }
    
    private void performDistributedHealthCheck() {
        try {
            // 1. 获取所有服务实例
            List<ServiceInstance> allInstances = discoverAllInstances();
            
            // 2. 分布式健康检查
            Map<String, HealthCheckResult> healthResults = performHealthChecks(allInstances);
            
            // 3. 共识算法确定最终健康状态
            Map<String, Boolean> consensusHealth = reachConsensus(healthResults);
            
            // 4. 更新服务状态
            updateServiceStatuses(consensusHealth);
            
            // 5. 执行故障恢复操作
            handleUnhealthyServices(consensusHealth);
            
        } catch (Exception e) {
            log.error("分布式健康检查失败", e);
        }
    }
    
    private Map<String, Boolean> reachConsensus(Map<String, HealthCheckResult> healthResults) {
        // 简化的Raft共识算法
        Map<String, Integer> healthyVotes = new HashMap<>();
        Map<String, Integer> totalVotes = new HashMap<>();
        
        for (HealthCheckResult result : healthResults.values()) {
            for (Map.Entry<String, Boolean> entry : result.getServiceHealth().entrySet()) {
                String serviceId = entry.getKey();
                boolean isHealthy = entry.getValue();
                
                totalVotes.merge(serviceId, 1, Integer::sum);
                if (isHealthy) {
                    healthyVotes.merge(serviceId, 1, Integer::sum);
                }
            }
        }
        
        // 多数投票决定
        Map<String, Boolean> consensus = new HashMap<>();
        for (String serviceId : totalVotes.keySet()) {
            int total = totalVotes.get(serviceId);
            int healthy = healthyVotes.getOrDefault(serviceId, 0);
            boolean isConsensusHealthy = healthy > total / 2;
            consensus.put(serviceId, isConsensusHealthy);
        }
        
        return consensus;
    }
    
    private void handleUnhealthyServices(Map<String, Boolean> consensusHealth) {
        for (Map.Entry<String, Boolean> entry : consensusHealth.entrySet()) {
            String serviceId = entry.getKey();
            boolean isHealthy = entry.getValue();
            
            if (!isHealthy) {
                ServiceHealthStatus currentStatus = serviceStatuses.get(serviceId);
                
                if (currentStatus == null || currentStatus.isHealthy()) {
                    // 第一次检测到不健康
                    markServiceUnhealthy(serviceId);
                    triggerFailover(serviceId);
                }
            } else {
                // 服务恢复健康
                ServiceHealthStatus currentStatus = serviceStatuses.get(serviceId);
                if (currentStatus != null && !currentStatus.isHealthy()) {
                    markServiceHealthy(serviceId);
                }
            }
        }
    }
    
    private void triggerFailover(String serviceId) {
        try {
            // 从服务注册中心移除不健康的实例
            deregisterUnhealthyService(serviceId);
            
            // 通知负载均衡器
            notifyLoadBalancer(serviceId);
            
            // 尝试重启服务实例
            restartServiceInstance(serviceId);
            
            log.warn("触发故障转移: {}", serviceId);
        } catch (Exception e) {
            log.error("故障转移失败: {}", serviceId, e);
        }
    }
}
```

### 数据备份与恢复

**数据库备份策略**：
```java
// 数据库备份管理器
@Component
public class DatabaseBackupManager {
    
    private final DataSource dataSource;
    private final FileSystem backupStorage;
    private final ScheduledExecutorService scheduler = 
        Executors.newSingleThreadScheduledExecutor();
    
    @PostConstruct
    public void init() {
        // 启动定时备份
        scheduler.scheduleWithFixedDelay(this::performScheduledBackup, 
            0, 1, TimeUnit.HOURS);
            
        // 启动增量备份
        scheduler.scheduleWithFixedDelay(this::performIncrementalBackup,
            0, 10, TimeUnit.MINUTES);
    }
    
    public void performFullBackup() {
        String backupId = generateBackupId();
        Path backupPath = createBackupPath(backupId);
        
        try (Connection conn = dataSource.getConnection()) {
            // 1. 创建一致性快照
            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
            conn.setAutoCommit(false);
            
            // 2. 备份所有表
            backupTables(conn, backupPath);
            
            // 3. 备份存储过程和触发器
            backupProcedures(conn, backupPath);
            
            // 4. 备份元数据
            backupMetadata(conn, backupPath);
            
            // 5. 验证备份完整性
            validateBackup(backupPath);
            
            // 6. 压缩并加密备份文件
            compressAndEncryptBackup(backupPath);
            
            conn.commit();
            
            // 7. 记录备份元数据
            recordBackupMetadata(backupId, backupPath, BackupType.FULL);
            
            log.info("完整备份完成: {}", backupId);
            
        } catch (Exception e) {
            log.error("完整备份失败: {}", backupId, e);
            throw new BackupException("完整备份失败", e);
        }
    }
    
    private void backupTables(Connection conn, Path backupPath) throws SQLException {
        DatabaseMetaData metaData = conn.getMetaData();
        try (ResultSet tables = metaData.getTables(null, null, "%", new String[]{"TABLE"})) {
            
            while (tables.next()) {
                String tableName = tables.getString("TABLE_NAME");
                backupTable(conn, tableName, backupPath);
            }
        }
    }
    
    private void backupTable(Connection conn, String tableName, Path backupPath) throws SQLException {
        String backupFile = backupPath.resolve(tableName + ".sql").toString();
        
        try (Statement stmt = conn.createStatement();
             FileWriter writer = new FileWriter(backupFile)) {
            
            // 获取表结构
            writeTableSchema(stmt, tableName, writer);
            
            // 获取表数据
            writeTableData(stmt, tableName, writer);
            
            writer.flush();
            
        } catch (IOException e) {
            throw new SQLException("写入备份文件失败: " + backupFile, e);
        }
    }
    
    public void performPointInTimeRecovery(String recoveryTarget) {
        try {
            // 1. 验证恢复点是否有效
            validateRecoveryPoint(recoveryTarget);
            
            // 2. 停止应用写入
            pauseApplicationWrites();
            
            // 3. 恢复到指定时间点
            restoreToPointInTime(recoveryTarget);
            
            // 4. 验证数据一致性
            validateDataIntegrity();
            
            // 5. 验证应用逻辑一致性
            validateApplicationConsistency();
            
            log.info("时间点恢复完成: {}", recoveryTarget);
            
        } catch (Exception e) {
            log.error("时间点恢复失败: {}", recoveryTarget, e);
            throw new RecoveryException("时间点恢复失败", e);
        } finally {
            // 6. 恢复应用写入
            resumeApplicationWrites();
        }
    }
    
    private void restoreToPointInTime(String targetTime) throws SQLException {
        // 执行SQL恢复脚本
        Path recoveryScript = generateRecoveryScript(targetTime);
        
        try (Connection conn = dataSource.getConnection();
             FileReader reader = new FileReader(recoveryScript.toFile());
             ScriptRunner runner = new ScriptRunner(conn)) {
            
            runner.runScript(reader);
            
        } catch (Exception e) {
            throw new SQLException("执行恢复脚本失败", e);
        }
    }
}
```

**配置备份与恢复**：
```java
// 配置管理备份
@Component
public class ConfigurationBackupManager {
    
    private final Map<String, Object> currentConfig = new ConcurrentHashMap<>();
    private final Path backupDirectory;
    
    public void backupConfiguration(String configKey) {
        Object configValue = currentConfig.get(configKey);
        String backupId = generateBackupId(configKey);
        Path backupPath = backupDirectory.resolve(backupId + ".json");
        
        try {
            // 序列化配置
            String configJson = objectMapper.writeValueAsString(configValue);
            
            // 计算校验和
            String checksum = calculateChecksum(configJson);
            
            // 加密配置
            String encryptedConfig = encryptConfiguration(configJson);
            
            // 写入备份文件
            BackupMetadata metadata = BackupMetadata.builder()
                .backupId(backupId)
                .configKey(configKey)
                .timestamp(System.currentTimeMillis())
                .checksum(checksum)
                .size(configJson.length())
                .build();
                
            writeBackupFile(backupPath, encryptedConfig, metadata);
            
            log.info("配置备份完成: {}", configKey);
            
        } catch (Exception e) {
            log.error("配置备份失败: {}", configKey, e);
            throw new ConfigBackupException("配置备份失败", e);
        }
    }
    
    public Object restoreConfiguration(String configKey, String backupId) {
        Path backupPath = backupDirectory.resolve(backupId + ".json");
        
        try {
            // 读取备份文件
            BackupFile backupFile = readBackupFile(backupPath);
            
            // 验证校验和
            validateChecksum(backupFile);
            
            // 解密配置
            String decryptedConfig = decryptConfiguration(backupFile.getEncryptedConfig());
            
            // 反序列化配置
            Object configValue = objectMapper.readValue(decryptedConfig, Object.class);
            
            // 验证配置有效性
            validateConfiguration(configValue);
            
            // 应用配置
            applyConfiguration(configKey, configValue);
            
            log.info("配置恢复完成: {} <- {}", configKey, backupId);
            
            return configValue;
            
        } catch (Exception e) {
            log.error("配置恢复失败: {} <- {}", configKey, backupId, e);
            throw new ConfigRestoreException("配置恢复失败", e);
        }
    }
}
```

### 灾难恢复规划

**灾难恢复策略**：
```java
// 灾难恢复管理器
@Component
public class DisasterRecoveryManager {
    
    private final RecoveryPlanRepository recoveryPlanRepository;
    private final NotificationService notificationService;
    private final ScheduledExecutorService scheduler = 
        Executors.newSingleThreadScheduledExecutor();
    
    @PostConstruct
    public void init() {
        // 定期检查灾难恢复准备状态
        scheduler.scheduleWithFixedDelay(this::checkRecoveryReadiness,
            0, 1, TimeUnit.HOURS);
            
        // 定期执行恢复演练
        scheduler.scheduleWithFixedDelay(this::performRecoveryDrill,
            0, 24, TimeUnit.HOURS);
    }
    
    public void triggerDisasterRecovery(String disasterType, String affectedRegion) {
        try {
            // 1. 评估灾难影响范围
            DisasterImpact assessment = assessDisasterImpact(disasterType, affectedRegion);
            
            // 2. 激活灾难恢复计划
            RecoveryPlan plan = activateRecoveryPlan(assessment);
            
            // 3. 执行数据恢复
            DataRecoveryResult dataResult = performDataRecovery(plan);
            
            // 4. 恢复应用服务
            ServiceRecoveryResult serviceResult = recoverServices(plan);
            
            // 5. 验证系统完整性
            ValidationResult validation = validateSystemIntegrity(plan);
            
            // 6. 切换流量
            TrafficSwitchResult trafficResult = switchTraffic(affectedRegion);
            
            // 7. 通知相关人员
            notifyStakeholders(assessment, plan, dataResult, serviceResult, validation, trafficResult);
            
            log.info("灾难恢复完成: {}", disasterType);
            
        } catch (Exception e) {
            log.error("灾难恢复失败: {}", disasterType, e);
            escalateToManualRecovery(disasterType, e);
        }
    }
    
    private DisasterImpact assessDisasterImpact(String disasterType, String affectedRegion) {
        DisasterImpact.Builder impactBuilder = DisasterImpact.builder()
            .disasterType(disasterType)
            .affectedRegion(affectedRegion)
            .assessmentTime(System.currentTimeMillis());
        
        // 检查基础设施影响
        InfrastructureImpact infraImpact = assessInfrastructureImpact(affectedRegion);
        impactBuilder.infrastructureImpact(infraImpact);
        
        // 检查数据影响
        DataImpact dataImpact = assessDataImpact(affectedRegion);
        impactBuilder.dataImpact(dataImpact);
        
        // 检查服务影响
        ServiceImpact serviceImpact = assessServiceImpact(affectedRegion);
        impactBuilder.serviceImpact(serviceImpact);
        
        // 估算恢复时间
        EstimatedRecoveryTime estimatedTime = estimateRecoveryTime(infraImpact, dataImpact, serviceImpact);
        impactBuilder.estimatedRecoveryTime(estimatedTime);
        
        return impactBuilder.build();
    }
    
    private DataRecoveryResult performDataRecovery(RecoveryPlan plan) {
        RecoveryResult.Builder resultBuilder = RecoveryResult.builder()
            .planId(plan.getId())
            .startTime(System.currentTimeMillis());
        
        try {
            // 1. 确定数据恢复优先级
            List<DataRestorePriority> priorities = determineDataRestorePriority(plan);
            
            // 2. 并行恢复关键数据
            List<CompletableFuture<DataRestoreResult>> restoreTasks = priorities.stream()
                .map(priority -> CompletableFuture.supplyAsync(() -> {
                    return restoreDataSet(priority);
                }))
                .collect(Collectors.toList());
                
            // 等待所有恢复任务完成
            CompletableFuture.allOf(restoreTasks.toArray(new CompletableFuture[0]))
                .join();
                
            // 3. 验证数据完整性
            validateRecoveredData(plan);
            
            // 4. 应用数据变更
            applyDataChanges(plan);
            
            resultBuilder
                .status(RecoveryStatus.SUCCESS)
                .endTime(System.currentTimeMillis())
                .details("数据恢复成功")
                .build();
                
        } catch (Exception e) {
            resultBuilder
                .status(RecoveryStatus.FAILED)
                .endTime(System.currentTimeMillis())
                .error(e.getMessage())
                .build();
                
            throw new DataRecoveryException("数据恢复失败", e);
        }
        
        return resultBuilder.build();
    }
}
```

**恢复时间目标（RTO）和恢复点目标（RPO）**：
```java
// RTO/RPO管理
@Service
public class RtoRpoManager {
    
    private final Map<String, ServiceRtoRpo> serviceRtoRpoConfig = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void init() {
        // 初始化RTO/RPO配置
        serviceRtoRpoConfig.put("paymentService", ServiceRtoRpo.builder()
            .serviceName("paymentService")
            .recoveryTimeObjective(Duration.ofMinutes(15))    // RTO: 15分钟
            .recoveryPointObjective(Duration.ofMinutes(5))    // RPO: 5分钟
            .backupFrequency(Duration.ofMinutes(5))           // 5分钟备份一次
            .redundancyLevel(3)                              // 三重冗余
            .build());
            
        serviceRtoRpoConfig.put("userService", ServiceRtoRpo.builder()
            .serviceName("userService")
            .recoveryTimeObjective(Duration.ofHours(2))       // RTO: 2小时
            .recoveryPointObjective(Duration.ofHours(1))      // RPO: 1小时
            .backupFrequency(Duration.ofHours(1))            // 1小时备份一次
            .redundancyLevel(2)                              // 双重冗余
            .build());
    }
    
    public boolean meetsRtoRequirement(String serviceName, Duration actualRecoveryTime) {
        ServiceRtoRpo config = serviceRtoRpoConfig.get(serviceName);
        if (config == null) {
            return false;
        }
        
        Duration rto = config.getRecoveryTimeObjective();
        boolean meetsRequirement = !actualRecoveryTime.isLongerThan(rto);
        
        log.info("RTO检查: 服务={}, 要求={}, 实际={}, 满足要求={}", 
            serviceName, rto, actualRecoveryTime, meetsRequirement);
            
        return meetsRequirement;
    }
    
    public boolean meetsRpoRequirement(String serviceName, Duration dataLossWindow) {
        ServiceRtoRpo config = serviceRtoRpoConfig.get(serviceName);
        if (config == null) {
            return false;
        }
        
        Duration rpo = config.getRecoveryPointObjective();
        boolean meetsRequirement = !dataLossWindow.isLongerThan(rpo);
        
        log.info("RPO检查: 服务={}, 要求={}, 实际丢失窗口={}, 满足要求={}", 
            serviceName, rpo, dataLossWindow, meetsRequirement);
            
        return meetsRequirement;
    }
    
    public void monitorRtoRpoCompliance() {
        for (ServiceRtoRpo config : serviceRtoRpoConfig.values()) {
            // 监控备份频率合规性
            Duration lastBackup = getLastBackupTime(config.getServiceName());
            Duration backupGap = Duration.between(lastBackup, Instant.now());
            
            if (backupGap.isLongerThan(config.getBackupFrequency().multipliedBy(1.5))) {
                // 备份间隔超过配置的150%，发送告警
                sendRtoRpoAlert(config, "备份频率违规", 
                    String.format("备份间隔 %s 超过配置的 %s", backupGap, config.getBackupFrequency()));
            }
            
            // 监控冗余度合规性
            int currentRedundancy = getCurrentRedundancyLevel(config.getServiceName());
            if (currentRedundancy < config.getRedundancyLevel()) {
                sendRtoRpoAlert(config, "冗余度不足", 
                    String.format("当前冗余度 %d 低于要求的 %d", currentRedundancy, config.getRedundancyLevel()));
            }
        }
    }
}
```

## 可靠性测试

### 故障注入测试

**混沌工程实现**：
```java
// 混沌工程注入器
@Component
public class ChaosInjector {
    
    private final Map<String, ChaosExperiment> activeExperiments = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = 
        Executors.newSingleThreadScheduledExecutor();
    
    @EventListener
    public void handleChaosRequest(ChaosExperimentRequest request) {
        ChaosExperiment experiment = ChaosExperiment.builder()
            .id(request.getExperimentId())
            .type(request.getChaosType())
            .target(request.getTargetService())
            .parameters(request.getParameters())
            .startTime(Instant.now())
            .build();
            
        activeExperiments.put(experiment.getId(), experiment);
        
        // 执行混沌实验
        executeExperiment(experiment);
    }
    
    private void executeExperiment(ChaosExperiment experiment) {
        switch (experiment.getType()) {
            case NETWORK_LATENCY:
                injectNetworkLatency(experiment);
                break;
            case SERVICE_FAILURE:
                injectServiceFailure(experiment);
                break;
            case RESOURCE_EXHAUSTION:
                injectResourceExhaustion(experiment);
                break;
            case DATA_CORRUPTION:
                injectDataCorruption(experiment);
                break;
            default:
                log.warn("未知的混沌实验类型: {}", experiment.getType());
        }
    }
    
    private void injectNetworkLatency(ChaosExperiment experiment) {
        Map<String, Object> params = experiment.getParameters();
        int delayMs = (Integer) params.getOrDefault("delayMs", 1000);
        int packetLossPercent = (Integer) params.getOrDefault("packetLossPercent", 5);
        
        try {
            // 使用tc命令注入网络延迟
            ProcessBuilder pb = new ProcessBuilder("tc", "qdisc", "add", "dev", "eth0", 
                "root", "netem", "delay", delayMs + "ms", "loss", packetLossPercent + "%");
            Process process = pb.start();
            
            // 记录实验开始
            experiment.start();
            
            // 持续指定时间后恢复
            Duration experimentDuration = Duration.ofSeconds(
                (Integer) params.getOrDefault("durationSeconds", 300)
            );
            
            scheduler.schedule(() -> {
                cleanupNetworkLatency();
                experiment.complete();
                log.info("网络延迟混沌实验完成: {}", experiment.getId());
            }, experimentDuration.toMillis(), TimeUnit.MILLISECONDS);
            
        } catch (Exception e) {
            log.error("注入网络延迟失败", e);
            experiment.fail(e);
        }
    }
    
    private void injectServiceFailure(ChaosExperiment experiment) {
        String targetService = experiment.getTarget();
        FailureMode failureMode = FailureMode.valueOf(
            (String) experiment.getParameters().getOrDefault("failureMode", "CIRCUIT_BREAKER"));
            
        try {
            switch (failureMode) {
                case CIRCUIT_BREAKER:
                    // 触发熔断器
                    triggerCircuitBreaker(targetService);
                    break;
                case SERVICE_UNAVAILABLE:
                    // 模拟服务不可用
                    simulateServiceUnavailable(targetService);
                    break;
                case RESPONSE_DELAY:
                    // 模拟响应延迟
                    simulateResponseDelay(targetService);
                    break;
            }
            
            experiment.start();
            
            // 持续时间后恢复
            Duration experimentDuration = Duration.ofSeconds(
                (Integer) experiment.getParameters().getOrDefault("durationSeconds", 60)
            );
            
            scheduler.schedule(() -> {
                cleanupServiceFailure(targetService);
                experiment.complete();
            }, experimentDuration.toMillis(), TimeUnit.MILLISECONDS);
            
        } catch (Exception e) {
            log.error("注入服务故障失败", e);
            experiment.fail(e);
        }
    }
}
```

### 可靠性基准测试

**故障场景测试**：
```java
// 故障场景测试套件
@SpringBootTest
public class ReliabilityTestSuite {
    
    @Autowired
    private CircuitBreaker circuitBreaker;
    
    @Autowired
    private ServiceHealthChecker healthChecker;
    
    @Autowired
    private DisasterRecoveryManager recoveryManager;
    
    @Test
    @DisplayName("测试单点故障恢复")
    public void testSinglePointFailureRecovery() {
        // 模拟单点故障
        String serviceId = "critical-service";
        markServiceAsUnhealthy(serviceId);
        
        // 验证故障检测时间
        long detectionStart = System.currentTimeMillis();
        Awaitility.await()
            .atMost(30, TimeUnit.SECONDS)
            .until(() -> !healthChecker.isServiceHealthy(serviceId));
        long detectionTime = System.currentTimeMillis() - detectionStart;
        
        assertThat(detectionTime).isLessThan(30000);
        
        // 验证自动恢复
        Awaitility.await()
            .atMost(5, TimeUnit.MINUTES)
            .until(() -> recoveryManager.hasRecovered(serviceId));
            
        assertThat(healthChecker.isServiceHealthy(serviceId)).isTrue();
    }
    
    @Test
    @DisplayName("测试数据恢复完整性")
    public void testDataRecoveryIntegrity() {
        // 创建测试数据
        String testDataId = createTestData();
        
        // 模拟数据丢失
        deleteTestData(testDataId);
        
        // 执行数据恢复
        DataRecoveryResult result = recoveryManager.restoreData(testDataId);
        
        // 验证数据完整性
        assertThat(result.isSuccessful()).isTrue();
        assertThat(result.getRecoveryTime()).isLessThan(Duration.ofMinutes(10));
        assertThat(validateDataIntegrity(testDataId)).isTrue();
    }
    
    @Test
    @DisplayName("测试熔断器功能")
    public void testCircuitBreakerFunctionality() {
        // 模拟服务持续失败
        simulateServiceFailure();
        
        // 验证熔断器开启
        Awaitility.await()
            .atMost(10, TimeUnit.SECONDS)
            .until(() -> circuitBreaker.getState() == CircuitBreaker.State.OPEN);
            
        assertThatThrownBy(() -> circuitBreaker.execute(() -> {
            throw new RuntimeException("Service failed");
        })).isInstanceOf(CircuitBreakerOpenException.class);
        
        // 等待超时后验证半开状态
        Awaitility.await()
            .atMost(70, TimeUnit.SECONDS)
            .until(() -> circuitBreaker.getState() == CircuitBreaker.State.HALF_OPEN);
            
        // 模拟服务恢复
        simulateServiceRecovery();
        
        // 验证熔断器关闭
        Awaitility.await()
            .atMost(30, TimeUnit.SECONDS)
            .until(() -> circuitBreaker.getState() == CircuitBreaker.State.CLOSED);
    }
    
    @Test
    @DisplayName("测试多级降级策略")
    public void testMultiLevelDegradation() {
        // 第一级降级：使用缓存
        simulatePrimaryServiceSlow();
        assertThat(degradationService.getUser(userId)).isInstanceOf(UserCacheFallback.class);
        
        // 第二级降级：使用默认值
        simulateCacheFailure();
        assertThat(degradationService.getUser(userId)).isInstanceOf(UserDefaultFallback.class);
        
        // 第三级降级：返回错误信息
        simulateDefaultServiceFailure();
        assertThatThrownBy(() -> degradationService.getUser(userId))
            .isInstanceOf(ServiceUnavailableException.class);
    }
}
```

## 监控与告警

### 可靠性指标监控

**可靠性指标收集**：
```java
// 可靠性指标收集器
@Component
public class ReliabilityMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    private final Map<String, Timer> serviceAvailabilityTimers = new ConcurrentHashMap<>();
    private final Map<String, Counter> failureCounters = new ConcurrentHashMap<>();
    
    @EventListener
    public void handleServiceStatusChange(ServiceStatusChangeEvent event) {
        String serviceName = event.getServiceName();
        ServiceStatus oldStatus = event.getOldStatus();
        ServiceStatus newStatus = event.getNewStatus();
        
        // 记录状态变更
        meterRegistry.counter("service.status.changes.total",
            "service", serviceName,
            "from_status", oldStatus.name(),
            "to_status", newStatus.name()).increment();
            
        // 记录可用性变化
        if (oldStatus == ServiceStatus.HEALTHY && newStatus == ServiceStatus.UNHEALTHY) {
            recordServiceDowntime(serviceName);
        } else if (oldStatus == ServiceStatus.UNHEALTHY && newStatus == ServiceStatus.HEALTHY) {
            recordServiceUptime(serviceName);
        }
    }
    
    @EventListener
    public void handleBackupEvent(BackupEvent event) {
        String backupType = event.getBackupType().name();
        Duration backupDuration = event.getDuration();
        boolean success = event.isSuccessful();
        
        // 记录备份操作指标
        Timer.Sample sample = Timer.start(meterRegistry);
        sample.stop(Timer.builder("backup.operations")
            .description("备份操作耗时")
            .tag("backup_type", backupType)
            .tag("result", success ? "success" : "failure")
            .register(meterRegistry));
            
        if (!success) {
            meterRegistry.counter("backup.failures.total",
                "backup_type", backupType,
                "failure_reason", event.getFailureReason().orElse("unknown")).increment();
        }
    }
    
    @EventListener
    public void handleRecoveryEvent(RecoveryEvent event) {
        String recoveryType = event.getRecoveryType();
        Duration recoveryTime = event.getRecoveryTime();
        boolean meetsRto = event.meetsRto();
        boolean meetsRpo = event.meetsRpo();
        
        // 记录恢复指标
        meterRegistry.timer("recovery.operations")
            .tags(Map.of(
                "recovery_type", recoveryType,
                "meets_rto", String.valueOf(meetsRto),
                "meets_rpo", String.valueOf(meetsRpo)
            ))
            .record(recoveryTime);
            
        // 记录RTO/RPO合规性
        if (!meetsRto) {
            meterRegistry.counter("rto.violations.total",
                "recovery_type", recoveryType).increment();
        }
        
        if (!meetsRpo) {
            meterRegistry.counter("rpo.violations.total",
                "recovery_type", recoveryType).increment();
        }
    }
    
    @Scheduled(fixedRate = 60000) // 每分钟计算可用性
    public void calculateServiceAvailability() {
        for (String serviceName : getAllServiceNames()) {
            AvailabilityStats stats = calculateServiceAvailability(serviceName);
            
            meterRegistry.gauge("service.availability.percentage", 
                Map.of("service", serviceName), 
                stats.getAvailabilityPercentage());
                
            meterRegistry.gauge("service.mtbf.hours",
                Map.of("service", serviceName),
                stats.getMtbf().toHoursPart());
                
            meterRegistry.gauge("service.mttr.minutes",
                Map.of("service", serviceName),
                stats.getMttr().toMinutesPart());
        }
    }
}
```

### 智能告警系统

**多级告警策略**：
```java
// 智能告警管理器
@Component
public class IntelligentAlertManager {
    
    private final AlertRuleEngine alertRuleEngine;
    private final NotificationService notificationService;
    private final AlertEscalationService escalationService;
    
    @EventListener
    public void handleReliabilityAlert(ReliabilityAlertEvent event) {
        Alert alert = Alert.builder()
            .id(generateAlertId())
            .severity(event.getSeverity())
            .service(event.getServiceName())
            .type(event.getAlertType())
            .description(event.getDescription())
            .timestamp(System.currentTimeMillis())
            .metrics(event.getMetrics())
            .build();
            
        // 应用告警规则
        AlertRuleResult ruleResult = alertRuleEngine.evaluate(alert);
        
        if (ruleResult.shouldSuppress()) {
            log.info("告警被抑制: {}", alert.getId());
            return;
        }
        
        // 发送到合适渠道
        List<NotificationChannel> channels = determineNotificationChannels(alert, ruleResult);
        notificationService.sendAlert(alert, channels);
        
        // 设置升级规则
        setupEscalation(alert, ruleResult);
        
        // 记录告警历史
        recordAlert(alert);
    }
    
    private List<NotificationChannel> determineNotificationChannels(Alert alert, AlertRuleResult ruleResult) {
        List<NotificationChannel> channels = new ArrayList<>();
        
        switch (alert.getSeverity()) {
            case CRITICAL:
                channels.addAll(Arrays.asList(
                    NotificationChannel.SMS,
                    NotificationChannel.EMAIL,
                    NotificationChannel.SLACK,
                    NotificationChannel.PAGER_DUTY
                ));
                break;
                
            case WARNING:
                channels.addAll(Arrays.asList(
                    NotificationChannel.EMAIL,
                    NotificationChannel.SLACK
                ));
                break;
                
            case INFO:
                channels.add(NotificationChannel.SLACK);
                break;
        }
        
        // 根据规则调整通知渠道
        if (ruleResult.getCustomChannels() != null) {
            channels.addAll(ruleResult.getCustomChannels());
        }
        
        // 根据时间段调整
        if (isOutsideBusinessHours()) {
            channels.removeIf(channel -> 
                channel == NotificationChannel.SLACK || 
                channel == NotificationChannel.EMAIL);
            channels.add(NotificationChannel.PAGER_DUTY);
        }
        
        return channels;
    }
    
    private void setupEscalation(Alert alert, AlertRuleResult ruleResult) {
        AlertEscalationPlan plan = ruleResult.getEscalationPlan();
        if (plan == null) {
            plan = createDefaultEscalationPlan(alert);
        }
        
        for (AlertEscalationStep step : plan.getSteps()) {
            escalationService.scheduleEscalation(alert.getId(), step);
        }
    }
}

// 告警规则引擎
@Component
public class AlertRuleEngine {
    
    private final List<AlertRule> rules = new ArrayList<>();
    
    @PostConstruct
    public void init() {
        // 加载告警规则
        rules.addAll(loadAlertRules());
    }
    
    public AlertRuleResult evaluate(Alert alert) {
        AlertRuleResult.Builder resultBuilder = AlertRuleResult.builder();
        
        for (AlertRule rule : rules) {
            if (rule.appliesTo(alert)) {
                RuleEvaluationResult evaluation = rule.evaluate(alert);
                
                if (evaluation.shouldSuppress()) {
                    resultBuilder.suppress(true);
                    resultBuilder.suppressionReason(evaluation.getSuppressionReason());
                }
                
                if (evaluation.hasCustomChannels()) {
                    resultBuilder.customChannels(evaluation.getCustomChannels());
                }
                
                if (evaluation.hasEscalationPlan()) {
                    resultBuilder.escalationPlan(evaluation.getEscalationPlan());
                }
                
                // 复合规则逻辑
                if (rule instanceof CompositeAlertRule) {
                    CompositeAlertRule compositeRule = (CompositeAlertRule) rule;
                    resultBuilder.addSubResults(compositeRule.evaluateSubRules(alert));
                }
            }
        }
        
        return resultBuilder.build();
    }
}
```

## 最佳实践与反模式

### 可靠性设计原则

**防御性编程**：
```java
// 好的做法：防御性编程
public class DefensiveUserService {
    
    private final UserRepository userRepository;
    private final CircuitBreaker circuitBreaker;
    private final Cache<String, User> userCache;
    
    public Optional<User> getUserById(Long userId) {
        // 参数验证
        if (userId == null || userId <= 0) {
            log.warn("无效的用户ID: {}", userId);
            return Optional.empty();
        }
        
        String cacheKey = "user:" + userId;
        
        try {
            // 先尝试从缓存获取
            User cachedUser = userCache.get(cacheKey);
            if (cachedUser != null) {
                return Optional.of(cachedUser);
            }
            
            // 数据库查询（带熔断保护）
            User user = circuitBreaker.execute(() -> {
                return userRepository.findById(userId);
            });
            
            if (user != null) {
                userCache.put(cacheKey, user);
                return Optional.of(user);
            }
            
            return Optional.empty();
            
        } catch (CircuitBreakerOpenException e) {
            log.warn("熔断器开启，使用缓存数据", e);
            
            // 熔断器开启时，尝试返回过期缓存
            User staleUser = getStaleUserFromCache(cacheKey);
            return Optional.ofNullable(staleUser);
            
        } catch (Exception e) {
            log.error("获取用户信息失败: {}", userId, e);
            
            // 返回安全的默认值
            return Optional.of(createDefaultUser(userId));
        }
    }
    
    private User getStaleUserFromCache(String cacheKey) {
        try {
            // 从过期缓存中获取数据
            return userCache.getIfPresent(cacheKey);
        } catch (Exception e) {
            log.warn("读取过期缓存失败", e);
            return null;
        }
    }
    
    private User createDefaultUser(Long userId) {
        return User.builder()
            .id(userId)
            .name("未知用户")
            .status(UserStatus.INACTIVE)
            .createdAt(Instant.now())
            .build();
    }
}
```

**渐进式降级**：
```java
// 渐进式降级策略
@Component
public class ProgressiveDegradationStrategy {
    
    private final List<DegradationLevel> degradationLevels = Arrays.asList(
        DegradationLevel.builder()
            .level(1)
            .name("性能降级")
            .actions(Arrays.asList(
                () -> disableNonEssentialFeatures(),
                () -> reduceCacheTTL(),
                () -> increaseResponseTimeouts()
            ))
            .build(),
            
        DegradationLevel.builder()
            .level(2)
            .name("功能降级")
            .actions(Arrays.asList(
                () -> disableAdvancedFeatures(),
                () -> useSimplerAlgorithms(),
                () -> reduceDataPrecision()
            ))
            .build(),
            
        DegradationLevel.builder()
            .level(3)
            .name("基础功能")
            .actions(Arrays.asList(
                () -> enableOnlyCoreFeatures(),
                () -> returnCachedStaticData(),
                () -> enableReadOnlyMode()
            ))
            .build()
    );
    
    public void applyDegradationLevel(int level) {
        DegradationLevel degradationLevel = degradationLevels.stream()
            .filter(dl -> dl.getLevel() == level)
            .findFirst()
            .orElseThrow(() -> new IllegalArgumentException("未知的降级级别: " + level));
            
        log.warn("应用降级策略: {}", degradationLevel.getName());
        
        degradationLevel.getActions().forEach(action -> {
            try {
                action.execute();
            } catch (Exception e) {
                log.error("执行降级动作失败", e);
            }
        });
        
        // 通知相关组件
        eventPublisher.publishEvent(new DegradationLevelChangedEvent(level));
    }
}
```

### 常见反模式

**过度依赖单体架构**：
```java
// 反模式：过度依赖单体架构
// 订单系统中，所有业务逻辑都在一个单体中
@SpringBootApplication
public class MonolithicOrderApplication {
    
    @RestController
    public class OrderController {
        
        @Autowired
        private OrderService orderService;
        @Autowired
        private InventoryService inventoryService;
        @Autowired
        private PaymentService paymentService;
        @Autowired
        private EmailService emailService;
        @Autowired
        private NotificationService notificationService;
        @Autowired
        private ReportingService reportingService;
        @Autowired
        private AnalyticsService analyticsService;
        
        @PostMapping("/orders")
        public Order createOrder(@RequestBody OrderRequest request) {
            // 所有服务都在一个方法中，任何一个故障都会导致整个订单创建失败
            Order order = orderService.createOrder(request);
            inventoryService.reserveInventory(order);
            PaymentResult payment = paymentService.processPayment(order);
            emailService.sendConfirmation(order);
            notificationService.notifyUsers(order);
            reportingService.generateOrderReport(order);
            analyticsService.trackOrderEvent(order);
            
            return order;
        }
    }
}

// 好的做法：微服务架构
// 每个服务独立部署，故障隔离
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    @Autowired
    private InventoryClient inventoryClient;
    @Autowired
    private PaymentClient paymentClient;
    
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 1. 创建订单
        Order order = createOrderEntity(request);
        
        try {
            // 2. 预留库存（异步+重试）
            CompletableFuture<Void> inventoryFuture = 
                inventoryClient.reserveInventoryAsync(order.getId());
                
            // 3. 处理支付（异步+熔断）
            CompletableFuture<PaymentResult> paymentFuture = 
                paymentClient.processPaymentAsync(order.getId());
            
            // 4. 等待关键操作完成
            CompletableFuture.allOf(inventoryFuture, paymentFuture).join();
            
            order.markAsConfirmed();
            return orderRepository.save(order);
            
        } catch (Exception e) {
            // 处理失败，回滚操作
            order.markAsFailed(e.getMessage());
            return orderRepository.save(order);
        }
    }
}
```

**忽视监控和告警**：
```java
// 反模式：缺乏监控和告警
@Component
public class PoorMonitoringExample {
    
    public void processOrder(Order order) {
        try {
            // 业务处理，但没有监控
            processPayment(order);
            updateInventory(order);
            sendEmail(order);
            
        } catch (Exception e) {
            // 只是打印日志，没有告警
            System.out.println("订单处理失败: " + e.getMessage());
        }
    }
}

// 好的做法：完善的监控和告警
@Component
public class WellMonitoredOrderService {
    
    private final MeterRegistry meterRegistry;
    private final AlertService alertService;
    
    public void processOrder(Order order) {
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            // 业务处理
            processPayment(order);
            updateInventory(order);
            sendEmail(order);
            
            // 记录成功指标
            meterRegistry.counter("orders.processed.success.total").increment();
            
        } catch (Exception e) {
            // 记录失败指标
            meterRegistry.counter("orders.processed.failure.total",
                "error_type", e.getClass().getSimpleName()).increment();
                
            // 发送告警
            if (isCriticalFailure(e)) {
                alertService.sendAlert(Alert.builder()
                    .severity(AlertSeverity.HIGH)
                    .service("order-service")
                    .description("订单处理失败: " + e.getMessage())
                    .build());
            }
            
            throw e;
            
        } finally {
            sample.stop(Timer.builder("orders.processing.duration")
                .description("订单处理耗时")
                .register(meterRegistry));
        }
    }
    
    private boolean isCriticalFailure(Exception e) {
        // 判断是否为关键故障
        return e instanceof PaymentFailureException || 
               e instanceof InventoryShortageException;
    }
}
```

## 总结

系统可靠性设计是一个系统性工程，需要从架构设计、编码实现、测试验证、监控运维等多个维度进行考虑。关键要点包括：

1. **故障预防**：通过良好的架构设计和代码实践预防故障
2. **故障检测**：建立完善的健康检查和监控系统
3. **故障隔离**：使用熔断器、舱壁隔离等模式限制故障影响范围
4. **故障恢复**：制定完善的备份和恢复策略
5. **持续改进**：通过混沌工程和故障演练不断提升系统可靠性

只有建立了完整的可靠性管理体系，才能确保系统在各种异常情况下仍能稳定运行，为用户提供可靠的服务体验。