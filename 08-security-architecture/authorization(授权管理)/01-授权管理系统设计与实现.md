# 授权管理系统设计与实现

## 目录
1. [授权管理概述](#授权管理概述)
2. [RBAC模型](#rbac模型)
3. [ABAC模型](#abac模型)
4. [权限验证](#权限验证)
5. [授权缓存](#授权缓存)
6. [授权审计](#授权审计)

## 授权管理概述

授权管理是控制用户对资源访问权限的过程，是在身份认证基础上建立的安全机制。正确的授权策略能够确保用户只能访问他们有权访问的资源。

### 授权目标
- **最小权限原则**: 用户只获得完成工作所需的最小权限
- **职责分离**: 敏感操作需要多个用户共同完成
- **动态权限**: 根据上下文动态调整权限
- **审计追踪**: 记录所有授权相关操作

### 授权模型
- **DAC**: 自主访问控制，资源所有者决定访问权限
- **MAC**: 强制访问控制，系统强制执行安全策略
- **RBAC**: 基于角色的访问控制
- **ABAC**: 基于属性的访问控制

## RBAC模型

基于角色的访问控制（Role-Based Access Control）是最常用的授权模型。

```python
from typing import Dict, List, Set, Optional
from datetime import datetime
import json

class Permission:
    """权限类"""
    def __init__(self, name: str, resource: str, action: str):
        self.name = name
        self.resource = resource
        self.action = action
        self.created_at = datetime.now()
    
    def __str__(self):
        return f"{self.name}: {self.resource}:{self.action}"
    
    def to_dict(self):
        return {
            'name': self.name,
            'resource': self.resource,
            'action': self.action,
            'created_at': self.created_at.isoformat()
        }

class Role:
    """角色类"""
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.permissions: Set[Permission] = set()
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
    
    def add_permission(self, permission: Permission):
        """添加权限"""
        self.permissions.add(permission)
        self.updated_at = datetime.now()
    
    def remove_permission(self, permission: Permission):
        """移除权限"""
        self.permissions.discard(permission)
        self.updated_at = datetime.now()
    
    def has_permission(self, resource: str, action: str) -> bool:
        """检查是否具有指定权限"""
        for permission in self.permissions:
            if permission.resource == resource and permission.action == action:
                return True
        return False
    
    def get_permissions(self) -> List[Permission]:
        """获取所有权限"""
        return list(self.permissions)

class User:
    """用户类"""
    def __init__(self, user_id: str, username: str, email: str):
        self.user_id = user_id
        self.username = username
        self.email = email
        self.roles: Set[Role] = set()
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
        self.is_active = True
    
    def add_role(self, role: Role):
        """添加角色"""
        self.roles.add(role)
        self.updated_at = datetime.now()
    
    def remove_role(self, role: Role):
        """移除角色"""
        self.roles.discard(role)
        self.updated_at = datetime.now()
    
    def has_role(self, role_name: str) -> bool:
        """检查是否具有指定角色"""
        for role in self.roles:
            if role.name == role_name:
                return True
        return False
    
    def has_permission(self, resource: str, action: str) -> bool:
        """检查是否具有指定权限"""
        if not self.is_active:
            return False
        
        for role in self.roles:
            if role.has_permission(resource, action):
                return True
        return False

class RBACManager:
    """基于角色的访问控制管理器"""
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.roles: Dict[str, Role] = {}
        self.permissions: Dict[str, Permission] = {}
        self.user_roles: Dict[str, Set[str]] = {}  # 用户ID到角色名称的映射
        self.role_permissions: Dict[str, Set[str]] = {}  # 角色名称到权限名称的映射
    
    def create_permission(self, name: str, resource: str, action: str) -> Permission:
        """创建权限"""
        permission = Permission(name, resource, action)
        self.permissions[name] = permission
        return permission
    
    def create_role(self, name: str, description: str = "") -> Role:
        """创建角色"""
        role = Role(name, description)
        self.roles[name] = role
        return role
    
    def assign_permission_to_role(self, role_name: str, permission_name: str) -> bool:
        """为角色分配权限"""
        if role_name not in self.roles or permission_name not in self.permissions:
            return False
        
        role = self.roles[role_name]
        permission = self.permissions[permission_name]
        role.add_permission(permission)
        
        # 更新映射
        if role_name not in self.role_permissions:
            self.role_permissions[role_name] = set()
        self.role_permissions[role_name].add(permission_name)
        
        return True
    
    def create_user(self, user_id: str, username: str, email: str) -> User:
        """创建用户"""
        user = User(user_id, username, email)
        self.users[user_id] = user
        return user
    
    def assign_role_to_user(self, user_id: str, role_name: str) -> bool:
        """为用户分配角色"""
        if user_id not in self.users or role_name not in self.roles:
            return False
        
        user = self.users[user_id]
        role = self.roles[role_name]
        user.add_role(role)
        
        # 更新映射
        if user_id not in self.user_roles:
            self.user_roles[user_id] = set()
        self.user_roles[user_id].add(role_name)
        
        return True
    
    def revoke_role_from_user(self, user_id: str, role_name: str) -> bool:
        """从用户撤销角色"""
        if user_id not in self.users or role_name not in self.roles:
            return False
        
        user = self.users[user_id]
        role = self.roles[role_name]
        user.remove_role(role)
        
        # 更新映射
        if user_id in self.user_roles:
            self.user_roles[user_id].discard(role_name)
        
        return True
    
    def check_permission(self, user_id: str, resource: str, action: str) -> bool:
        """检查用户权限"""
        if user_id not in self.users:
            return False
        
        user = self.users[user_id]
        return user.has_permission(resource, action)
    
    def get_user_permissions(self, user_id: str) -> List[Permission]:
        """获取用户所有权限"""
        if user_id not in self.users:
            return []
        
        user = self.users[user_id]
        all_permissions = set()
        
        for role in user.roles:
            all_permissions.update(role.permissions)
        
        return list(all_permissions)
```

## ABAC模型

基于属性的访问控制（Attribute-Based Access Control）提供更灵活的权限控制。

```python
from typing import Any, Dict, List, Optional, Callable
import re

class Attribute:
    """属性类"""
    def __init__(self, name: str, value: Any, attr_type: str = "string"):
        self.name = name
        self.value = value
        self.type = attr_type  # string, number, boolean, datetime
        self.created_at = datetime.now()
    
    def evaluate(self, operator: str, other_value: Any) -> bool:
        """评估属性条件"""
        if operator == "==":
            return self.value == other_value
        elif operator == "!=":
            return self.value != other_value
        elif operator == ">":
            return self.value > other_value
        elif operator == "<":
            return self.value < other_value
        elif operator == ">=":
            return self.value >= other_value
        elif operator == "<=":
            return self.value <= other_value
        elif operator == "in":
            return other_value in self.value if isinstance(self.value, list) else False
        elif operator == "contains":
            return other_value in self.value if isinstance(self.value, str) else False
        elif operator == "matches":
            return bool(re.search(str(other_value), str(self.value)))
        
        return False

class Policy:
    """策略类"""
    def __init__(self, name: str, description: str = ""):
        self.name = name
        self.description = description
        self.effect = "permit"  # permit or deny
        self.conditions: List[Callable] = []
        self.created_at = datetime.now()
    
    def add_condition(self, condition: Callable[[Dict], bool]):
        """添加条件"""
        self.conditions.append(condition)
    
    def evaluate(self, context: Dict) -> bool:
        """评估策略"""
        for condition in self.conditions:
            if not condition(context):
                return False
        return True

class ABACManager:
    """基于属性的访问控制管理器"""
    def __init__(self):
        self.user_attributes: Dict[str, Dict[str, Attribute]] = {}
        self.resource_attributes: Dict[str, Dict[str, Attribute]] = {}
        self.action_attributes: Dict[str, Dict[str, Attribute]] = {}
        self.environment_attributes: Dict[str, Attribute] = {}
        self.policies: List[Policy] = []
        self.policy_combining_algorithm = "first-match"  # first-match, permit-overrides, deny-overrides
    
    def set_user_attribute(self, user_id: str, attr_name: str, value: Any, attr_type: str = "string"):
        """设置用户属性"""
        if user_id not in self.user_attributes:
            self.user_attributes[user_id] = {}
        
        self.user_attributes[user_id][attr_name] = Attribute(attr_name, value, attr_type)
    
    def set_resource_attribute(self, resource_id: str, attr_name: str, value: Any, attr_type: str = "string"):
        """设置资源属性"""
        if resource_id not in self.resource_attributes:
            self.resource_attributes[resource_id] = {}
        
        self.resource_attributes[resource_id][attr_name] = Attribute(attr_name, value, attr_type)
    
    def set_action_attribute(self, action_name: str, attr_name: str, value: Any, attr_type: str = "string"):
        """设置动作属性"""
        if action_name not in self.action_attributes:
            self.action_attributes[action_name] = {}
        
        self.action_attributes[action_name][attr_name] = Attribute(attr_name, value, attr_type)
    
    def set_environment_attribute(self, attr_name: str, value: Any, attr_type: str = "string"):
        """设置环境属性"""
        self.environment_attributes[attr_name] = Attribute(attr_name, value, attr_type)
    
    def create_policy(self, name: str, description: str = "", effect: str = "permit") -> Policy:
        """创建策略"""
        policy = Policy(name, description)
        policy.effect = effect
        self.policies.append(policy)
        return policy
    
    def add_user_role_condition(self, policy: Policy, required_role: str):
        """添加用户角色条件"""
        def condition(context):
            user_id = context.get('user_id')
            if not user_id or user_id not in self.user_attributes:
                return False
            
            user_attrs = self.user_attributes[user_id]
            role_attr = user_attrs.get('role')
            
            return role_attr and role_attr.evaluate("==", required_role)
        
        policy.add_condition(condition)
    
    def add_time_condition(self, policy: Policy, start_time: str = "09:00", end_time: str = "17:00"):
        """添加时间条件"""
        def condition(context):
            current_time = datetime.now().strftime("%H:%M")
            return start_time <= current_time <= end_time
        
        policy.add_condition(condition)
    
    def add_department_condition(self, policy: Policy, allowed_departments: List[str]):
        """添加部门条件"""
        def condition(context):
            user_id = context.get('user_id')
            if not user_id or user_id not in self.user_attributes:
                return False
            
            user_attrs = self.user_attributes[user_id]
            dept_attr = user_attrs.get('department')
            
            return dept_attr and dept_attr.evaluate("in", allowed_departments)
        
        policy.add_condition(condition)
    
    def evaluate_access(self, user_id: str, resource_id: str, action: str) -> bool:
        """评估访问权限"""
        context = {
            'user_id': user_id,
            'resource_id': resource_id,
            'action': action,
            'user_attributes': self.user_attributes.get(user_id, {}),
            'resource_attributes': self.resource_attributes.get(resource_id, {}),
            'action_attributes': self.action_attributes.get(action, {}),
            'environment_attributes': self.environment_attributes
        }
        
        for policy in self.policies:
            if policy.evaluate(context):
                return policy.effect == "permit"
        
        return False  # 默认拒绝
```

## 权限验证

```python
class AuthorizationService:
    """授权服务"""
    def __init__(self, rbac_manager: RBACManager, abac_manager: ABACManager):
        self.rbac_manager = rbac_manager
        self.abac_manager = abac_manager
        self.cache = {}  # 权限缓存
        self.cache_ttl = 300  # 缓存5分钟
    
    def authorize(self, user_id: str, resource: str, action: str, context: Dict = None) -> Dict[str, Any]:
        """统一授权接口"""
        # 检查缓存
        cache_key = f"{user_id}:{resource}:{action}"
        cached_result = self._get_from_cache(cache_key)
        if cached_result is not None:
            return cached_result
        
        # RBAC检查
        rbac_result = self.rbac_manager.check_permission(user_id, resource, action)
        
        # ABAC检查
        abac_result = True
        if context:
            abac_result = self.abac_manager.evaluate_access(user_id, resource, action)
        
        # 合并结果
        final_result = rbac_result and abac_result
        
        result = {
            'authorized': final_result,
            'rbac_authorized': rbac_result,
            'abac_authorized': abac_result,
            'resource': resource,
            'action': action,
            'timestamp': datetime.now().isoformat()
        }
        
        # 缓存结果
        self._add_to_cache(cache_key, result)
        
        return result
    
    def _get_from_cache(self, key: str) -> Optional[Dict]:
        """从缓存获取结果"""
        if key in self.cache:
            entry = self.cache[key]
            if datetime.now().timestamp() - entry['timestamp'] < self.cache_ttl:
                return entry['result']
            else:
                del self.cache[key]
        return None
    
    def _add_to_cache(self, key: str, result: Dict):
        """添加结果到缓存"""
        self.cache[key] = {
            'result': result,
            'timestamp': datetime.now().timestamp()
        }
    
    def clear_cache(self, user_id: str = None):
        """清除缓存"""
        if user_id:
            # 清除指定用户的缓存
            keys_to_remove = [k for k in self.cache.keys() if k.startswith(f"{user_id}:")]
            for key in keys_to_remove:
                del self.cache[key]
        else:
            # 清除所有缓存
            self.cache.clear()
    
    def get_user_permissions_summary(self, user_id: str) -> Dict[str, Any]:
        """获取用户权限摘要"""
        rbac_permissions = self.rbac_manager.get_user_permissions(user_id)
        
        # 转换为可读格式
        rbac_summary = []
        for perm in rbac_permissions:
            rbac_summary.append({
                'name': perm.name,
                'resource': perm.resource,
                'action': perm.action
            })
        
        return {
            'user_id': user_id,
            'rbac_permissions': rbac_summary,
            'total_permissions': len(rbac_summary),
            'last_updated': datetime.now().isoformat()
        }
```

## 授权缓存

```python
import time
from threading import Lock
from typing import Dict, Any, Optional

class PermissionCache:
    """权限缓存管理器"""
    def __init__(self, max_size: int = 10000, default_ttl: int = 300):
        self.max_size = max_size
        self.default_ttl = default_ttl
        self.cache: Dict[str, Dict] = {}
        self.access_times: Dict[str, float] = {}
        self.lock = Lock()
        self.hit_count = 0
        self.miss_count = 0
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        with self.lock:
            if key not in self.cache:
                self.miss_count += 1
                return None
            
            entry = self.cache[key]
            if time.time() > entry['expires_at']:
                # 缓存过期
                del self.cache[key]
                if key in self.access_times:
                    del self.access_times[key]
                self.miss_count += 1
                return None
            
            # 更新访问时间
            self.access_times[key] = time.time()
            self.hit_count += 1
            return entry['value']
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """设置缓存值"""
        with self.lock:
            # 清理过期项
            self._cleanup_expired()
            
            # 如果缓存已满，清理最久未使用的项
            if len(self.cache) >= self.max_size:
                self._evict_lru()
            
            expires_at = time.time() + (ttl or self.default_ttl)
            self.cache[key] = {
                'value': value,
                'expires_at': expires_at
            }
            self.access_times[key] = time.time()
    
    def _cleanup_expired(self) -> None:
        """清理过期的缓存项"""
        current_time = time.time()
        expired_keys = [
            key for key, entry in self.cache.items()
            if current_time > entry['expires_at']
        ]
        
        for key in expired_keys:
            del self.cache[key]
            if key in self.access_times:
                del self.access_times[key]
    
    def _evict_lru(self) -> None:
        """清理最久未使用的缓存项"""
        if not self.access_times:
            return
        
        # 找到最久未使用的键
        lru_key = min(self.access_times.keys(), key=lambda k: self.access_times[k])
        
        # 删除该键
        del self.cache[lru_key]
        del self.access_times[lru_key]
    
    def clear(self) -> None:
        """清空缓存"""
        with self.lock:
            self.cache.clear()
            self.access_times.clear()
    
    def get_stats(self) -> Dict[str, Any]:
        """获取缓存统计信息"""
        total_requests = self.hit_count + self.miss_count
        hit_rate = self.hit_count / total_requests if total_requests > 0 else 0
        
        return {
            'hit_count': self.hit_count,
            'miss_count': self.miss_count,
            'hit_rate': hit_rate,
            'cache_size': len(self.cache),
            'max_size': self.max_size
        }
    
    def invalidate_user_permissions(self, user_id: str) -> int:
        """失效用户相关权限缓存"""
        with self.lock:
            keys_to_remove = [key for key in self.cache.keys() if key.startswith(f"{user_id}:")]
            
            for key in keys_to_remove:
                if key in self.cache:
                    del self.cache[key]
                if key in self.access_times:
                    del self.access_times[key]
            
            return len(keys_to_remove)
```

## 授权审计

```python
import json
from typing import Dict, Any, List
from datetime import datetime

class AuthorizationAudit:
    """授权审计"""
    def __init__(self):
        self.audit_log: List[Dict] = []
        self.security_events: List[Dict] = []
        self.max_log_size = 10000
    
    def log_authorization_decision(self, user_id: str, resource: str, action: str, 
                                 result: bool, context: Dict = None):
        """记录授权决策"""
        audit_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': 'AUTHORIZATION_DECISION',
            'user_id': user_id,
            'resource': resource,
            'action': action,
            'result': result,
            'context': context or {},
            'source_ip': context.get('source_ip', 'unknown') if context else 'unknown'
        }
        
        self.audit_log.append(audit_entry)
        
        # 保持日志大小限制
        if len(self.audit_log) > self.max_log_size:
            self.audit_log = self.audit_log[-self.max_log_size:]
    
    def log_security_event(self, event_type: str, user_id: str, details: str, 
                          severity: str = 'INFO'):
        """记录安全事件"""
        security_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'user_id': user_id,
            'details': details,
            'severity': severity
        }
        
        self.security_events.append(security_entry)
        
        # 保持日志大小限制
        if len(self.security_events) > self.max_log_size:
            self.security_events = self.security_events[-self.max_log_size:]
    
    def get_user_audit_trail(self, user_id: str, start_date: datetime = None, 
                           end_date: datetime = None) -> List[Dict]:
        """获取用户审计轨迹"""
        user_audit = [
            entry for entry in self.audit_log
            if entry['user_id'] == user_id
        ]
        
        if start_date:
            user_audit = [
                entry for entry in user_audit
                if datetime.fromisoformat(entry['timestamp']) >= start_date
            ]
        
        if end_date:
            user_audit = [
                entry for entry in user_audit
                if datetime.fromisoformat(entry['timestamp']) <= end_date
            ]
        
        return sorted(user_audit, key=lambda x: x['timestamp'])
    
    def analyze_access_patterns(self, days: int = 30) -> Dict[str, Any]:
        """分析访问模式"""
        cutoff_date = datetime.now() - timedelta(days=days)
        
        recent_audits = [
            entry for entry in self.audit_log
            if datetime.fromisoformat(entry['timestamp']) >= cutoff_date
        ]
        
        # 统计资源访问频率
        resource_access = {}
        failed_attempts = 0
        successful_attempts = 0
        
        for entry in recent_audits:
            resource = entry['resource']
            result = entry['result']
            
            if resource not in resource_access:
                resource_access[resource] = {'total': 0, 'success': 0, 'failure': 0}
            
            resource_access[resource]['total'] += 1
            
            if result:
                successful_attempts += 1
                resource_access[resource]['success'] += 1
            else:
                failed_attempts += 1
                resource_access[resource]['failure'] += 1
        
        return {
            'analysis_period_days': days,
            'total_accesses': len(recent_audits),
            'successful_attempts': successful_attempts,
            'failed_attempts': failed_attempts,
            'success_rate': successful_attempts / len(recent_audits) if recent_audits else 0,
            'resource_access_patterns': resource_access,
            'unique_users': len(set(entry['user_id'] for entry in recent_audits)),
            'unique_resources': len(set(entry['resource'] for entry in recent_audits))
        }
    
    def detect_anomalies(self, user_id: str = None, threshold: float = 2.0) -> List[Dict]:
        """检测异常访问模式"""
        anomalies = []
        
        # 获取最近的审计日志
        recent_logs = self.audit_log[-1000:]  # 最近1000条记录
        
        # 分析失败率
        user_failures = {}
        for entry in recent_logs:
            uid = entry['user_id']
            if uid not in user_failures:
                user_failures[uid] = {'total': 0, 'failures': 0}
            
            user_failures[uid]['total'] += 1
            if not entry['result']:
                user_failures[uid]['failures'] += 1
        
        # 计算异常
        for uid, stats in user_failures.items():
            if stats['total'] > 10:  # 至少10次访问
                failure_rate = stats['failures'] / stats['total']
                if failure_rate > threshold:
                    anomalies.append({
                        'user_id': uid,
                        'type': 'HIGH_FAILURE_RATE',
                        'failure_rate': failure_rate,
                        'total_attempts': stats['total'],
                        'failed_attempts': stats['failures'],
                        'severity': 'HIGH' if failure_rate > 0.5 else 'MEDIUM'
                    })
        
        # 如果指定了用户，只返回该用户的异常
        if user_id:
            anomalies = [a for a in anomalies if a['user_id'] == user_id]
        
        return anomalies
    
    def export_audit_report(self, start_date: datetime, end_date: datetime) -> str:
        """导出审计报告"""
        filtered_logs = [
            entry for entry in self.audit_log
            if start_date <= datetime.fromisoformat(entry['timestamp']) <= end_date
        ]
        
        report = {
            'report_period': {
                'start': start_date.isoformat(),
                'end': end_date.isoformat()
            },
            'summary': {
                'total_events': len(filtered_logs),
                'unique_users': len(set(entry['user_id'] for entry in filtered_logs)),
                'unique_resources': len(set(entry['resource'] for entry in filtered_logs)),
                'success_rate': len([e for e in filtered_logs if e['result']]) / len(filtered_logs) if filtered_logs else 0
            },
            'events': filtered_logs,
            'generated_at': datetime.now().isoformat()
        }
        
        return json.dumps(report, indent=2, ensure_ascii=False)
```

## 总结

授权管理系统需要考虑：
1. **选择合适的授权模型**: RBAC适合组织结构清晰的环境，ABAC适合复杂的权限场景
2. **性能优化**: 使用缓存机制减少数据库查询
3. **审计追踪**: 记录所有授权决策和安全事件
4. **异常检测**: 监控异常访问模式
5. **可扩展性**: 支持动态权限变更和权限继承

良好的授权系统应该在保证安全性的同时，提供灵活的权限管理和良好的性能表现。

---
*文档更新时间: 2024年12月*