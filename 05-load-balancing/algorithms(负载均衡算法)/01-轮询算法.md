# Round Robin 负载均衡算法详解

## 目录
1. [算法概述](#算法概述)
2. [算法原理](#算法原理)
3. [Python实现](#python实现)
4. [Go语言实现](#go语言实现)
5. [算法特点分析](#算法特点分析)
6. [应用场景](#应用场景)
7. [性能分析](#性能分析)
8. [故障处理](#故障处理)
9. [监控指标](#监控指标)
10. [实战案例](#实战案例)

## 算法概述

### 什么是Round Robin

Round Robin（轮询）是一种负载均衡算法，通过按顺序依次分配请求给后端服务器来均衡负载。该算法假设所有服务器具有相同的处理能力，每个服务器按顺序接收请求，当到达列表末尾时重新开始。

### 核心特性

```python
from typing import List, Dict, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import time
import threading
import random
import statistics
import json
import logging
from collections import defaultdict, deque
from concurrent.futures import ThreadPoolExecutor, as_completed
import copy

@dataclass
class Server:
    """服务器节点"""
    id: str
    hostname: str
    port: int
    weight: float = 1.0  # 权重，用于加权轮询
    health_check_url: str = None
    is_healthy: bool = True
    current_connections: int = 0
    response_times: deque = field(default_factory=lambda: deque(maxlen=100))
    last_health_check: float = field(default_factory=time.time)
    failure_count: int = 0
    success_count: int = 0
    total_requests: int = 0
    total_response_time: float = 0.0
    
    def get_avg_response_time(self) -> float:
        """获取平均响应时间"""
        if len(self.response_times) == 0:
            return 0.0
        return statistics.mean(self.response_times)
    
    def get_success_rate(self) -> float:
        """获取成功率"""
        total_attempts = self.success_count + self.failure_count
        if total_attempts == 0:
            return 0.0
        return self.success_count / total_attempts
    
    def get_load_score(self) -> float:
        """获取负载分数（用于决策）"""
        load_factors = [
            self.current_connections / 100.0,  # 连接数权重
            self.get_avg_response_time() / 1000.0,  # 响应时间权重
            (1.0 - self.get_success_rate()) * 0.1  # 错误率权重
        ]
        return sum(load_factors)

class RoundRobinStrategy(Enum):
    """轮询策略类型"""
    SIMPLE_ROUND_ROBIN = "simple"
    WEIGHTED_ROUND_ROBIN = "weighted"
    SMOOTH_ROUND_ROBIN = "smooth"  # 平滑加权轮询

class HealthCheckStatus(Enum):
    """健康检查状态"""
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"

@dataclass
class Request:
    """请求"""
    request_id: str
    timestamp: float
    method: str = "GET"
    path: str = "/"
    data: Dict[str, Any] = field(default_factory=dict)
    priority: int = 0  # 优先级，数字越大优先级越高
    
    def __lt__(self, other):
        """支持优先级排序"""
        return self.priority > other.priority

@dataclass
class LoadBalancerConfig:
    """负载均衡器配置"""
    algorithm: RoundRobinStrategy = RoundRobinStrategy.SIMPLE_ROUND_ROBIN
    health_check_interval: float = 30.0
    health_check_timeout: float = 5.0
    health_check_path: str = "/health"
    max_failure_count: int = 3
    recovery_threshold: int = 2  # 连续成功次数后标记为健康
    enable_failover: bool = True
    enable_circuit_breaker: bool = True
    circuit_breaker_failure_threshold: int = 5
    circuit_breaker_recovery_timeout: float = 60.0

class CircuitBreaker:
    """断路器实现"""
    
    def __init__(self, failure_threshold: int = 5, recovery_timeout: float = 60.0):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        
    def can_execute(self) -> bool:
        """检查是否可以执行请求"""
        current_time = time.time()
        
        if self.state == "OPEN":
            if self.last_failure_time and (current_time - self.last_failure_time) > self.recovery_timeout:
                self.state = "HALF_OPEN"
                return True
            return False
        elif self.state == "HALF_OPEN":
            return True
        else:  # CLOSED
            return True
    
    def record_success(self):
        """记录成功"""
        self.failure_count = 0
        if self.state == "HALF_OPEN":
            self.state = "CLOSED"
    
    def record_failure(self):
        """记录失败"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.failure_threshold:
            self.state = "OPEN"

class RoundRobinLoadBalancer:
    """Round Robin负载均衡器"""
    
    def __init__(self, config: LoadBalancerConfig = None):
        self.config = config or LoadBalancerConfig()
        self.servers: List[Server] = []
        self.current_index = 0
        self.request_stats: Dict[str, List[float]] = defaultdict(list)
        self.circuit_breakers: Dict[str, CircuitBreaker] = {}
        self.health_check_enabled = True
        self.mutex = threading.RLock()
        self.total_requests = 0
        self.start_time = time.time()
        
        # 设置日志
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger("RoundRobinLB")
    
    def add_server(self, server: Server):
        """添加服务器"""
        with self.mutex:
            self.servers.append(server)
            self.circuit_breakers[server.id] = CircuitBreaker(
                self.config.circuit_breaker_failure_threshold,
                self.config.circuit_breaker_recovery_timeout
            )
        
        self.logger.info(f"Added server: {server.hostname}:{server.port}")
    
    def remove_server(self, server_id: str):
        """移除服务器"""
        with self.mutex:
            self.servers = [s for s in self.servers if s.id != server_id]
            if server_id in self.circuit_breakers:
                del self.circuit_breakers[server_id]
        
        self.logger.info(f"Removed server: {server_id}")
    
    def get_next_server(self) -> Optional[Server]:
        """获取下一个服务器"""
        with self.mutex:
            healthy_servers = [s for s in self.servers if s.is_healthy]
            
            if not healthy_servers:
                self.logger.warning("No healthy servers available")
                return None
            
            # 应用轮询策略
            if self.config.algorithm == RoundRobinStrategy.SIMPLE_ROUND_ROBIN:
                return self._simple_round_robin(healthy_servers)
            elif self.config.algorithm == RoundRobinStrategy.WEIGHTED_ROUND_ROBIN:
                return self._weighted_round_robin(healthy_servers)
            elif self.config.algorithm == RoundRobinStrategy.SMOOTH_ROUND_ROBIN:
                return self._smooth_round_robin(healthy_servers)
            else:
                return self._simple_round_robin(healthy_servers)
    
    def _simple_round_robin(self, healthy_servers: List[Server]) -> Server:
        """简单轮询"""
        if len(healthy_servers) == 1:
            return healthy_servers[0]
        
        server = healthy_servers[self.current_index]
        self.current_index = (self.current_index + 1) % len(healthy_servers)
        return server
    
    def _weighted_round_robin(self, healthy_servers: List[Server]) -> Server:
        """加权轮询"""
        # 计算总权重
        total_weight = sum(server.weight for server in healthy_servers)
        
        if total_weight <= 0:
            return self._simple_round_robin(healthy_servers)
        
        # 生成随机数
        target_weight = random.uniform(0, total_weight)
        current_weight = 0
        
        # 按权重选择
        for server in healthy_servers:
            current_weight += server.weight
            if current_weight >= target_weight:
                return server
        
        return healthy_servers[-1]  # 兜底
    
    def _smooth_round_robin(self, healthy_servers: List[Server]) -> Server:
        """平滑加权轮询（类似Nginx）"""
        total_weight = sum(server.weight for server in healthy_servers)
        best_server = None
        max_current = float('-inf')
        
        for server in healthy_servers:
            server.current_weight += server.weight
            if server.current_weight > max_current:
                max_current = server.current_weight
                best_server = server
        
        if best_server:
            best_server.current_weight -= total_weight
        
        return best_server or healthy_servers[0]
    
    def health_check(self, server: Server) -> bool:
        """健康检查"""
        try:
            # 这里可以实际发送HTTP请求
            # 简化版：模拟检查
            time.sleep(self.config.health_check_timeout)
            
            # 模拟健康检查结果
            import random
            is_healthy = random.random() > 0.1  # 90%概率健康
            
            server.last_health_check = time.time()
            server.is_healthy = is_healthy
            
            if is_healthy:
                server.failure_count = max(0, server.failure_count - 1)
            else:
                server.failure_count += 1
            
            return is_healthy
            
        except Exception as e:
            self.logger.error(f"Health check failed for {server.hostname}: {str(e)}")
            server.is_healthy = False
            return False
    
    def start_health_checks(self):
        """启动健康检查"""
        def health_check_worker():
            while self.health_check_enabled:
                try:
                    with ThreadPoolExecutor(max_workers=5) as executor:
                        futures = {executor.submit(self.health_check, server): server 
                                  for server in self.servers}
                        
                        for future in as_completed(futures):
                            server = futures[future]
                            try:
                                future.result()
                            except Exception as e:
                                self.logger.error(f"Health check error for {server.hostname}: {str(e)}")
                    
                    time.sleep(self.config.health_check_interval)
                    
                except Exception as e:
                    self.logger.error(f"Health check worker error: {str(e)}")
                    time.sleep(5)
        
        health_thread = threading.Thread(target=health_check_worker, daemon=True)
        health_thread.start()
        self.logger.info("Health check worker started")
    
    def route_request(self, request: Request) -> Optional[Server]:
        """路由请求"""
        # 获取下一个服务器
        server = self.get_next_server()
        
        if not server:
            return None
        
        # 检查断路器
        circuit_breaker = self.circuit_breakers.get(server.id)
        if circuit_breaker and not circuit_breaker.can_execute():
            self.logger.warning(f"Circuit breaker open for {server.hostname}")
            if self.config.enable_failover:
                # 尝试其他健康服务器
                backup_servers = [s for s in self.servers if s.is_healthy and s.id != server.id]
                if backup_servers:
                    # 选择负载最小的备份服务器
                    server = min(backup_servers, key=lambda s: s.current_connections)
        
        # 更新统计信息
        with self.mutex:
            server.total_requests += 1
            self.total_requests += 1
        
        return server
    
    def record_response_time(self, server: Server, response_time: float):
        """记录响应时间"""
        with self.mutex:
            server.response_times.append(response_time)
            server.total_response_time += response_time
            
            # 记录到统计信息
            self.request_stats[server.id].append(response_time)
            
            # 更新连接计数（这里模拟）
            server.current_connections = max(0, server.current_connections - 1)
    
    def simulate_request(self, request: Request) -> Dict[str, Any]:
        """模拟请求处理"""
        start_time = time.time()
        
        # 路由请求
        server = self.route_request(request)
        
        if not server:
            return {
                "success": False,
                "error": "No available servers",
                "response_time": 0.0
            }
        
        # 模拟处理请求
        try:
            # 更新连接计数
            server.current_connections += 1
            
            # 模拟处理时间
            base_response_time = server.get_avg_response_time() if server.get_avg_response_time() > 0 else 100
            processing_time = random.uniform(base_response_time * 0.8, base_response_time * 1.2) / 1000
            
            time.sleep(processing_time)
            
            # 模拟成功率
            success_rate = server.get_success_rate()
            is_success = random.random() < success_rate
            
            # 更新统计
            if is_success:
                server.success_count += 1
            else:
                server.failure_count += 1
            
            response_time = time.time() - start_time
            
            # 更新断路器
            circuit_breaker = self.circuit_breakers.get(server.id)
            if circuit_breaker:
                if is_success:
                    circuit_breaker.record_success()
                else:
                    circuit_breaker.record_failure()
            
            self.record_response_time(server, response_time)
            
            return {
                "success": True,
                "server": server.hostname,
                "response_time": response_time,
                "processing_time": processing_time
            }
            
        except Exception as e:
            # 记录失败
            server.failure_count += 1
            
            circuit_breaker = self.circuit_breakers.get(server.id)
            if circuit_breaker:
                circuit_breaker.record_failure()
            
            return {
                "success": False,
                "error": str(e),
                "server": server.hostname,
                "response_time": time.time() - start_time
            }
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        with self.mutex:
            current_time = time.time()
            uptime = current_time - self.start_time
            
            server_stats = []
            for server in self.servers:
                server_stats.append({
                    "id": server.id,
                    "hostname": server.hostname,
                    "port": server.port,
                    "weight": server.weight,
                    "is_healthy": server.is_healthy,
                    "total_requests": server.total_requests,
                    "success_rate": server.get_success_rate(),
                    "avg_response_time": server.get_avg_response_time(),
                    "current_connections": server.current_connections,
                    "current_weight": getattr(server, 'current_weight', 0),
                    "load_score": server.get_load_score()
                })
            
            return {
                "total_servers": len(self.servers),
                "healthy_servers": len([s for s in self.servers if s.is_healthy]),
                "total_requests": self.total_requests,
                "uptime_seconds": uptime,
                "requests_per_second": self.total_requests / uptime if uptime > 0 else 0,
                "algorithm": self.config.algorithm.value,
                "servers": server_stats,
                "circuit_breaker_states": {
                    server_id: cb.state for server_id, cb in self.circuit_breakers.items()
                }
            }

class GoStyleRoundRobin:
    """Go风格的轮询负载均衡器"""
    
    def __init__(self, servers: List[Dict[str, Any]]):
        self.servers = [{"host": s["host"], "port": s["port"], "weight": s.get("weight", 1)} for s in servers]
        self.current = 0
        self.total_weight = sum(s["weight"] for s in self.servers)
    
    def GetNextServer(self) -> Dict[str, Any]:
        """获取下一个服务器（Go风格命名）"""
        if not self.servers:
            return None
        
        # 简单轮询
        server = self.servers[self.current]
        self.current = (self.current + 1) % len(self.servers)
        
        return server
    
    def GetWeightedNextServer(self) -> Dict[str, Any]:
        """获取下一个加权服务器"""
        if not self.servers:
            return None
        
        import random
        target = random.randint(1, self.total_weight)
        
        current_sum = 0
        for server in self.servers:
            current_sum += server["weight"]
            if current_sum >= target:
                return server
        
        return self.servers[-1]
    
    def ChannelBasedRoundRobin(self, server_count: int) -> List[Dict[str, Any]]:
        """基于通道的轮询（模拟Go的channel）"""
        servers = []
        
        for i in range(server_count):
            # 模拟向channel发送服务器
            server_idx = i % len(self.servers)
            servers.append(self.servers[server_idx])
        
        return servers

# 性能测试和基准测试
class LoadBalancerBenchmark:
    """负载均衡器性能基准测试"""
    
    def __init__(self, load_balancer: RoundRobinLoadBalancer):
        self.load_balancer = load_balancer
        self.benchmark_results = {}
    
    def run_concurrent_requests(self, num_requests: int, num_threads: int = 10):
        """运行并发请求测试"""
        import concurrent.futures
        import statistics
        
        print(f"Running benchmark: {num_requests} requests with {num_threads} threads")
        
        # 准备请求
        requests = [
            Request(
                request_id=f"req_{i}",
                timestamp=time.time(),
                method="GET",
                path="/",
                priority=0
            ) for i in range(num_requests)
        ]
        
        start_time = time.time()
        
        # 并发执行
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = {
                executor.submit(self.load_balancer.simulate_request, request): request 
                for request in requests
            }
            
            results = []
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                results.append(result)
        
        end_time = time.time()
        total_time = end_time - start_time
        
        # 分析结果
        successful_requests = [r for r in results if r["success"]]
        failed_requests = [r for r in results if not r["success"]]
        
        if successful_requests:
            response_times = [r["response_time"] for r in successful_requests]
            avg_response_time = statistics.mean(response_times)
            median_response_time = statistics.median(response_times)
            p95_response_time = sorted(response_times)[int(len(response_times) * 0.95)]
            p99_response_time = sorted(response_times)[int(len(response_times) * 0.99)]
        else:
            avg_response_time = median_response_time = p95_response_time = p99_response_time = 0
        
        self.benchmark_results = {
            "total_requests": num_requests,
            "successful_requests": len(successful_requests),
            "failed_requests": len(failed_requests),
            "success_rate": len(successful_requests) / num_requests,
            "total_time": total_time,
            "requests_per_second": num_requests / total_time,
            "avg_response_time": avg_response_time,
            "median_response_time": median_response_time,
            "p95_response_time": p95_response_time,
            "p99_response_time": p99_response_time
        }
        
        return self.benchmark_results
    
    def compare_algorithms(self, num_requests: int = 1000):
        """比较不同轮询算法"""
        algorithms = [
            RoundRobinStrategy.SIMPLE_ROUND_ROBIN,
            RoundRobinStrategy.WEIGHTED_ROUND_ROBIN,
            RoundRobinStrategy.SMOOTH_ROUND_ROBIN
        ]
        
        results = {}
        
        for algorithm in algorithms:
            print(f"Testing {algorithm.value} algorithm...")
            
            # 创建新的负载均衡器
            config = LoadBalancerConfig(algorithm=algorithm)
            lb = RoundRobinLoadBalancer(config)
            
            # 添加测试服务器
            test_servers = [
                Server(f"server_{i}", f"server{i}.example.com", 8080 + i, weight=1.0 + i * 0.5)
                for i in range(4)
            ]
            
            for server in test_servers:
                lb.add_server(server)
            
            # 运行基准测试
            benchmark = LoadBalancerBenchmark(lb)
            result = benchmark.run_concurrent_requests(num_requests)
            results[algorithm.value] = result
        
        return results
    
    def print_results(self):
        """打印测试结果"""
        if not self.benchmark_results:
            print("No benchmark results available. Run a benchmark first.")
            return
        
        print("\n=== Load Balancer Benchmark Results ===")
        print(f"Total Requests: {self.benchmark_results['total_requests']}")
        print(f"Success Rate: {self.benchmark_results['success_rate']:.2%}")
        print(f"Requests/Second: {self.benchmark_results['requests_per_second']:.2f}")
        print(f"Average Response Time: {self.benchmark_results['avg_response_time']*1000:.2f}ms")
        print(f"Median Response Time: {self.benchmark_results['median_response_time']*1000:.2f}ms")
        print(f"P95 Response Time: {self.benchmark_results['p95_response_time']*1000:.2f}ms")
        print(f"P99 Response Time: {self.benchmark_results['p99_response_time']*1000:.2f}ms")

# 主演示函数
def demo_round_robin_load_balancer():
    """主演示函数"""
    
    print("=== Round Robin Load Balancer Demo ===\n")
    
    # 1. 创建负载均衡器
    print("1. Setting up Load Balancer")
    print("="*40)
    
    config = LoadBalancerConfig(
        algorithm=RoundRobinStrategy.WEIGHTED_ROUND_ROBIN,
        health_check_interval=10.0,
        enable_failover=True,
        enable_circuit_breaker=True
    )
    
    load_balancer = RoundRobinLoadBalancer(config)
    
    # 添加测试服务器
    servers = [
        Server("server1", "webserver1.com", 8080, weight=1.0),
        Server("server2", "webserver2.com", 8080, weight=2.0),
        Server("server3", "webserver3.com", 8080, weight=3.0),
        Server("server4", "webserver4.com", 8080, weight=1.5)
    ]
    
    for server in servers:
        load_balancer.add_server(server)
    
    print(f"Added {len(servers)} servers to load balancer")
    
    # 2. 演示负载均衡
    print("\n2. Load Balancing Demonstration")
    print("="*40)
    
    # 创建测试请求
    test_requests = [
        Request(f"request_{i}", time.time(), "GET", f"/api/endpoint{i % 10}")
        for i in range(20)
    ]
    
    print("Routing 20 requests across servers...")
    
    server_usage = defaultdict(int)
    
    for request in test_requests:
        result = load_balancer.simulate_request(request)
        if result["success"]:
            server_usage[result["server"]] += 1
    
    print("\nServer usage distribution:")
    for server, count in server_usage.items():
        percentage = (count / len(test_requests)) * 100
        print(f"  {server}: {count} requests ({percentage:.1f}%)")
    
    # 3. 健康检查演示
    print("\n3. Health Check Demonstration")
    print("="*40)
    
    # 手动标记一个服务器为不健康
    unhealthy_server = servers[1]  # server2
    unhealthy_server.is_healthy = False
    print(f"Marked {unhealthy_server.hostname} as unhealthy")
    
    # 测试在 unhealthy 服务器存在时的负载均衡
    server_usage_after_failure = defaultdict(int)
    
    for request in test_requests:
        result = load_balancer.simulate_request(request)
        if result["success"]:
            server_usage_after_failure[result["server"]] += 1
    
    print("\nServer usage after marking one server unhealthy:")
    for server, count in server_usage_after_failure.items():
        percentage = (count / len(test_requests)) * 100
        print(f"  {server}: {count} requests ({percentage:.1f}%)")
    
    # 4. 性能基准测试
    print("\n4. Performance Benchmark")
    print("="*40)
    
    benchmark = LoadBalancerBenchmark(load_balancer)
    
    # 恢复服务器健康状态
    unhealthy_server.is_healthy = True
    
    # 运行基准测试
    results = benchmark.run_concurrent_requests(1000, num_threads=20)
    benchmark.print_results()
    
    # 5. 算法比较
    print("\n5. Algorithm Comparison")
    print("="*40)
    
    algorithm_results = benchmark.compare_algorithms(num_requests=500)
    
    print("\nAlgorithm Performance Comparison:")
    print(f"{'Algorithm':<20} {'RPS':<10} {'Avg RT (ms)':<15} {'Success Rate':<12}")
    print("-" * 60)
    
    for algorithm, result in algorithm_results.items():
        rps = result['requests_per_second']
        avg_rt = result['avg_response_time'] * 1000
        success_rate = result['success_rate']
        
        print(f"{algorithm:<20} {rps:<10.2f} {avg_rt:<15.2f} {success_rate:<12.2%}")
    
    # 6. 统计信息
    print("\n6. Detailed Statistics")
    print("="*40)
    
    stats = load_balancer.get_statistics()
    
    print(f"Total servers: {stats['total_servers']}")
    print(f"Healthy servers: {stats['healthy_servers']}")
    print(f"Total requests processed: {stats['total_requests']}")
    print(f"Requests per second: {stats['requests_per_second']:.2f}")
    print(f"Uptime: {stats['uptime_seconds']:.0f} seconds")
    
    print("\nServer Details:")
    for server_stat in stats['servers']:
        print(f"  {server_stat['hostname']}:{server_stat['port']}")
        print(f"    Weight: {server_stat['weight']}")
        print(f"    Healthy: {server_stat['is_healthy']}")
        print(f"    Requests: {server_stat['total_requests']}")
        print(f"    Success Rate: {server_stat['success_rate']:.2%}")
        print(f"    Avg Response Time: {server_stat['avg_response_time']*1000:.2f}ms")
        print(f"    Current Weight: {server_stat['current_weight']}")
        print(f"    Load Score: {server_stat['load_score']:.3f}")
        print()
    
    # 7. Go风格实现演示
    print("7. Go-Style Implementation")
    print("="*40)
    
    go_servers = [
        {"host": "go-server1", "port": 8080, "weight": 1},
        {"host": "go-server2", "port": 8080, "weight": 2},
        {"host": "go-server3", "port": 8080, "weight": 3}
    ]
    
    go_lb = GoStyleRoundRobin(go_servers)
    
    print("Go-style round-robin server selection:")
    for i in range(10):
        server = go_lb.GetNextServer()
        print(f"  Request {i+1}: {server['host']}:{server['port']}")
    
    print("\nGo-style weighted round-robin:")
    for i in range(10):
        server = go_lb.GetWeightedNextServer()
        print(f"  Request {i+1}: {server['host']}:{server['port']}")
    
    print("\n=== Round Robin Load Balancer Summary ===")
    print("Round Robin Algorithm provides:")
    print("• Simple and fair distribution")
    print("• Equal treatment of all servers (basic version)")
    print("• Weighted distribution (with weights)")
    print("• Smooth weighted distribution (Nginx-style)")
    print("\nAdvantages:")
    print("• Easy to implement and understand")
    print("• Low computational overhead")
    print("• No state synchronization issues")
    print("• Good for homogeneous servers")
    print("\nDisadvantages:")
    print("• Assumes equal server capacity")
    print("• No consideration for server load")
    print("• Not adaptive to real-time conditions")
    print("\nBest for:")
    print("• Static server environments")
    print("• Homogeneous server capacity")
    print("• Simple load balancing needs")
    print("• High-throughput, low-latency requirements")

if __name__ == "__main__":
    demo_round_robin_load_balancer()