# 设计原则在大型系统架构中的实践

## 概述

本文档深入探讨SOLID原则在大型分布式系统架构中的具体实践，通过真实的业务场景和完整的代码实现，展示如何将这些原则应用于复杂的企业级系统设计中。每个原则都将通过具体的架构决策和实现细节来体现其实际价值。

## 电商平台架构中的SOLID原则实践

### 业务背景

我们正在构建一个大型电商平台，需要支持千万级用户、亿级商品、每日千万级订单。系统需要具备高可用、高并发、高扩展性，同时要支持快速迭代和持续交付。

### 系统架构概览

```
用户层 → API网关 → 业务服务层 → 数据访问层 → 数据存储层
  ↓         ↓         ↓         ↓         ↓
CDN/负载均衡 → 限流熔断 → 微服务集群 → 缓存层 → 分布式数据库
```

### 单一职责原则（SRP）的深度实践

#### 服务拆分策略

**问题分析**：
在单体架构中，用户服务既处理用户认证、又处理用户信息管理、还处理用户行为统计、优惠券发放等功能，导致职责混乱，难以维护和扩展。

**解决方案**：
按照业务域边界进行微服务拆分，每个服务只负责一个明确的业务领域。

**架构实现**：

```python
# 用户中心服务 - 仅处理用户相关业务
from abc import ABC, abstractmethod
from typing import List, Optional
import asyncio

# 用户信息接口
class UserInfoService(ABC):
    @abstractmethod
    async def get_user_by_id(self, user_id: str) -> Optional[Dict]:
        pass
    
    @abstractmethod
    async def update_user_profile(self, user_id: str, profile_data: Dict) -> bool:
        pass
    
    @abstractmethod
    async def list_users_by_criteria(self, criteria: Dict) -> List[Dict]:
        pass

# 用户认证接口
class UserAuthService(ABC):
    @abstractmethod
    async def authenticate(self, credentials: Dict) -> Optional[str]:
        pass
    
    @abstractmethod
    async def validate_token(self, token: str) -> Optional[Dict]:
        pass
    
    @abstractmethod
    async def refresh_token(self, refresh_token: str) -> Optional[str]:
        pass

# 用户行为统计服务 - 独立的服务
class UserAnalyticsService(ABC):
    @abstractmethod
    async def track_user_action(self, user_id: str, action: str, metadata: Dict) -> bool:
        pass
    
    @abstractmethod
    async def get_user_behavior_report(self, user_id: str, time_range: Dict) -> Dict:
        pass

# 用户服务组合 - 协调多个专门服务
class UserFacade:
    def __init__(self, 
                 user_info_service: UserInfoService,
                 user_auth_service: UserAuthService,
                 user_analytics_service: UserAnalyticsService):
        self.user_info_service = user_info_service
        self.user_auth_service = user_auth_service
        self.user_analytics_service = user_analytics_service
    
    async def login(self, credentials: Dict) -> Dict:
        """登录流程 - 协调多个服务的使用"""
        # 1. 认证
        token = await self.user_auth_service.authenticate(credentials)
        if not token:
            raise Exception("认证失败")
        
        # 2. 获取用户信息
        user_info = await self.user_info_service.get_user_by_id(credentials['user_id'])
        
        # 3. 记录登录行为
        await self.user_analytics_service.track_user_action(
            credentials['user_id'], 
            'login',
            {'timestamp': asyncio.get_event_loop().time()}
        )
        
        return {
            'token': token,
            'user_info': user_info
        }
```

#### 优势分析

1. **服务独立演进**：每个服务可以独立开发、测试、部署
2. **技术栈灵活**：不同的服务可以选择最适合的技术栈
3. **团队自治**：不同的团队可以负责不同的服务领域
4. **故障隔离**：单个服务故障不影响其他服务

### 开闭原则（OCP）的深度实践

#### 插件化支付系统架构

**问题分析**：
电商平台需要支持多种支付方式（信用卡、支付宝、微信支付、数字货币等），而且新的支付方式会不断出现。传统的if-else架构会导致系统频繁修改，引入风险。

**解决方案**：
采用插件化架构，使用策略模式和工厂模式，支持新支付方式的动态扩展。

**架构实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Type
import importlib
import inspect

# 支付方式抽象接口
class PaymentMethod(ABC):
    @abstractmethod
    async def process_payment(self, payment_request: Dict) -> Dict:
        """处理支付"""
        pass
    
    @abstractmethod
    def validate_payment_request(self, request: Dict) -> bool:
        """验证支付请求"""
        pass
    
    @property
    @abstractmethod
    def payment_type(self) -> str:
        """支付方式类型"""
        pass
    
    @property
    @abstractmethod
    def supported_currencies(self) -> List[str]:
        """支持的货币"""
        pass

# 信用卡支付实现
class CreditCardPayment(PaymentMethod):
    def __init__(self, config: Dict):
        self.config = config
        self.api_endpoint = config.get('api_endpoint')
        self.merchant_id = config.get('merchant_id')
    
    async def process_payment(self, payment_request: Dict) -> Dict:
        """信用卡支付处理"""
        print(f"处理信用卡支付: {payment_request['amount']} {payment_request['currency']}")
        
        # 1. 验证支付请求
        if not self.validate_payment_request(payment_request):
            raise ValueError("支付请求验证失败")
        
        # 2. 调用支付API（模拟）
        await asyncio.sleep(0.5)  # 模拟网络延迟
        
        # 3. 返回支付结果
        return {
            'success': True,
            'transaction_id': f"cc_{int(asyncio.get_event_loop().time())}",
            'amount': payment_request['amount'],
            'currency': payment_request['currency'],
            'timestamp': asyncio.get_event_loop().time()
        }
    
    def validate_payment_request(self, request: Dict) -> bool:
        required_fields = ['amount', 'currency', 'card_number', 'cvv']
        return all(field in request for field in required_fields)
    
    @property
    def payment_type(self) -> str:
        return "credit_card"
    
    @property
    def supported_currencies(self) -> List[str]:
        return ["USD", "EUR", "CNY"]

# 支付宝支付实现
class AlipayPayment(PaymentMethod):
    def __init__(self, config: Dict):
        self.config = config
        self.app_id = config.get('app_id')
        self.private_key = config.get('private_key')
    
    async def process_payment(self, payment_request: Dict) -> Dict:
        """支付宝支付处理"""
        print(f"处理支付宝支付: {payment_request['amount']} {payment_request['currency']}")
        
        # 1. 验证支付请求
        if not self.validate_payment_request(payment_request):
            raise ValueError("支付请求验证失败")
        
        # 2. 生成支付二维码（模拟）
        await asyncio.sleep(0.3)
        
        # 3. 返回支付信息
        return {
            'success': True,
            'payment_url': f"https://qr.alipay.com/{int(asyncio.get_event_loop().time())}",
            'transaction_id': f"alipay_{int(asyncio.get_event_loop().time())}",
            'amount': payment_request['amount'],
            'currency': payment_request['currency'],
            'timestamp': asyncio.get_event_loop().time()
        }
    
    def validate_payment_request(self, request: Dict) -> bool:
        required_fields = ['amount', 'currency', 'user_id']
        return all(field in request for field in required_fields)
    
    @property
    def payment_type(self) -> str:
        return "alipay"
    
    @property
    def supported_currencies(self) -> List[str]:
        return ["CNY"]

# 微信支付实现
class WeChatPayPayment(PaymentMethod):
    def __init__(self, config: Dict):
        self.config = config
        self.mch_id = config.get('mch_id')
        self.api_key = config.get('api_key')
    
    async def process_payment(self, payment_request: Dict) -> Dict:
        """微信支付处理"""
        print(f"处理微信支付: {payment_request['amount']} {payment_request['currency']}")
        
        await asyncio.sleep(0.4)
        
        return {
            'success': True,
            'code_url': f"weixin://wxpay/bizpayurl?pr={int(asyncio.get_event_loop().time())}",
            'transaction_id': f"wechat_{int(asyncio.get_event_loop().time())}",
            'amount': payment_request['amount'],
            'currency': payment_request['currency'],
            'timestamp': asyncio.get_event_loop().time()
        }
    
    def validate_payment_request(self, request: Dict) -> bool:
        required_fields = ['amount', 'currency', 'openid']
        return all(field in request for field in required_fields)
    
    @property
    def payment_type(self) -> str:
        return "wechat_pay"
    
    @property
    def supported_currencies(self) -> List[str]:
        return ["CNY"]

# 支付方式管理器 - 支持动态扩展
class PaymentMethodManager:
    def __init__(self):
        self.payment_methods: Dict[str, PaymentMethod] = {}
        self.plugin_directory = "payment_plugins"  # 插件目录
    
    def register_payment_method(self, payment_method: PaymentMethod):
        """注册支付方式"""
        self.payment_methods[payment_method.payment_type] = payment_method
        print(f"注册支付方式: {payment_method.payment_type}")
    
    def unregister_payment_method(self, payment_type: str):
        """注销支付方式"""
        if payment_type in self.payment_methods:
            del self.payment_methods[payment_type]
            print(f"注销支付方式: {payment_type}")
    
    async def process_payment(self, payment_type: str, payment_request: Dict) -> Dict:
        """处理支付"""
        payment_method = self.payment_methods.get(payment_type)
        if not payment_method:
            raise ValueError(f"不支持的支付方式: {payment_type}")
        
        return await payment_method.process_payment(payment_request)
    
    def load_payment_plugins(self):
        """动态加载支付插件"""
        try:
            # 模拟从插件目录加载
            plugin_classes = [
                CreditCardPayment,
                AlipayPayment,
                WeChatPayPayment
            ]
            
            for plugin_class in plugin_classes:
                # 检查是否是PaymentMethod的子类
                if issubclass(plugin_class, PaymentMethod):
                    # 创建插件实例（需要配置）
                    config = self._get_plugin_config(plugin_class)
                    if config:
                        plugin_instance = plugin_class(config)
                        self.register_payment_method(plugin_instance)
                        
        except Exception as e:
            print(f"加载支付插件失败: {e}")
    
    def _get_plugin_config(self, plugin_class: Type[PaymentMethod]) -> Dict:
        """获取插件配置（简化实现）"""
        # 在实际应用中，这里会从配置文件或数据库中读取配置
        return {
            'api_endpoint': 'https://api.example.com',
            'merchant_id': 'test_merchant',
            'app_id': 'test_app_id',
            'private_key': 'test_private_key',
            'mch_id': 'test_mch_id',
            'api_key': 'test_api_key'
        }
    
    def get_supported_payment_methods(self) -> List[str]:
        """获取支持的支付方式列表"""
        return list(self.payment_methods.keys())
    
    def get_payment_method_info(self, payment_type: str) -> Dict:
        """获取支付方式详细信息"""
        payment_method = self.payment_methods.get(payment_type)
        if not payment_method:
            return {}
        
        return {
            'type': payment_method.payment_type,
            'supported_currencies': payment_method.supported_currencies
        }

# 支付系统工厂
class PaymentSystemFactory:
    def __init__(self):
        self.payment_managers = {}
    
    def create_payment_system(self, system_id: str) -> PaymentMethodManager:
        """创建支付系统实例"""
        if system_id not in self.payment_managers:
            self.payment_managers[system_id] = PaymentMethodManager()
        return self.payment_managers[system_id]
    
    def get_payment_system(self, system_id: str) -> PaymentMethodManager:
        """获取支付系统实例"""
        return self.payment_managers.get(system_id)
```

#### 优势分析

1. **新支付方式扩展**：只需实现PaymentMethod接口，无需修改现有代码
2. **运行时动态加载**：支持插件热插拔
3. **配置驱动**：通过配置文件控制启用的支付方式
4. **版本兼容**：新旧支付方式可以共存

### 里氏替换原则（LSP）的深度实践

#### 数据库访问层设计

**问题分析**：
电商平台需要同时支持MySQL、MongoDB、Redis等多种数据存储系统，并且可能在不同的发展阶段选择不同的存储方案。系统设计必须支持无缝切换。

**解决方案**：
设计统一的数据访问接口，不同的存储系统实现相同的接口，保证LSP原则。

**架构实现**：

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Any
import asyncio

# 商品数据模型
class Product:
    def __init__(self, product_id: str, name: str, price: float, category: str):
        self.product_id = product_id
        self.name = name
        self.price = price
        self.category = category
    
    def to_dict(self) -> Dict:
        return {
            'product_id': self.product_id,
            'name': self.name,
            'price': self.price,
            'category': self.category
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'Product':
        return cls(
            data['product_id'],
            data['name'],
            data['price'],
            data['category']
        )

# 商品仓储接口 - 抽象定义
class ProductRepository(ABC):
    @abstractmethod
    async def get_by_id(self, product_id: str) -> Optional[Product]:
        """根据ID获取商品"""
        pass
    
    @abstractmethod
    async def save(self, product: Product) -> bool:
        """保存商品"""
        pass
    
    @abstractmethod
    async def delete(self, product_id: str) -> bool:
        """删除商品"""
        pass
    
    @abstractmethod
    async def find_by_category(self, category: str) -> List[Product]:
        """根据分类查询商品"""
        pass
    
    @abstractmethod
    async def find_by_price_range(self, min_price: float, max_price: float) -> List[Product]:
        """根据价格范围查询商品"""
        pass
    
    @abstractmethod
    async def update_stock(self, product_id: str, quantity: int) -> bool:
        """更新库存"""
        pass

# MySQL实现
class MySQLProductRepository(ProductRepository):
    def __init__(self, connection_pool: Any):
        self.connection_pool = connection_pool
    
    async def get_by_id(self, product_id: str) -> Optional[Product]:
        """从MySQL获取商品"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "SELECT product_id, name, price, category FROM products WHERE product_id = %s",
                (product_id,)
            )
            row = await cursor.fetchone()
            
            if row:
                return Product(*row)
            return None
            
        finally:
            await connection.close()
    
    async def save(self, product: Product) -> bool:
        """保存商品到MySQL"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "INSERT INTO products (product_id, name, price, category) VALUES (%s, %s, %s, %s) ON DUPLICATE KEY UPDATE name=VALUES(name), price=VALUES(price), category=VALUES(category)",
                (product.product_id, product.name, product.price, product.category)
            )
            await connection.commit()
            return True
            
        except Exception as e:
            print(f"保存商品失败: {e}")
            return False
            
        finally:
            await connection.close()
    
    async def delete(self, product_id: str) -> bool:
        """从MySQL删除商品"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "DELETE FROM products WHERE product_id = %s",
                (product_id,)
            )
            await connection.commit()
            return cursor.rowcount > 0
            
        finally:
            await connection.close()
    
    async def find_by_category(self, category: str) -> List[Product]:
        """从MySQL根据分类查询商品"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "SELECT product_id, name, price, category FROM products WHERE category = %s",
                (category,)
            )
            rows = await cursor.fetchall()
            
            return [Product(*row) for row in rows]
            
        finally:
            await connection.close()
    
    async def find_by_price_range(self, min_price: float, max_price: float) -> List[Product]:
        """从MySQL根据价格范围查询商品"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "SELECT product_id, name, price, category FROM products WHERE price BETWEEN %s AND %s",
                (min_price, max_price)
            )
            rows = await cursor.fetchall()
            
            return [Product(*row) for row in rows]
            
        finally:
            await connection.close()
    
    async def update_stock(self, product_id: str, quantity: int) -> bool:
        """更新MySQL商品库存"""
        connection = await self.connection_pool.acquire()
        try:
            cursor = await connection.cursor()
            await cursor.execute(
                "UPDATE products SET stock = %s WHERE product_id = %s",
                (quantity, product_id)
            )
            await connection.commit()
            return cursor.rowcount > 0
            
        finally:
            await connection.close()

# MongoDB实现
class MongoDBProductRepository(ProductRepository):
    def __init__(self, database: Any):
        self.database = database
        self.collection = database.products
    
    async def get_by_id(self, product_id: str) -> Optional[Product]:
        """从MongoDB获取商品"""
        document = await self.collection.find_one({'product_id': product_id})
        
        if document:
            return Product.from_dict(document)
        return None
    
    async def save(self, product: Product) -> bool:
        """保存商品到MongoDB"""
        try:
            await self.collection.replace_one(
                {'product_id': product.product_id},
                product.to_dict(),
                upsert=True
            )
            return True
            
        except Exception as e:
            print(f"保存商品失败: {e}")
            return False
    
    async def delete(self, product_id: str) -> bool:
        """从MongoDB删除商品"""
        try:
            result = await self.collection.delete_one({'product_id': product_id})
            return result.deleted_count > 0
            
        except Exception as e:
            print(f"删除商品失败: {e}")
            return False
    
    async def find_by_category(self, category: str) -> List[Product]:
        """从MongoDB根据分类查询商品"""
        cursor = self.collection.find({'category': category})
        documents = await cursor.to_list(length=None)
        
        return [Product.from_dict(doc) for doc in documents]
    
    async def find_by_price_range(self, min_price: float, max_price: float) -> List[Product]:
        """从MongoDB根据价格范围查询商品"""
        cursor = self.collection.find({
            'price': {'$gte': min_price, '$lte': max_price}
        })
        documents = await cursor.to_list(length=None)
        
        return [Product.from_dict(doc) for doc in documents]
    
    async def update_stock(self, product_id: str, quantity: int) -> bool:
        """更新MongoDB商品库存"""
        try:
            result = await self.collection.update_one(
                {'product_id': product_id},
                {'$set': {'stock': quantity}}
            )
            return result.modified_count > 0
            
        except Exception as e:
            print(f"更新库存失败: {e}")
            return False

# Redis缓存实现
class RedisProductRepository(ProductRepository):
    def __init__(self, redis_client: Any):
        self.redis_client = redis_client
    
    async def get_by_id(self, product_id: str) -> Optional[Product]:
        """从Redis获取商品"""
        try:
            data = await self.redis_client.get(f"product:{product_id}")
            if data:
                import json
                product_dict = json.loads(data)
                return Product.from_dict(product_dict)
            return None
            
        except Exception as e:
            print(f"从Redis获取商品失败: {e}")
            return None
    
    async def save(self, product: Product) -> bool:
        """保存商品到Redis"""
        try:
            import json
            data = json.dumps(product.to_dict())
            await self.redis_client.setex(
                f"product:{product.product_id}",
                3600,  # 1小时过期
                data
            )
            return True
            
        except Exception as e:
            print(f"保存商品到Redis失败: {e}")
            return False
    
    async def delete(self, product_id: str) -> bool:
        """从Redis删除商品"""
        try:
            result = await self.redis_client.delete(f"product:{product_id}")
            return result > 0
            
        except Exception as e:
            print(f"从Redis删除商品失败: {e}")
            return False
    
    async def find_by_category(self, category: str) -> List[Product]:
        """从Redis根据分类查询商品（简化实现）"""
        # Redis不擅长范围查询，这里简化处理
        return []
    
    async def find_by_price_range(self, min_price: float, max_price: float) -> List[Product]:
        """从Redis根据价格范围查询商品（简化实现）"""
        return []
    
    async def update_stock(self, product_id: str, quantity: int) -> bool:
        """更新Redis商品库存"""
        try:
            # 先获取现有商品
            product = await self.get_by_id(product_id)
            if product:
                product.stock = quantity
                return await self.save(product)
            return False
            
        except Exception as e:
            print(f"更新Redis库存失败: {e}")
            return False

# 商品服务 - 支持存储后端切换
class ProductService:
    def __init__(self, product_repository: ProductRepository):
        self.product_repository = product_repository
    
    async def create_product(self, product_id: str, name: str, price: float, category: str) -> Product:
        """创建商品"""
        product = Product(product_id, name, price, category)
        success = await self.product_repository.save(product)
        
        if not success:
            raise Exception("创建商品失败")
        
        return product
    
    async def get_product(self, product_id: str) -> Optional[Product]:
        """获取商品"""
        return await self.product_repository.get_by_id(product_id)
    
    async def update_product_price(self, product_id: str, new_price: float) -> bool:
        """更新商品价格"""
        product = await self.product_repository.get_by_id(product_id)
        if not product:
            return False
        
        product.price = new_price
        return await self.product_repository.save(product)
    
    async def search_products(self, category: str = None, min_price: float = None, max_price: float = None) -> List[Product]:
        """搜索商品"""
        if category:
            return await self.product_repository.find_by_category(category)
        elif min_price is not None and max_price is not None:
            return await self.product_repository.find_by_price_range(min_price, max_price)
        else:
            return []

# 配置管理器 - 动态选择存储后端
class StorageConfigManager:
    def __init__(self):
        self.configurations = {
            'mysql': {
                'host': 'localhost',
                'port': 3306,
                'database': 'ecommerce',
                'user': 'root',
                'password': 'password'
            },
            'mongodb': {
                'host': 'localhost',
                'port': 27017,
                'database': 'ecommerce'
            },
            'redis': {
                'host': 'localhost',
                'port': 6379,
                'database': 0
            }
        }
    
    def get_repository_config(self, storage_type: str, **kwargs) -> Dict:
        """获取仓储配置"""
        base_config = self.configurations.get(storage_type, {})
        base_config.update(kwargs)
        return base_config
    
    def register_storage_type(self, storage_type: str, config: Dict):
        """注册新的存储类型"""
        self.configurations[storage_type] = config

# 仓储工厂
class RepositoryFactory:
    def __init__(self, config_manager: StorageConfigManager):
        self.config_manager = config_manager
        self.repositories = {}
    
    def create_product_repository(self, storage_type: str, **kwargs) -> ProductRepository:
        """创建商品仓储"""
        config = self.config_manager.get_repository_config(storage_type, **kwargs)
        
        if storage_type == 'mysql':
            # 假设有MySQL连接池
            connection_pool = self._create_mysql_pool(config)
            return MySQLProductRepository(connection_pool)
            
        elif storage_type == 'mongodb':
            # 假设有MongoDB连接
            database = self._create_mongodb_connection(config)
            return MongoDBProductRepository(database)
            
        elif storage_type == 'redis':
            # 假设有Redis连接
            redis_client = self._create_redis_client(config)
            return RedisProductRepository(redis_client)
            
        else:
            raise ValueError(f"不支持的存储类型: {storage_type}")
    
    def _create_mysql_pool(self, config: Dict):
        """创建MySQL连接池（模拟）"""
        # 在实际应用中，这里会创建真正的连接池
        return MockConnectionPool()
    
    def _create_mongodb_connection(self, config: Dict):
        """创建MongoDB连接（模拟）"""
        # 在实际应用中，这里会创建真正的MongoDB连接
        return MockMongoDB()
    
    def _create_redis_client(self, config: Dict):
        """创建Redis客户端（模拟）"""
        # 在实际应用中，这里会创建真正的Redis客户端
        return MockRedis()

# 模拟连接类
class MockConnectionPool:
    async def acquire(self):
        return MockConnection()

class MockConnection:
    async def cursor(self):
        return MockCursor()
    
    async def close(self):
        pass

class MockCursor:
    async def execute(self, query, params):
        pass
    
    async def fetchone(self):
        pass
    
    async def fetchall(self):
        return []
    
    @property
    def rowcount(self):
        return 1
    
    async def commit(self):
        pass

class MockMongoDB:
    def __init__(self):
        self.collections = {'products': MockCollection()}

class MockCollection:
    def __init__(self):
        self.data = {}
    
    async def find_one(self, query):
        return None
    
    async def find(self, query):
        return MockCursor()
    
    async def replace_one(self, filter, replacement, upsert):
        return MockUpdateResult()
    
    async def delete_one(self, filter):
        return MockDeleteResult()
    
    async def update_one(self, filter, update):
        return MockUpdateResult()

class MockUpdateResult:
    def __init__(self):
        self.modified_count = 1

class MockDeleteResult:
    def __init__(self):
        self.deleted_count = 1

class MockRedis:
    async def get(self, key):
        return None
    
    async def setex(self, key, ttl, value):
        pass
    
    async def delete(self, key):
        return 0
```

#### 优势分析

1. **无缝切换**：可以在运行时切换不同的存储后端
2. **测试友好**：可以使用Mock对象进行单元测试
3. **渐进式迁移**：可以平滑地从一种存储迁移到另一种
4. **性能优化**：可以根据访问模式选择最适合的存储

### 接口隔离原则（ISP）的深度实践

#### 用户权限管理系统

**问题分析**：
电商平台有多种用户角色（普通用户、VIP用户、商家、管理员），每个角色需要不同的权限。如果使用单一的权限接口，会导致接口臃肿，客户端被迫依赖不需要的方法。

**解决方案**：
将大接口拆分为多个专门的接口，每个客户端只依赖它需要的接口。

**架构实现**：

```python
from abc import ABC, abstractmethod
from typing import List, Dict, Optional
import asyncio

# 用户角色
class UserRole(Enum):
    CUSTOMER = "customer"
    VIP_CUSTOMER = "vip_customer"
    MERCHANT = "merchant"
    ADMIN = "admin"
    SUPER_ADMIN = "super_admin"

# 权限枚举
class Permission(Enum):
    # 商品相关权限
    VIEW_PRODUCT = "view_product"
    CREATE_PRODUCT = "create_product"
    EDIT_PRODUCT = "edit_product"
    DELETE_PRODUCT = "delete_product"
    
    # 订单相关权限
    VIEW_ORDER = "view_order"
    CREATE_ORDER = "create_order"
    CANCEL_ORDER = "cancel_order"
    PROCESS_ORDER = "process_order"
    
    # 用户相关权限
    VIEW_USER_PROFILE = "view_user_profile"
    EDIT_USER_PROFILE = "edit_user_profile"
    MANAGE_USERS = "manage_users"
    
    # 系统管理权限
    SYSTEM_CONFIG = "system_config"
    VIEW_ANALYTICS = "view_analytics"
    MANAGE_MERCHANTS = "manage_merchants"

# 基础权限查询接口
class PermissionQueryInterface(ABC):
    @abstractmethod
    async def has_permission(self, user_id: str, permission: Permission) -> bool:
        """检查用户是否有指定权限"""
        pass
    
    @abstractmethod
    async def get_user_permissions(self, user_id: str) -> List[Permission]:
        """获取用户所有权限"""
        pass

# 管理员权限接口
class AdminPermissionInterface(ABC):
    @abstractmethod
    async def grant_permission(self, admin_id: str, target_user_id: str, permission: Permission) -> bool:
        """授权权限"""
        pass
    
    @abstractmethod
    async def revoke_permission(self, admin_id: str, target_user_id: str, permission: Permission) -> bool:
        """撤销权限"""
        pass
    
    @abstractmethod
    async def get_all_users_permissions(self) -> Dict[str, List[Permission]]:
        """获取所有用户权限"""
        pass

# 商家权限接口
class MerchantPermissionInterface(ABC):
    @abstractmethod
    async def can_manage_products(self, merchant_id: str) -> bool:
        """检查是否可以管理商品"""
        pass
    
    @abstractmethod
    async def can_view_orders(self, merchant_id: str) -> bool:
        """检查是否可以查看订单"""
        pass
    
    @abstractmethod
    async def get_merchant_orders(self, merchant_id: str, status: str = None) -> List[Dict]:
        """获取商家订单"""
        pass

# 客户服务接口
class CustomerPermissionInterface(ABC):
    @abstractmethod
    async def can_create_order(self, customer_id: str) -> bool:
        """检查是否可以创建订单"""
        pass
    
    @abstractmethod
    async def can_view_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以查看订单"""
        pass
    
    @abstractmethod
    async def can_cancel_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以取消订单"""
        pass

# 权限存储实现
class PermissionRepository:
    def __init__(self):
        # 模拟数据库存储
        self.user_permissions = {}
        self.role_permissions = {
            UserRole.CUSTOMER: [Permission.VIEW_PRODUCT, Permission.CREATE_ORDER],
            UserRole.VIP_CUSTOMER: [Permission.VIEW_PRODUCT, Permission.CREATE_ORDER, Permission.VIEW_ORDER],
            UserRole.MERCHANT: [Permission.VIEW_PRODUCT, Permission.CREATE_PRODUCT, Permission.EDIT_PRODUCT, Permission.VIEW_ORDER, Permission.PROCESS_ORDER],
            UserRole.ADMIN: [Permission.VIEW_PRODUCT, Permission.CREATE_PRODUCT, Permission.EDIT_PRODUCT, Permission.DELETE_PRODUCT, Permission.VIEW_ORDER, Permission.PROCESS_ORDER, Permission.MANAGE_USERS, Permission.VIEW_ANALYTICS],
            UserRole.SUPER_ADMIN: list(Permission)  # 所有权限
        }
        self.user_roles = {}
    
    async def get_user_role(self, user_id: str) -> UserRole:
        """获取用户角色"""
        return self.user_roles.get(user_id, UserRole.CUSTOMER)
    
    async def set_user_role(self, user_id: str, role: UserRole):
        """设置用户角色"""
        self.user_roles[user_id] = role
    
    async def get_user_permissions(self, user_id: str) -> List[Permission]:
        """获取用户权限"""
        role = await self.get_user_role(user_id)
        base_permissions = self.role_permissions.get(role, [])
        
        # 获取额外的个人权限
        additional_permissions = self.user_permissions.get(user_id, [])
        
        return list(set(base_permissions + additional_permissions))

# 综合权限服务实现
class ComprehensivePermissionService(
    PermissionQueryInterface,
    AdminPermissionInterface,
    MerchantPermissionInterface,
    CustomerPermissionInterface
):
    def __init__(self, permission_repository: PermissionRepository):
        self.repository = permission_repository
    
    # PermissionQueryInterface 实现
    async def has_permission(self, user_id: str, permission: Permission) -> bool:
        """检查用户是否有指定权限"""
        user_permissions = await self.repository.get_user_permissions(user_id)
        return permission in user_permissions
    
    async def get_user_permissions(self, user_id: str) -> List[Permission]:
        """获取用户所有权限"""
        return await self.repository.get_user_permissions(user_id)
    
    # AdminPermissionInterface 实现
    async def grant_permission(self, admin_id: str, target_user_id: str, permission: Permission) -> bool:
        """授权权限"""
        # 检查管理员权限
        if not await self.has_permission(admin_id, Permission.MANAGE_USERS):
            return False
        
        # 获取目标用户当前权限
        user_permissions = set(await self.repository.get_user_permissions(target_user_id))
        user_permissions.add(permission)
        
        # 存储权限（简化实现）
        if target_user_id not in self.repository.user_permissions:
            self.repository.user_permissions[target_user_id] = []
        self.repository.user_permissions[target_user_id].append(permission)
        
        return True
    
    async def revoke_permission(self, admin_id: str, target_user_id: str, permission: Permission) -> bool:
        """撤销权限"""
        # 检查管理员权限
        if not await self.has_permission(admin_id, Permission.MANAGE_USERS):
            return False
        
        # 撤销权限（简化实现）
        if target_user_id in self.repository.user_permissions:
            user_permissions = self.repository.user_permissions[target_user_id]
            if permission in user_permissions:
                user_permissions.remove(permission)
        
        return True
    
    async def get_all_users_permissions(self) -> Dict[str, List[Permission]]:
        """获取所有用户权限"""
        all_permissions = {}
        
        # 获取所有用户ID
        all_user_ids = set(self.repository.user_roles.keys())
        all_user_ids.update(self.repository.user_permissions.keys())
        
        for user_id in all_user_ids:
            permissions = await self.repository.get_user_permissions(user_id)
            all_permissions[user_id] = permissions
        
        return all_permissions
    
    # MerchantPermissionInterface 实现
    async def can_manage_products(self, merchant_id: str) -> bool:
        """检查是否可以管理商品"""
        return await self.has_permission(merchant_id, Permission.CREATE_PRODUCT)
    
    async def can_view_orders(self, merchant_id: str) -> bool:
        """检查是否可以查看订单"""
        return await self.has_permission(merchant_id, Permission.VIEW_ORDER)
    
    async def get_merchant_orders(self, merchant_id: str, status: str = None) -> List[Dict]:
        """获取商家订单"""
        if not await self.can_view_orders(merchant_id):
            return []
        
        # 模拟查询商家订单
        mock_orders = [
            {'order_id': '1', 'status': 'pending', 'merchant_id': merchant_id},
            {'order_id': '2', 'status': 'processing', 'merchant_id': merchant_id}
        ]
        
        if status:
            mock_orders = [order for order in mock_orders if order['status'] == status]
        
        return mock_orders
    
    # CustomerPermissionInterface 实现
    async def can_create_order(self, customer_id: str) -> bool:
        """检查是否可以创建订单"""
        return await self.has_permission(customer_id, Permission.CREATE_ORDER)
    
    async def can_view_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以查看订单"""
        # 检查基础权限
        if not await self.has_permission(customer_id, Permission.VIEW_ORDER):
            return False
        
        # 检查是否是订单的所有者（简化实现）
        # 在实际应用中，需要查询数据库确认订单所有者
        return True
    
    async def can_cancel_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以取消订单"""
        # 检查是否可以取消订单
        if not await self.has_permission(customer_id, Permission.CANCEL_ORDER):
            return False
        
        # 检查订单状态（简化实现）
        return True

# 专门的客户权限服务 - 只实现客户需要的接口
class CustomerPermissionService(CustomerPermissionInterface):
    def __init__(self, comprehensive_service: ComprehensivePermissionService):
        self.comprehensive_service = comprehensive_service
    
    async def can_create_order(self, customer_id: str) -> bool:
        """检查是否可以创建订单"""
        return await self.comprehensive_service.can_create_order(customer_id)
    
    async def can_view_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以查看订单"""
        return await self.comprehensive_service.can_view_order(customer_id, order_id)
    
    async def can_cancel_order(self, customer_id: str, order_id: str) -> bool:
        """检查是否可以取消订单"""
        return await self.comprehensive_service.can_cancel_order(customer_id, order_id)

# 专门的商家权限服务 - 只实现商家需要的接口
class MerchantPermissionService(MerchantPermissionInterface):
    def __init__(self, comprehensive_service: ComprehensivePermissionService):
        self.comprehensive_service = comprehensive_service
    
    async def can_manage_products(self, merchant_id: str) -> bool:
        """检查是否可以管理商品"""
        return await self.comprehensive_service.can_manage_products(merchant_id)
    
    async def can_view_orders(self, merchant_id: str) -> bool:
        """检查是否可以查看订单"""
        return await self.comprehensive_service.can_view_orders(merchant_id)
    
    async def get_merchant_orders(self, merchant_id: str, status: str = None) -> List[Dict]:
        """获取商家订单"""
        return await self.comprehensive_service.get_merchant_orders(merchant_id, status)

# 权限服务工厂
class PermissionServiceFactory:
    def __init__(self, permission_service: ComprehensivePermissionService):
        self.permission_service = permission_service
        self.user_service_cache = {}
    
    def get_permission_service(self, user_id: str) -> PermissionQueryInterface:
        """根据用户类型返回合适的权限服务"""
        # 这里可以根据用户角色返回不同的接口
        # 简化实现：都返回综合权限服务
        return self.permission_service
    
    def get_customer_service(self, customer_id: str) -> CustomerPermissionService:
        """获取客户服务"""
        return CustomerPermissionService(self.permission_service)
    
    def get_merchant_service(self, merchant_id: str) -> MerchantPermissionService:
        """获取商家服务"""
        return MerchantPermissionService(self.permission_service)

# 使用示例
async def demonstrate_permission_usage():
    """演示权限系统使用"""
    
    # 初始化权限仓库和服务
    repository = PermissionRepository()
    comprehensive_service = ComprehensivePermissionService(repository)
    service_factory = PermissionServiceFactory(comprehensive_service)
    
    # 设置用户角色
    await repository.set_user_role("user1", UserRole.CUSTOMER)
    await repository.set_user_role("merchant1", UserRole.MERCHANT)
    await repository.set_user_role("admin1", UserRole.ADMIN)
    
    # 测试客户权限
    customer_service = service_factory.get_customer_service("user1")
    can_create = await customer_service.can_create_order("user1")
    print(f"用户是否可以创建订单: {can_create}")
    
    # 测试商家权限
    merchant_service = service_factory.get_merchant_service("merchant1")
    can_manage = await merchant_service.can_manage_products("merchant1")
    print(f"商家是否可以管理商品: {can_manage}")
    
    orders = await merchant_service.get_merchant_orders("merchant1")
    print(f"商家订单: {orders}")
    
    # 测试管理员权限
    admin_permissions = await comprehensive_service.get_all_users_permissions()
    print(f"所有用户权限: {admin_permissions}")
```

#### 优势分析

1. **接口精简**：每个客户端只看到它需要的接口
2. **降低耦合**：减少客户端对不需要方法的依赖
3. **易于测试**：可以针对具体接口进行测试
4. **清晰职责**：每个接口都有明确的业务含义

### 依赖倒置原则（DIP）的深度实践

#### 事件驱动架构

**问题分析**：
电商平台需要处理各种业务事件（订单创建、支付成功、库存更新等），这些事件的发布者和订阅者之间存在复杂的依赖关系。传统的事件系统会导致发布者和订阅者之间的紧耦合。

**解决方案**：
使用依赖倒置原则，设计抽象的事件总线接口，具体的实现可以灵活替换。

**架构实现**：

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Callable, Any
import asyncio
import json
from enum import Enum

# 事件类型枚举
class EventType(Enum):
    ORDER_CREATED = "order_created"
    ORDER_PAID = "order_paid"
    ORDER_SHIPPED = "order_shipped"
    ORDER_DELIVERED = "order_delivered"
    INVENTORY_UPDATED = "inventory_updated"
    USER_REGISTERED = "user_registered"
    PAYMENT_PROCESSED = "payment_processed"
    PRODUCT_CREATED = "product_created"

# 事件接口
class Event(ABC):
    @property
    @abstractmethod
    def event_type(self) -> EventType:
        """事件类型"""
        pass
    
    @property
    @abstractmethod
    def event_id(self) -> str:
        """事件ID"""
        pass
    
    @property
    @abstractmethod
    def timestamp(self) -> float:
        """事件时间戳"""
        pass
    
    @property
    @abstractmethod
    def data(self) -> Dict[str, Any]:
        """事件数据"""
        pass

# 具体事件实现
class OrderCreatedEvent(Event):
    def __init__(self, order_id: str, user_id: str, product_ids: List[str], total_amount: float):
        self._event_id = f"order_created_{order_id}"
        self._timestamp = asyncio.get_event_loop().time()
        self._data = {
            'order_id': order_id,
            'user_id': user_id,
            'product_ids': product_ids,
            'total_amount': total_amount
        }
    
    @property
    def event_type(self) -> EventType:
        return EventType.ORDER_CREATED
    
    @property
    def event_id(self) -> str:
        return self._event_id
    
    @property
    def timestamp(self) -> float:
        return self._timestamp
    
    @property
    def data(self) -> Dict[str, Any]:
        return self._data

class InventoryUpdatedEvent(Event):
    def __init__(self, product_id: str, quantity_change: int, reason: str):
        self._event_id = f"inventory_updated_{product_id}"
        self._timestamp = asyncio.get_event_loop().time()
        self._data = {
            'product_id': product_id,
            'quantity_change': quantity_change,
            'reason': reason
        }
    
    @property
    def event_type(self) -> EventType:
        return EventType.INVENTORY_UPDATED
    
    @property
    def event_id(self) -> str:
        return self._event_id
    
    @property
    def timestamp(self) -> float:
        return self._timestamp
    
    @property
    def data(self) -> Dict[str, Any]:
        return self._data

# 事件处理器接口
class EventHandler(ABC):
    @abstractmethod
    async def handle(self, event: Event) -> bool:
        """处理事件"""
        pass
    
    @property
    @abstractmethod
    def supported_event_types(self) -> List[EventType]:
        """支持的事件类型"""
        pass

# 事件发布器接口
class EventPublisher(ABC):
    @abstractmethod
    async def publish(self, event: Event) -> bool:
        """发布事件"""
        pass
    
    @abstractmethod
    async def publish_batch(self, events: List[Event]) -> bool:
        """批量发布事件"""
        pass

# 事件订阅器接口
class EventSubscriber(ABC):
    @abstractmethod
    async def subscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """订阅事件"""
        pass
    
    @abstractmethod
    async def unsubscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """取消订阅"""
        pass

# 事件总线接口
class EventBus(EventPublisher, EventSubscriber):
    @abstractmethod
    async def start(self):
        """启动事件总线"""
        pass
    
    @abstractmethod
    async def stop(self):
        """停止事件总线"""
        pass
    
    @abstractmethod
    def get_stats(self) -> Dict[str, Any]:
        """获取统计信息"""
        pass

# 具体的事件总线实现
class InMemoryEventBus(EventBus):
    def __init__(self, max_workers: int = 10):
        self.max_workers = max_workers
        self.subscribers: Dict[EventType, List[EventHandler]] = {}
        self.executor = asyncio.get_event_loop()
        self.is_running = False
        self.stats = {
            'events_published': 0,
            'events_processed': 0,
            'events_failed': 0
        }
    
    async def start(self):
        """启动事件总线"""
        self.is_running = print("事件总线已启动")
    
    async def stop(self):
        """停止事件总线"""
        self.is_running = False
        print("事件总线已停止")
    
    async def publish(self, event: Event) -> bool:
        """发布单个事件"""
        try:
            self.stats['events_published'] += 1
            
            # 获取事件的订阅者
            handlers = self.subscribers.get(event.event_type, [])
            
            if not handlers:
                print(f"没有订阅者处理事件: {event.event_type}")
                return True
            
            # 异步处理所有订阅者
            tasks = []
            for handler in handlers:
                if event.event_type in handler.supported_event_types:
                    task = asyncio.create_task(self._handle_event(handler, event))
                    tasks.append(task)
            
            # 等待所有处理完成
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)
            
            self.stats['events_processed'] += 1
            return True
            
        except Exception as e:
            self.stats['events_failed'] += 1
            print(f"事件发布失败: {e}")
            return False
    
    async def publish_batch(self, events: List[Event]) -> bool:
        """批量发布事件"""
        try:
            tasks = [self.publish(event) for event in events]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return all(result is True for result in results)
            
        except Exception as e:
            print(f"批量事件发布失败: {e}")
            return False
    
    async def subscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """订阅事件"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        
        if handler not in self.subscribers[event_type]:
            self.subscribers[event_type].append(handler)
            print(f"订阅事件: {event_type}")
            return True
        
        return False
    
    async def unsubscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """取消订阅"""
        if event_type in self.subscribers and handler in self.subscribers[event_type]:
            self.subscribers[event_type].remove(handler)
            print(f"取消订阅: {event_type}")
            return True
        
        return False
    
    async def _handle_event(self, handler: EventHandler, event: Event):
        """处理单个事件"""
        try:
            await handler.handle(event)
        except Exception as e:
            print(f"事件处理器执行失败: {handler.__class__.__name__}, 错误: {e}")
    
    def get_stats(self) -> Dict[str, Any]:
        """获取统计信息"""
        return self.stats.copy()

# Redis事件总线实现
class RedisEventBus(EventBus):
    def __init__(self, redis_client: Any, channel_prefix: str = "event_bus"):
        self.redis_client = redis_client
        self.channel_prefix = channel_prefix
        self.subscribers: Dict[str, List[Callable]] = {}
        self.is_running = False
        self.stats = {
            'events_published': 0,
            'events_processed': 0,
            'events_failed': 0
        }
    
    async def start(self):
        """启动Redis事件总线"""
        self.is_running = True
        # 在实际应用中，这里会启动Redis订阅者
        print("Redis事件总线已启动")
    
    async def stop(self):
        """停止Redis事件总线"""
        self.is_running = False
        print("Redis事件总线已停止")
    
    async def publish(self, event: Event) -> bool:
        """发布事件到Redis"""
        try:
            self.stats['events_published'] += 1
            
            # 序列化事件
            event_data = {
                'event_id': event.event_id,
                'event_type': event.event_type.value,
                'timestamp': event.timestamp,
                'data': event.data
            }
            
            # 发布到Redis频道
            channel = f"{self.channel_prefix}:{event.event_type.value}"
            import json
            message = json.dumps(event_data)
            
            # 模拟Redis发布
            print(f"发布事件到Redis频道 {channel}: {event.event_id}")
            
            self.stats['events_processed'] += 1
            return True
            
        except Exception as e:
            self.stats['events_failed'] += 1
            print(f"Redis事件发布失败: {e}")
            return False
    
    async def publish_batch(self, events: List[Event]) -> bool:
        """批量发布事件"""
        try:
            tasks = [self.publish(event) for event in events]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            return all(result is True for result in results)
            
        except Exception as e:
            print(f"Redis批量事件发布失败: {e}")
            return False
    
    async def subscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """订阅Redis事件"""
        # 在实际应用中，这里会订阅Redis频道
        print(f"订阅Redis事件: {event_type}")
        return True
    
    async def unsubscribe(self, event_type: EventType, handler: EventHandler) -> bool:
        """取消Redis事件订阅"""
        print(f"取消Redis事件订阅: {event_type}")
        return True
    
    def get_stats(self) -> Dict[str, Any]:
        """获取统计信息"""
        return self.stats.copy()

# 具体的事件处理器
class InventoryUpdateHandler(EventHandler):
    @property
    def supported_event_types(self) -> List[EventType]:
        return [EventType.ORDER_CREATED, EventType.INVENTORY_UPDATED]
    
    async def handle(self, event: Event) -> bool:
        """处理库存更新事件"""
        if event.event_type == EventType.ORDER_CREATED:
            return await self._handle_order_created(event)
        elif event.event_type == EventType.INVENTORY_UPDATED:
            return await self._handle_inventory_updated(event)
        
        return False
    
    async def _handle_order_created(self, event: Event) -> bool:
        """处理订单创建事件"""
        data = event.data
        product_ids = data['product_ids']
        
        print(f"处理订单创建事件: {data['order_id']}, 商品: {product_ids}")
        
        # 模拟库存检查和扣减
        for product_id in product_ids:
            print(f"检查商品 {product_id} 库存")
            # 实际实现中会调用库存服务
        
        return True
    
    async def _handle_inventory_updated(self, event: Event) -> bool:
        """处理库存更新事件"""
        data = event.data
        print(f"处理库存更新事件: {data['product_id']}, 变化: {data['quantity_change']}")
        
        # 模拟发送库存更新通知
        # 实际实现中会调用通知服务
        
        return True

class NotificationHandler(EventHandler):
    @property
    def supported_event_types(self) -> List[EventType]:
        return [EventType.ORDER_CREATED, EventType.ORDER_PAID, EventType.ORDER_SHIPPED, EventType.ORDER_DELIVERED]
    
    async def handle(self, event: Event) -> bool:
        """处理订单事件，发送通知"""
        if event.event_type == EventType.ORDER_CREATED:
            return await self._send_order_created_notification(event)
        elif event.event_type == EventType.ORDER_PAID:
            return await self._send_order_paid_notification(event)
        elif event.event_type == EventType.ORDER_SHIPPED:
            return await self._send_order_shipped_notification(event)
        elif event.event_type == EventType.ORDER_DELIVERED:
            return await self._send_order_delivered_notification(event)
        
        return False
    
    async def _send_order_created_notification(self, event: Event) -> bool:
        """发送订单创建通知"""
        data = event.data
        print(f"发送订单创建通知: 用户 {data['user_id']}, 订单 {data['order_id']}")
        
        # 模拟发送邮件/短信通知
        return True
    
    async def _send_order_paid_notification(self, event: Event) -> bool:
        """发送订单支付通知"""
        print("发送订单支付通知")
        return True
    
    async def _send_order_shipped_notification(self, event: Event) -> bool:
        """发送订单发货通知"""
        print("发送订单发货通知")
        return True
    
    async def _send_order_delivered_notification(self, event: Event) -> bool:
        """发送订单送达通知"""
        print("发送订单送达通知")
        return True

class AnalyticsHandler(EventHandler):
    @property
    def supported_event_types(self) -> List[EventType]:
        return [EventType.ORDER_CREATED, EventType.ORDER_PAID, EventType.PRODUCT_CREATED, EventType.USER_REGISTERED]
    
    async def handle(self, event: Event) -> bool:
        """处理分析事件"""
        print(f"记录分析事件: {event.event_type.value}")
        
        # 模拟记录到分析系统
        return True

# 订单服务 - 依赖抽象的事件总线
class OrderService:
    def __init__(self, event_bus: EventBus):
        self.event_bus = event_bus
        self.orders = {}
    
    async def create_order(self, user_id: str, product_ids: List[str], total_amount: float) -> str:
        """创建订单"""
        order_id = f"order_{len(self.orders) + 1}"
        
        # 保存订单
        order = {
            'order_id': order_id,
            'user_id': user_id,
            'product_ids': product_ids,
            'total_amount': total_amount,
            'status': 'created',
            'created_at': asyncio.get_event_loop().time()
        }
        self.orders[order_id] = order
        
        # 发布订单创建事件
        order_event = OrderCreatedEvent(order_id, user_id, product_ids, total_amount)
        await self.event_bus.publish(order_event)
        
        print(f"创建订单: {order_id}")
        return order_id
    
    def get_order(self, order_id: str) -> Dict:
        """获取订单"""
        return self.orders.get(order_id, {})

# 事件系统配置管理器
class EventSystemConfig:
    def __init__(self):
        self.event_bus_configs = {
            'memory': {
                'type': 'memory',
                'max_workers': 10
            },
            'redis': {
                'type': 'redis',
                'redis_url': 'redis://localhost:6379',
                'channel_prefix': 'event_bus'
            },
            'kafka': {
                'type': 'kafka',
                'bootstrap_servers': ['localhost:9092'],
                'topic_prefix': 'event_bus'
            }
        }
    
    def get_event_bus_config(self, bus_type: str) -> Dict:
        """获取事件总线配置"""
        return self.event_bus_configs.get(bus_type, {})
    
    def register_event_bus_config(self, bus_type: str, config: Dict):
        """注册新的事件总线配置"""
        self.event_bus_configs[bus_type] = config

# 事件总线工厂
class EventBusFactory:
    def __init__(self, config: EventSystemConfig):
        self.config = config
    
    def create_event_bus(self, bus_type: str, **kwargs) -> EventBus:
        """创建事件总线"""
        bus_config = self.config.get_event_bus_config(bus_type)
        bus_config.update(kwargs)
        
        if bus_config['type'] == 'memory':
            return InMemoryEventBus(max_workers=bus_config.get('max_workers', 10))
        
        elif bus_config['type'] == 'redis':
            # 假设有Redis客户端
            redis_client = self._create_redis_client(bus_config)
            return RedisEventBus(redis_client, bus_config.get('channel_prefix', 'event_bus'))
        
        else:
            raise ValueError(f"不支持的事件总线类型: {bus_config['type']}")
    
    def _create_redis_client(self, config: Dict):
        """创建Redis客户端（模拟）"""
        # 在实际应用中，这里会创建真正的Redis客户端
        return MockRedis()

# 使用示例
async def demonstrate_event_driven_architecture():
    """演示事件驱动架构"""
    
    # 创建配置和工厂
    config = EventSystemConfig()
    factory = EventBusFactory(config)
    
    # 创建内存事件总线
    event_bus = factory.create_event_bus('memory')
    
    # 启动事件总线
    await event_bus.start()
    
    # 注册事件处理器
    inventory_handler = InventoryUpdateHandler()
    notification_handler = NotificationHandler()
    analytics_handler = AnalyticsHandler()
    
    await event_bus.subscribe(EventType.ORDER_CREATED, inventory_handler)
    await event_bus.subscribe(EventType.ORDER_CREATED, notification_handler)
    await event_bus.subscribe(EventType.ORDER_CREATED, analytics_handler)
    
    await event_bus.subscribe(EventType.INVENTORY_UPDATED, inventory_handler)
    
    # 创建订单服务
    order_service = OrderService(event_bus)
    
    # 创建订单（会触发事件）
    order_id = await order_service.create_order(
        user_id="user123",
        product_ids=["product1", "product2"],
        total_amount=199.99
    )
    
    # 发送库存更新事件
    inventory_event = InventoryUpdatedEvent("product1", -1, "order_reservation")
    await event_bus.publish(inventory_event)
    
    # 获取统计信息
    stats = event_bus.get_stats()
    print(f"事件总线统计: {stats}")
    
    # 停止事件总线
    await event_bus.stop()

# 模拟Redis类
class MockRedis:
    def publish(self, channel: str, message: str):
        print(f"模拟Redis发布到频道 {channel}: {message}")
```

#### 优势分析

1. **解耦发布者和订阅者**：发布者不需要知道订阅者的存在
2. **支持多种实现**：可以轻松切换不同的消息中间件
3. **可测试性**：可以使用内存事件总线进行单元测试
4. **扩展性**：支持动态添加新的事件类型和处理器

## 总结

通过这些深入的实践案例，我们可以看到SOLID原则在大型系统架构中的重要价值：

### 1. 架构影响

- **微服务架构**：SRP原则指导服务拆分
- **插件化架构**：OCP原则支持动态扩展
- **多态设计**：LSP原则确保架构的灵活性
- **接口设计**：ISP原则优化系统耦合
- **依赖管理**：DIP原则实现架构解耦

### 2. 实践价值

- **可维护性**：清晰的职责分离和接口设计
- **可扩展性**：支持新功能的无缝集成
- **可测试性**：良好的抽象和依赖注入
- **可重用性**：组件化的设计模式
- **可演化性**：架构的长期演进能力

### 3. 实施建议

- **渐进式应用**：从核心模块开始逐步应用
- **团队培训**：确保团队理解原则背后的动机
- **代码审查**：通过审查确保原则得到遵循
- **重构计划**：在合适的时机重构现有代码

SOLID原则不是教条，而是指导原则。在实际应用中，需要根据具体的业务场景和技术约束进行权衡和调整。正确的应用能够显著提升系统的质量和长期可维护性。