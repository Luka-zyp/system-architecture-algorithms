# 缓存策略

## 目录
1. [缓存概述](#缓存概述)
2. [缓存架构模式](#缓存架构模式)
3. [缓存策略](#缓存策略)
4. [分布式缓存](#分布式缓存)
5. [缓存问题与解决方案](#缓存问题与解决方案)
6. [实际应用案例](#实际应用案例)
7. [最佳实践](#最佳实践)

## 缓存概述

缓存是提升系统性能的重要手段，通过将热点数据存储在高速存储介质中，减少对后端数据源的访问压力。

### 缓存层次结构
```
应用层缓存 → 分布式缓存 → 持久化存储
   (纳秒级)    (微秒级)     (毫秒级)
```

## 缓存架构模式

### 1. Cache Aside（缓存旁路模式）

最常用的模式，应用程序先从缓存获取数据，未命中时从数据库获取并更新缓存。

```python
import asyncio
import time
from typing import Any, Optional, Callable

class SimpleCache:
    """简单内存缓存"""
    
    def __init__(self, ttl: int = 300):
        self.data: dict[str, tuple[Any, float]] = {}
        self.ttl = ttl
        self.hits = 0
        self.misses = 0
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        if key in self.data:
            value, expire_time = self.data[key]
            if time.time() < expire_time:
                self.hits += 1
                return value
            else:
                del self.data[key]
        self.misses += 1
        return None
    
    async def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存值"""
        ttl = ttl or self.ttl
        expire_time = time.time() + ttl
        self.data[key] = (value, expire_time)

class CacheAside:
    """缓存旁路模式"""
    
    def __init__(self, cache: SimpleCache, data_loader: Callable):
        self.cache = cache
        self.data_loader = data_loader
    
    async def get(self, key: str) -> Any:
        """获取数据"""
        value = await self.cache.get(key)
        if value is None:
            value = await self.data_loader(key)
            if value is not None:
                await self.cache.set(key, value)
        return value

# 使用示例
async def demo_cache_aside():
    """演示缓存旁路模式"""
    cache = SimpleCache(ttl=60)
    loader = lambda key: f"data_from_db_{key}"
    
    cache_aside = CacheAside(cache, loader)
    
    # 第一次访问（缓存未命中）
    print("第一次访问:")
    result1 = await cache_aside.get("user:1")
    print(f"结果: {result1}")
    
    # 第二次访问（缓存命中）
    print("第二次访问:")
    result2 = await cache_aside.get("user:1")
    print(f"结果: {result2}")
    
    stats = cache.get_stats()
    print(f"缓存统计: 命中{stats['hits']}次, 未命中{stats['misses']}次")
```

### 2. Write Through（写透模式）

写入数据时，同时更新缓存和数据库。

```python
class WriteThrough:
    """写透模式"""
    
    def __init__(self, cache: SimpleCache, database: Callable):
        self.cache = cache
        self.database = database
    
    async def write(self, key: str, value: Any) -> bool:
        """写入数据（同时更新缓存和数据库）"""
        try:
            # 同时写入数据库和缓存
            await self.database(key, value)
            await self.cache.set(key, value)
            return True
        except Exception as e:
            print(f"写入失败: {e}")
            return False
```

### 3. Write Behind（写回模式）

写入数据时只更新缓存，异步刷新到数据库。

```python
class WriteBehind:
    """写回模式"""
    
    def __init__(self, cache: SimpleCache, database: Callable, flush_interval: int = 5):
        self.cache = cache
        self.database = database
        self.flush_interval = flush_interval
        self.dirty_data: dict[str, Any] = {}
    
    async def start_flush_loop(self):
        """启动异步刷新循环"""
        while True:
            await asyncio.sleep(self.flush_interval)
            await self._flush_to_database()
    
    async def write(self, key: str, value: Any):
        """写入数据（只更新缓存）"""
        await self.cache.set(key, value)
        self.dirty_data[key] = value
    
    async def _flush_to_database(self):
        """批量刷新到数据库"""
        if not self.dirty_data:
            return
        
        print(f"刷新 {len(self.dirty_data)} 条数据到数据库")
        for key, value in self.dirty_data.items():
            try:
                await self.database(key, value)
            except Exception as e:
                print(f"刷新失败 {key}: {e}")
        
        self.dirty_data.clear()
```

## 缓存策略

### 1. TTL策略

```python
import random

class TTLManager:
    """TTL管理器"""
    
    def __init__(self, default_ttl: int = 300):
        self.default_ttl = default_ttl
    
    def calculate_ttl(self, base_ttl: int = None) -> int:
        """计算TTL（添加随机偏移避免同时过期）"""
        base = base_ttl or self.default_ttl
        # 添加±10%的随机偏移
        random_factor = random.uniform(0.9, 1.1)
        return int(base * random_factor)

class AdaptiveTTL:
    """自适应TTL策略"""
    
    def __init__(self):
        self.access_count: dict[str, int] = {}
        self.key_ttl: dict[str, int] = {}
    
    def update_access(self, key: str):
        """更新访问计数"""
        self.access_count[key] = self.access_count.get(key, 0) + 1
    
    def get_ttl(self, key: str, base_ttl: int = 300) -> int:
        """获取自适应TTL"""
        access_count = self.access_count.get(key, 0)
        
        # 根据访问频率调整TTL
        if access_count > 100:  # 高频访问
            return base_ttl * 2
        elif access_count > 50:  # 中频访问
            return base_ttl * 1.5
        else:  # 低频访问
            return base_ttl
    
    def invalidate_key(self, key: str):
        """失效key"""
        if key in self.access_count:
            del self.access_count[key]
        if key in self.key_ttl:
            del self.key_ttl[key]
```

## 分布式缓存

### 一致性哈希

```python
import bisect
import hashlib
from typing import List, Optional

class ConsistentHash:
    """一致性哈希"""
    
    def __init__(self, nodes: List[str], virtual_nodes: int = 150):
        self.virtual_nodes = virtual_nodes
        self.ring: List[int] = []
        self.node_map: dict[int, str] = {}
        
        for node in nodes:
            self.add_node(node)
    
    def _hash(self, key: str) -> int:
        """哈希函数"""
        return int(hashlib.md5(key.encode()).hexdigest(), 16)
    
    def add_node(self, node: str):
        """添加节点"""
        for i in range(self.virtual_nodes):
            virtual_key = f"{node}:{i}"
            position = self._hash(virtual_key)
            bisect.insort(self.ring, position)
            self.node_map[position] = node
    
    def get_node(self, key: str) -> Optional[str]:
        """获取key对应的节点"""
        if not self.ring:
            return None
        
        hash_value = self._hash(key)
        index = bisect.bisect_right(self.ring, hash_value)
        if index == len(self.ring):
            index = 0
        
        return self.node_map[self.ring[index]]

class DistributedCache:
    """分布式缓存"""
    
    def __init__(self, nodes: List[str]):
        self.consistent_hash = ConsistentHash(nodes)
        self.nodes = {node: {} for node in nodes}  # 简化的节点存储
    
    async def get(self, key: str):
        """获取缓存值"""
        node = self.consistent_hash.get_node(key)
        if node:
            return self.nodes[node].get(key)
        return None
    
    async def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存值"""
        node = self.consistent_hash.get_node(key)
        if node:
            self.nodes[node][key] = value
            return True
        return False
```

## 缓存问题与解决方案

### 1. 缓存穿透

```python
class CachePenetrationProtection:
    """缓存穿透防护"""
    
    def __init__(self, cache: SimpleCache, data_loader: Callable):
        self.cache = cache
        self.data_loader = data_loader
        self.null_cache_ttl = 300  # 空值缓存5分钟
        self.bloom_filter: set[str] = set()
    
    async def get(self, key: str) -> Any:
        """带穿透防护的获取"""
        # 检查布隆过滤器
        if key not in self.bloom_filter:
            # 布隆过滤器判断数据不存在，可以直接返回
            return None
        
        # 检查缓存
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        # 缓存未命中，从数据源加载
        value = await self.data_loader(key)
        
        if value is None:
            # 数据不存在，缓存空值
            await self.cache.set(key, "NULL", ttl=self.null_cache_ttl)
        else:
            # 数据存在，缓存数据
            await self.cache.set(key, value)
        
        return value
```

### 2. 缓存击穿

```python
class CacheBreakdownProtection:
    """缓存击穿防护"""
    
    def __init__(self, cache: SimpleCache, data_loader: Callable):
        self.cache = cache
        self.data_loader = data_loader
        self.locks: set[str] = set()
    
    async def get(self, key: str) -> Any:
        """带击穿防护的获取"""
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        # 获取锁（简化实现）
        if key in self.locks:
            # 等待其他线程加载
            await asyncio.sleep(0.1)
            return await self.get(key)
        
        try:
            self.locks.add(key)
            
            # 双重检查
            value = await self.cache.get(key)
            if value is not None:
                return value
            
            # 从数据源加载
            value = await self.data_loader(key)
            if value is not None:
                await self.cache.set(key, value)
            
            return value
        
        finally:
            self.locks.remove(key)
```

### 3. 缓存雪崩

```python
class CacheAvalancheProtection:
    """缓存雪崩防护"""
    
    def __init__(self, cache: SimpleCache, data_loader: Callable):
        self.cache = cache
        self.data_loader = data_loader
        self.fallback_cache: dict[str, Any] = {}
    
    async def get(self, key: str) -> Any:
        """带雪崩防护的获取"""
        # 1. 检查主缓存
        value = await self.cache.get(key)
        if value is not None:
            return value
        
        # 2. 检查降级缓存
        if key in self.fallback_cache:
            fallback_value = self.fallback_cache[key]
            if fallback_value is not None:
                # 恢复数据到主缓存
                await self.cache.set(key, fallback_value)
                return fallback_value
        
        # 3. 从数据源加载
        try:
            value = await self.data_loader(key)
            if value is not None:
                # 设置到主缓存和降级缓存
                await self.cache.set(key, value)
                self.fallback_cache[key] = value
            else:
                # 设置空值到降级缓存
                self.fallback_cache[key] = None
            
            return value
        except Exception as e:
            # 异常时返回降级数据
            return self.fallback_cache.get(key)
```

## 实际应用案例

### 电商系统缓存

```python
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class Product:
    """商品信息"""
    id: str
    name: str
    price: float
    stock: int
    category: str

class EcommerceCache:
    """电商系统缓存"""
    
    def __init__(self, cache: SimpleCache):
        self.cache = cache
        self.product_cache = {}
        self.user_cache = {}
        self.cart_cache = {}
    
    async def get_product(self, product_id: str) -> Optional[Product]:
        """获取商品信息"""
        cache_key = f"product:{product_id}"
        
        cached = await self.cache.get(cache_key)
        if cached:
            return Product(**cached) if isinstance(cached, dict) else cached
        
        # 从数据库加载（模拟）
        product = await self._load_product_from_db(product_id)
        if product:
            product_dict = {
                'id': product.id,
                'name': product.name,
                'price': product.price,
                'stock': product.stock,
                'category': product.category
            }
            await self.cache.set(cache_key, product_dict, ttl=3600)
            self.product_cache[product_id] = product
        
        return product
    
    async def invalidate_product(self, product_id: str):
        """失效商品缓存"""
        cache_keys = [
            f"product:{product_id}",
            f"category:{product_id}",
            f"recommendations:{product_id}*"
        ]
        print(f"失效商品相关缓存: {product_id}")
    
    async def _load_product_from_db(self, product_id: str) -> Optional[Product]:
        """从数据库加载商品信息（模拟）"""
        # 模拟数据库查询
        await asyncio.sleep(0.01)
        return Product(
            id=product_id,
            name=f"商品{product_id}",
            price=99.99,
            stock=100,
            category="electronics"
        )

# 使用示例
async def demo_ecommerce_cache():
    """演示电商缓存"""
    cache = SimpleCache(ttl=300)
    ecommerce_cache = EcommerceCache(cache)
    
    # 获取商品信息
    product = await ecommerce_cache.get_product("prod_001")
    print(f"商品信息: {product}")
    
    # 第二次获取（缓存命中）
    product2 = await ecommerce_cache.get_product("prod_001")
    print(f"缓存命中: {product2 is not None}")
    
    # 失效缓存
    await ecommerce_cache.invalidate_product("prod_001")
    print("缓存已失效")
```

## 最佳实践

### 1. 缓存设计原则
- **数据一致性**: 确保缓存数据与数据库数据的一致性
- **性能考虑**: 选择合适的缓存层次和策略
- **可靠性**: 处理缓存故障和降级策略
- **监控**: 监控缓存命中率、响应时间等指标

### 2. TTL设置策略
```python
class TTLCategories:
    """TTL分类策略"""
    
    CATEGORIES = {
        'user_session': 1800,      # 用户会话 30分钟
        'product_info': 3600,      # 商品信息 1小时
        'category_data': 7200,     # 分类数据 2小时
        'recommendations': 900,    # 推荐数据 15分钟
        'search_results': 300,     # 搜索结果 5分钟
        'static_content': 86400    # 静态内容 24小时
    }
    
    @classmethod
    def get_ttl(cls, category: str, custom_ttl: int = None) -> int:
        """获取TTL"""
        if custom_ttl:
            return custom_ttl
        return cls.CATEGORIES.get(category, 300)
```

### 3. 缓存监控指标

```python
class CacheMonitor:
    """缓存监控器"""
    
    def __init__(self):
        self.metrics = {
            'hits': 0,
            'misses': 0,
            'sets': 0,
            'deletes': 0,
            'errors': 0
        }
    
    def record_hit(self):
        """记录命中"""
        self.metrics['hits'] += 1
    
    def record_miss(self):
        """记录未命中"""
        self.metrics['misses'] += 1
    
    def record_set(self):
        """记录设置"""
        self.metrics['sets'] += 1
    
    def record_error(self):
        """记录错误"""
        self.metrics['errors'] += 1
    
    def get_hit_rate(self) -> float:
        """获取命中率"""
        total = self.metrics['hits'] + self.metrics['misses']
        return self.metrics['hits'] / total if total > 0 else 0
    
    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            **self.metrics,
            'hit_rate': f"{self.get_hit_rate():.2%}",
            'total_requests': self.metrics['hits'] + self.metrics['misses']
        }
```

## 总结

缓存策略是系统性能优化的关键，需要根据业务特点选择合适的模式：

1. **Cache Aside**: 适合读多写少的场景
2. **Write Through**: 适合数据一致性要求高的场景  
3. **Write Behind**: 适合写性能要求高的场景

同时要注意处理缓存穿透、击穿、雪崩等问题，确保系统的稳定性和可靠性。

---
*文档创建时间: 2024年12月*  
*最后更新: 精简冗余内容，保留核心概念*