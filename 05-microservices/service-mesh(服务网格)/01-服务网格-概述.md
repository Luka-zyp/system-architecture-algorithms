# Service Mesh 服务网格概述

## 目录
1. [服务网格概述](#服务网格概述)
2. [服务网格架构](#服务网格架构)
3. [核心功能组件](#核心功能组件)
4. [流量管理](#流量管理)
5. [安全通信](#安全通信)
6. [可观测性](#可观测性)
7. [主流服务网格](#主流服务网格)
8. [Istio详解](#istio详解)
9. [Linkerd详解](#linkerd详解)
10. [自建服务网格](#自建服务网格)
11. [最佳实践](#最佳实践)

## 服务网格概述

服务网格（Service Mesh）是专门用于处理服务间通信的基础设施层，它负责为微服务架构提供可靠的、可观测的、安全的服务间通信能力。

### 服务网格演进
```
传统架构 → 分布式架构 → 微服务架构 → 服务网格架构
单体应用   → RPC调用    → 服务治理    → 基础设施层
```

### 服务网格特点
- **无侵入性**：服务网格通过sidecar模式实现，对业务代码无侵入
- **基础设施化**：将服务间通信下沉为基础设施
- **统一治理**：集中化的服务治理策略
- **可观测性**：内置的监控、日志、追踪能力
- **安全性**：内置的mTLS加密和认证

## 服务网格架构

### 1. 基础架构图
```
                    Service Mesh 控制平面
┌─────────────────────────────────────────────────────────────┐
│  配置管理    服务发现    流量控制    安全策略    可观测性      │
│   (Config)  (Discovery)  (Traffic)  (Security)  (Metrics)     │
└─────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    │               │               │
        Service A   │   Service B   │   Service C   │
    ┌─────────────┐ │ ┌─────────────┐ │ ┌─────────────┐ │
    │  Sidecar    │ │ │  Sidecar    │ │ │  Sidecar    │ │
    │  Proxy      │ │ │  Proxy      │ │ │  Proxy      │ │
    │             │ │ │             │ │ │             │ │
    │  数据平面    │ │ │  数据平面    │ │ │  数据平面    │ │
    └─────────────┘ │ └─────────────┘ │ └─────────────┘ │
        │           │     │           │     │           │
    业务服务A       业务服务B       业务服务C
```

### 2. 控制平面 vs 数据平面
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from enum import Enum
import asyncio

class TrafficDirection(Enum):
    """流量方向"""
    INBOUND = "inbound"
    OUTBOUND = "outbound"

class TrafficAction(Enum):
    """流量动作"""
    ALLOW = "allow"
    DENY = "deny"
    REDIRECT = "redirect"
    REWRITE = "rewrite"

@dataclass
class ServiceConfig:
    """服务配置"""
    service_name: str
    namespace: str
    endpoints: List[str]
    labels: Dict[str, str]
    annotations: Dict[str, str]
    traffic_policy: Dict[str, Any]

@dataclass
class TrafficRule:
    """流量规则"""
    source_service: str
    destination_service: str
    action: TrafficAction
    conditions: Dict[str, Any]
    weight: int = 100

@dataclass
class SecurityPolicy:
    """安全策略"""
    name: str
    services: List[str]
    auth_type: str  # mTLS, JWT, etc.
    rules: Dict[str, Any]

class ControlPlane(ABC):
    """控制平面抽象"""
    
    @abstractmethod
    async def start(self):
        """启动控制平面"""
        pass
    
    @abstractmethod
    async def stop(self):
        """停止控制平面"""
        pass
    
    @abstractmethod
    async def get_service_configs(self) -> List[ServiceConfig]:
        """获取服务配置"""
        pass
    
    @abstractmethod
    async def get_traffic_rules(self) -> List[TrafficRule]:
        """获取流量规则"""
        pass
    
    @abstractmethod
    async def get_security_policies(self) -> List[SecurityPolicy]:
        """获取安全策略"""
        pass

class DataPlane(ABC):
    """数据平面抽象"""
    
    @abstractmethod
    async def start(self):
        """启动数据平面"""
        pass
    
    @abstractmethod
    async def stop(self):
        """停止数据平面"""
        pass
    
    @abstractmethod
    async def configure(self, config: Dict[str, Any]):
        """配置数据平面"""
        pass
    
    @abstractmethod
    async def handle_traffic(self, traffic_data: Dict[str, Any]) -> Dict[str, Any]:
        """处理流量"""
        pass

class ServiceMesh:
    """服务网格"""
    
    def __init__(self, control_plane: ControlPlane, data_plane: DataPlane):
        self.control_plane = control_plane
        self.data_plane = data_plane
        self.config_cache: Dict[str, Any] = {}
        self._running = False
    
    async def start(self):
        """启动服务网格"""
        await self.control_plane.start()
        await self.data_plane.start()
        self._running = True
        
        # 启动配置同步任务
        asyncio.create_task(self._config_sync_loop())
    
    async def stop(self):
        """停止服务网格"""
        self._running = False
        await self.data_plane.stop()
        await self.control_plane.stop()
    
    async def _config_sync_loop(self):
        """配置同步循环"""
        while self._running:
            try:
                # 同步控制平面配置到数据平面
                await self._sync_configurations()
                await asyncio.sleep(30)  # 每30秒同步一次
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Configuration sync error: {e}")
                await asyncio.sleep(60)
    
    async def _sync_configurations(self):
        """同步配置"""
        # 获取控制平面配置
        service_configs = await self.control_plane.get_service_configs()
        traffic_rules = await self.control_plane.get_traffic_rules()
        security_policies = await self.control_plane.get_security_policies()
        
        # 构建数据平面配置
        mesh_config = {
            'services': [self._serialize_service_config(config) for config in service_configs],
            'traffic_rules': [self._serialize_traffic_rule(rule) for rule in traffic_rules],
            'security_policies': [self._serialize_security_policy(policy) for policy in security_policies]
        }
        
        # 配置数据平面
        await self.data_plane.configure(mesh_config)
        
        # 更新缓存
        self.config_cache = mesh_config
    
    def _serialize_service_config(self, config: ServiceConfig) -> Dict[str, Any]:
        """序列化服务配置"""
        return {
            'service_name': config.service_name,
            'namespace': config.namespace,
            'endpoints': config.endpoints,
            'labels': config.labels,
            'annotations': config.annotations,
            'traffic_policy': config.traffic_policy
        }
    
    def _serialize_traffic_rule(self, rule: TrafficRule) -> Dict[str, Any]:
        """序列化流量规则"""
        return {
            'source_service': rule.source_service,
            'destination_service': rule.destination_service,
            'action': rule.action.value,
            'conditions': rule.conditions,
            'weight': rule.weight
        }
    
    def _serialize_security_policy(self, policy: SecurityPolicy) -> Dict[str, Any]:
        """序列化安全策略"""
        return {
            'name': policy.name,
            'services': policy.services,
            'auth_type': policy.auth_type,
            'rules': policy.rules
        }
```

## 核心功能组件

### 3. 服务发现与注册
```python
class ServiceRegistry:
    """服务注册中心"""
    
    def __init__(self):
        self.services: Dict[str, Dict[str, Dict]] = {}  # namespace -> service_name -> instance
        self.health_checks: Dict[str, callable] = {}
        self.watchers: List[callable] = []
    
    async def register_service(self, namespace: str, service_name: str, 
                              instance_id: str, instance_data: Dict[str, Any]):
        """注册服务实例"""
        if namespace not in self.services:
            self.services[namespace] = {}
        
        if service_name not in self.services[namespace]:
            self.services[namespace][service_name] = {}
        
        instance_data['last_heartbeat'] = time.time()
        self.services[namespace][service_name][instance_id] = instance_data
        
        await self._notify_watchers('register', namespace, service_name, instance_id)
    
    async def deregister_service(self, namespace: str, service_name: str, instance_id: str):
        """注销服务实例"""
        if namespace in self.services and service_name in self.services[namespace]:
            if instance_id in self.services[namespace][service_name]:
                del self.services[namespace][service_name][instance_id]
                await self._notify_watchers('deregister', namespace, service_name, instance_id)
    
    async def discover_services(self, namespace: str, service_name: str) -> List[Dict[str, Any]]:
        """服务发现"""
        if namespace not in self.services or service_name not in self.services[namespace]:
            return []
        
        instances = []
        current_time = time.time()
        
        for instance_id, instance_data in self.services[namespace][service_name].items():
            # 检查心跳超时
            if current_time - instance_data.get('last_heartbeat', 0) < 300:  # 5分钟超时
                instances.append({
                    'instance_id': instance_id,
                    **instance_data
                })
        
        return instances
    
    async def health_check(self, namespace: str, service_name: str, instance_id: str) -> bool:
        """健康检查"""
        instance_data = self.services.get(namespace, {}).get(service_name, {}).get(instance_id)
        
        if not instance_data:
            return False
        
        health_check_url = instance_data.get('health_check_url')
        if health_check_url:
            try:
                # 执行HTTP健康检查
                async with aiohttp.ClientSession() as session:
                    async with session.get(health_check_url, timeout=aiohttp.ClientTimeout(total=5)) as response:
                        return response.status == 200
            except Exception:
                return False
        
        return True
    
    def add_watcher(self, watcher: callable):
        """添加变更监听器"""
        self.watchers.append(watcher)
    
    async def _notify_watchers(self, event_type: str, namespace: str, 
                              service_name: str, instance_id: str):
        """通知监听器"""
        for watcher in self.watchers:
            try:
                await watcher(event_type, namespace, service_name, instance_id)
            except Exception as e:
                print(f"Error notifying watcher: {e}")
```

### 4. 负载均衡
```python
class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self, algorithm: str = "round_robin"):
        self.algorithm = algorithm
        self.algorithms = {
            'round_robin': self._round_robin_select,
            'least_connections': self._least_connections_select,
            'random': self._random_select,
            'consistent_hash': self._consistent_hash_select,
            'weighted_round_robin': self._weighted_round_robin_select
        }
        self.connection_counts: Dict[str, int] = {}
        self.weights: Dict[str, int] = {}
        self._lock = asyncio.Lock()
    
    async def select_target(self, service_instances: List[Dict], 
                          request_context: Dict = None) -> Optional[Dict]:
        """选择目标实例"""
        if not service_instances:
            return None
        
        request_context = request_context or {}
        select_func = self.algorithms.get(self.algorithm, self._round_robin_select)
        
        return await select_func(service_instances, request_context)
    
    async def _round_robin_select(self, instances: List[Dict], 
                                context: Dict) -> Dict:
        """轮询选择"""
        async with self._lock:
            if not hasattr(self, '_rr_counter'):
                self._rr_counter = 0
            
            selected = instances[self._rr_counter % len(instances)]
            self._rr_counter += 1
            return selected
    
    async def _least_connections_select(self, instances: List[Dict], 
                                      context: Dict) -> Dict:
        """最少连接选择"""
        min_connections = float('inf')
        selected_instance = None
        
        for instance in instances:
            instance_id = instance['instance_id']
            connections = self.connection_counts.get(instance_id, 0)
            
            if connections < min_connections:
                min_connections = connections
                selected_instance = instance
        
        return selected_instance or instances[0]
    
    async def _random_select(self, instances: List[Dict], 
                           context: Dict) -> Dict:
        """随机选择"""
        import random
        return random.choice(instances)
    
    async def _consistent_hash_select(self, instances: List[Dict], 
                                    context: Dict) -> Dict:
        """一致性哈希选择"""
        import hashlib
        
        # 获取请求的关键信息（如用户ID、请求ID等）
        hash_key = context.get('user_id') or context.get('request_id') or context.get('source_ip')
        
        if not hash_key:
            # 如果没有hash key，回退到轮询
            return await self._round_robin_select(instances, context)
        
        # 计算hash值
        hash_value = int(hashlib.md5(hash_key.encode()).hexdigest(), 16)
        
        # 选择实例
        selected_index = hash_value % len(instances)
        return instances[selected_index]
    
    async def _weighted_round_robin_select(self, instances: List[Dict], 
                                         context: Dict) -> Dict:
        """加权轮询选择"""
        total_weight = sum(self.weights.get(inst.get('instance_id'), 1) for inst in instances)
        
        if total_weight == 0:
            return await self._round_robin_select(instances, context)
        
        selected_weight = hash(int(time.time() * 1000)) % total_weight
        
        for instance in instances:
            weight = self.weights.get(instance.get('instance_id'), 1)
            if selected_weight < weight:
                return instance
            selected_weight -= weight
        
        return instances[0]
    
    def update_connection_count(self, instance_id: str, delta: int):
        """更新连接计数"""
        self.connection_counts[instance_id] = \
            self.connection_counts.get(instance_id, 0) + delta
    
    def set_instance_weight(self, instance_id: str, weight: int):
        """设置实例权重"""
        self.weights[instance_id] = weight
```

## 流量管理

### 5. 流量路由
```python
class TrafficRouter:
    """流量路由器"""
    
    def __init__(self):
        self.routes: List[Dict] = []
        self.destinations: Dict[str, List[Dict]] = {}  # service -> destinations
    
    def add_route(self, route: Dict):
        """添加路由规则"""
        self.routes.append(route)
    
    def add_destination(self, service_name: str, destination: Dict):
        """添加路由目标"""
        if service_name not in self.destinations:
            self.destinations[service_name] = []
        self.destinations[service_name].append(destination)
    
    async def route_request(self, source_service: str, request: Dict) -> Dict:
        """路由请求"""
        # 匹配路由规则
        for route in self.routes:
            if await self._match_route(route, source_service, request):
                destination_service = route.get('destination')
                
                # 找到目标服务实例
                if destination_service in self.destinations:
                    return await self._select_destination(
                        destination_service, 
                        self.destinations[destination_service],
                        request
                    )
        
        # 默认路由（如果没有匹配规则）
        return None
    
    async def _match_route(self, route: Dict, source_service: str, 
                          request: Dict) -> bool:
        """匹配路由规则"""
        # 检查源服务
        if route.get('source_service') and route['source_service'] != source_service:
            return False
        
        # 检查请求特征
        conditions = route.get('conditions', {})
        
        for key, expected_value in conditions.items():
            actual_value = request.get(key)
            
            if isinstance(expected_value, dict):
                # 支持操作符：exact, regex, range等
                for op, value in expected_value.items():
                    if op == 'exact' and actual_value != value:
                        return False
                    elif op == 'regex' and not self._match_regex(actual_value, value):
                        return False
                    elif op == 'range' and not self._match_range(actual_value, value):
                        return False
            else:
                if actual_value != expected_value:
                    return False
        
        return True
    
    def _match_regex(self, value: str, pattern: str) -> bool:
        """正则匹配"""
        import re
        try:
            return bool(re.match(pattern, value))
        except:
            return False
    
    def _match_range(self, value: float, range_spec: List[float]) -> bool:
        """范围匹配"""
        if not isinstance(value, (int, float)) or len(range_spec) != 2:
            return False
        return range_spec[0] <= value <= range_spec[1]
    
    async def _select_destination(self, service_name: str, 
                                destinations: List[Dict], 
                                request: Dict) -> Dict:
        """选择目标实例"""
        # 根据权重选择
        total_weight = sum(dest.get('weight', 1) for dest in destinations)
        
        if total_weight <= 0:
            return destinations[0]
        
        import random
        random_weight = random.randint(1, total_weight)
        
        current_weight = 0
        for dest in destinations:
            weight = dest.get('weight', 1)
            current_weight += weight
            if random_weight <= current_weight:
                return dest
        
        return destinations[0]

class CircuitBreaker:
    """熔断器"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60, 
                 success_threshold: int = 3):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.success_threshold = success_threshold
        
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time = None
        self.state = 'closed'  # closed, open, half_open
    
    async def allow_request(self, target: Dict) -> bool:
        """检查是否允许请求"""
        if self.state == 'open':
            if self._should_attempt_reset():
                self.state = 'half_open'
                self.success_count = 0
                return True
            return False
        
        return True
    
    async def record_success(self):
        """记录成功"""
        if self.state == 'half_open':
            self.success_count += 1
            if self.success_count >= self.success_threshold:
                self.state = 'closed'
                self.failure_count = 0
        elif self.state == 'closed':
            self.failure_count = 0
    
    async def record_failure(self):
        """记录失败"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.state == 'closed':
            if self.failure_count >= self.failure_threshold:
                self.state = 'open'
        elif self.state == 'half_open':
            self.state = 'open'
    
    def _should_attempt_reset(self) -> bool:
        """检查是否应该尝试重置"""
        if not self.last_failure_time:
            return True
        return (time.time() - self.last_failure_time) >= self.timeout

class RateLimiter:
    """限流器"""
    
    def __init__(self, rate_limit: int, time_window: int = 60):
        self.rate_limit = rate_limit
        self.time_window = time_window
        self.requests: Dict[str, deque] = defaultdict(deque)
    
    async def allow_request(self, key: str) -> bool:
        """检查是否允许请求"""
        current_time = time.time()
        window_start = current_time - self.time_window
        
        # 清理过旧请求
        requests = self.requests[key]
        while requests and requests[0] < window_start:
            requests.popleft()
        
        # 检查是否超过限制
        if len(requests) >= self.rate_limit:
            return False
        
        # 记录请求
        requests.append(current_time)
        return True
```

## 安全通信

### 6. 服务间认证与授权
```python
import ssl
import tempfile
import os
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID

class CertificateManager:
    """证书管理器"""
    
    def __init__(self, ca_cert_path: str, ca_key_path: str):
        self.ca_cert_path = ca_cert_path
        self.ca_key_path = ca_key_path
        self.service_certs: Dict[str, Dict] = {}
    
    def load_ca_certificate(self) -> Dict[str, Any]:
        """加载CA证书"""
        try:
            with open(self.ca_cert_path, 'rb') as f:
                ca_cert_data = f.read()
            
            with open(self.ca_key_path, 'rb') as f:
                ca_key_data = f.read()
            
            ca_cert = x509.load_pem_x509_certificate(ca_cert_data)
            ca_key = serialization.load_pem_private_key(ca_key_data, password=None)
            
            return {'cert': ca_cert, 'key': ca_key}
        except Exception as e:
            print(f"Error loading CA certificate: {e}")
            return None
    
    def generate_service_certificate(self, service_name: str, namespace: str, 
                                   ip_addresses: List[str]) -> Dict[str, Any]:
        """生成服务证书"""
        ca_info = self.load_ca_certificate()
        if not ca_info:
            return None
        
        # 生成私钥
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        
        # 创建证书
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, "US"),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, "CA"),
            x509.NameAttribute(NameOID.LOCALITY_NAME, "San Francisco"),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, "Service Mesh"),
            x509.NameAttribute(NameOID.COMMON_NAME, f"{service_name}.{namespace}.svc.cluster.local"),
        ])
        
        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=365)
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(f"{service_name}.{namespace}.svc.cluster.local"),
                x509.DNSName(f"{service_name}.{namespace}"),
                x509.DNSName(f"{service_name}"),
            ] + [x509.IPAddress(ip) for ip in ip_addresses]),
            critical=False
        ).sign(private_key, hashes.SHA256())
        
        # 序列化证书和私钥
        cert_pem = cert.public_bytes(serialization.Encoding.PEM)
        key_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        cert_info = {
            'cert': cert_pem.decode(),
            'key': key_pem.decode(),
            'private_key': private_key,
            'cert_object': cert
        }
        
        self.service_certs[f"{service_name}.{namespace}"] = cert_info
        return cert_info
    
    def get_service_certificate(self, service_name: str, namespace: str) -> Optional[Dict[str, Any]]:
        """获取服务证书"""
        full_name = f"{service_name}.{namespace}"
        return self.service_certs.get(full_name)
    
    def verify_certificate(self, cert_pem: str) -> bool:
        """验证证书"""
        try:
            cert = x509.load_pem_x509_certificate(cert_pem.encode())
            
            # 验证证书签名
            ca_info = self.load_ca_certificate()
            if ca_info:
                ca_info['cert'].public_key().verify(
                    cert.signature,
                    cert.tbs_certificate_bytes,
                    cert.signature_hash_algorithm
                )
                return True
        except Exception as e:
            print(f"Certificate verification failed: {e}")
        
        return False

class MTLSClient:
    """mTLS客户端"""
    
    def __init__(self, cert_manager: CertificateManager):
        self.cert_manager = cert_manager
        self.ssl_contexts: Dict[str, ssl.SSLContext] = {}
    
    def create_ssl_context(self, service_name: str, namespace: str) -> ssl.SSLContext:
        """创建SSL上下文"""
        cert_info = self.cert_manager.get_service_certificate(service_name, namespace)
        
        if not cert_info:
            raise ValueError(f"No certificate found for {service_name}.{namespace}")
        
        ssl_context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
        
        # 加载客户端证书
        ssl_context.load_cert_chain(
            certfile=cert_info['cert'],
            keyfile=cert_info['key']
        )
        
        # 设置验证模式
        ssl_context.verify_mode = ssl.CERT_REQUIRED
        
        # 可以在这里加载CA证书进行服务器证书验证
        # ssl_context.load_verify_locations(cafile='ca.crt')
        
        return ssl_context
    
    async def make_request(self, target_service: str, target_namespace: str, 
                          method: str, path: str, data: Any = None) -> Dict[str, Any]:
        """发送mTLS请求"""
        ssl_context = self.create_ssl_context(target_service, target_namespace)
        
        # 构造目标地址
        target_address = f"{target_service}.{target_namespace}.svc.cluster.local"
        
        connector = aiohttp.TCPConnector(ssl=ssl_context)
        
        async with aiohttp.ClientSession(connector=connector) as session:
            url = f"https://{target_address}{path}"
            
            try:
                async with session.request(method, url, json=data) as response:
                    response_data = await response.json()
                    
                    return {
                        'status_code': response.status,
                        'data': response_data,
                        'success': True
                    }
            except Exception as e:
                return {
                    'success': False,
                    'error': str(e)
                }

class ServiceAuth:
    """服务认证"""
    
    def __init__(self):
        self.service_tokens: Dict[str, str] = {}
    
    def generate_service_token(self, service_name: str, namespace: str, 
                             permissions: List[str]) -> str:
        """生成服务令牌"""
        import json
        
        token_data = {
            'service': f"{service_name}.{namespace}",
            'permissions': permissions,
            'exp': time.time() + 3600,  # 1小时过期
            'iat': time.time()
        }
        
        # 简化实现：使用base64编码（生产环境应使用JWT）
        import base64
        token = base64.b64encode(json.dumps(token_data).encode()).decode()
        
        self.service_tokens[token] = token_data
        return token
    
    def validate_service_token(self, token: str) -> Optional[Dict[str, Any]]:
        """验证服务令牌"""
        try:
            import json
            import base64
            
            token_data = self.service_tokens.get(token)
            if not token_data:
                # 尝试解码（用于向后兼容）
                decoded = base64.b64decode(token.encode()).decode()
                token_data = json.loads(decoded)
            
            # 检查过期时间
            if token_data.get('exp', 0) < time.time():
                return None
            
            return token_data
        except Exception:
            return None
```

## 可观测性

### 7. 指标收集与导出
```python
from prometheus_client import Counter, Histogram, Gauge, start_http_server
from typing import Dict, Any
import json

class MetricsCollector:
    """指标收集器"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        
        # Prometheus指标
        self.request_counter = Counter(
            'service_requests_total',
            'Total number of requests',
            ['method', 'endpoint', 'status_code']
        )
        
        self.request_duration = Histogram(
            'service_request_duration_seconds',
            'Request duration in seconds',
            ['method', 'endpoint']
        )
        
        self.active_connections = Gauge(
            'service_active_connections',
            'Number of active connections'
        )
        
        self.error_counter = Counter(
            'service_errors_total',
            'Total number of errors',
            ['error_type']
        )
    
    def record_request(self, method: str, endpoint: str, 
                      status_code: int, duration: float):
        """记录请求指标"""
        self.request_counter.labels(
            method=method,
            endpoint=endpoint,
            status_code=str(status_code)
        ).inc()
        
        self.request_duration.labels(
            method=method,
            endpoint=endpoint
        ).observe(duration)
    
    def record_error(self, error_type: str):
        """记录错误指标"""
        self.error_counter.labels(error_type=error_type).inc()
    
    def set_active_connections(self, count: int):
        """设置活跃连接数"""
        self.active_connections.set(count)

class DistributedTracer:
    """分布式追踪"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.traces: Dict[str, Dict] = {}
    
    def create_span(self, trace_id: str, span_id: str, 
                   parent_span_id: str = None, operation_name: str = None) -> Dict[str, Any]:
        """创建追踪跨度"""
        span = {
            'trace_id': trace_id,
            'span_id': span_id,
            'parent_span_id': parent_span_id,
            'operation_name': operation_name or 'unknown',
            'service_name': self.service_name,
            'start_time': time.time(),
            'end_time': None,
            'tags': {},
            'logs': []
        }
        
        self.traces[span_id] = span
        return span
    
    def finish_span(self, span_id: str, tags: Dict[str, Any] = None):
        """完成追踪跨度"""
        if span_id in self.traces:
            span = self.traces[span_id]
            span['end_time'] = time.time()
            span['duration'] = span['end_time'] - span['start_time']
            
            if tags:
                span['tags'].update(tags)
    
    def add_tag(self, span_id: str, key: str, value: Any):
        """添加标签"""
        if span_id in self.traces:
            self.traces[span_id]['tags'][key] = value
    
    def add_log(self, span_id: str, timestamp: float, message: str, 
               fields: Dict[str, Any] = None):
        """添加日志"""
        if span_id in self.traces:
            log_entry = {
                'timestamp': timestamp,
                'message': message,
                'fields': fields or {}
            }
            self.traces[span_id]['logs'].append(log_entry)
    
    def get_trace(self, trace_id: str) -> List[Dict[str, Any]]:
        """获取追踪"""
        return [
            span for span in self.traces.values()
            if span['trace_id'] == trace_id
        ]
    
    def export_trace(self, trace_id: str) -> str:
        """导出追踪数据（JSON格式）"""
        trace = self.get_trace(trace_id)
        return json.dumps(trace, indent=2, default=str)

class LogAggregator:
    """日志聚合器"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
        self.logs: list = []
        self.max_logs = 10000
    
    def add_log(self, level: str, message: str, 
               trace_id: str = None, span_id: str = None, 
               metadata: Dict[str, Any] = None):
        """添加日志"""
        log_entry = {
            'timestamp': time.time(),
            'service': self.service_name,
            'level': level,
            'message': message,
            'trace_id': trace_id,
            'span_id': span_id,
            'metadata': metadata or {}
        }
        
        self.logs.append(log_entry)
        
        # 保持日志数量限制
        if len(self.logs) > self.max_logs:
            self.logs = self.logs[-self.max_logs//2:]  # 保留后半部分
    
    def get_logs(self, level: str = None, trace_id: str = None, 
                since: float = None) -> list:
        """获取日志"""
        filtered_logs = self.logs
        
        if level:
            filtered_logs = [log for log in filtered_logs if log['level'] == level]
        
        if trace_id:
            filtered_logs = [log for log in filtered_logs if log.get('trace_id') == trace_id]
        
        if since:
            filtered_logs = [log for log in filtered_logs if log['timestamp'] >= since]
        
        return filtered_logs
    
    def search_logs(self, query: str) -> list:
        """搜索日志"""
        results = []
        query_lower = query.lower()
        
        for log in self.logs:
            if (query_lower in log['message'].lower() or
                query_lower in str(log.get('metadata', {})).lower()):
                results.append(log)
        
        return results
```

## 主流服务网格

### 8. Istio详解
```python
class IstioConfig:
    """Istio配置"""
    
    def __init__(self):
        self.virtual_services: List[Dict] = []
        self.destination_rules: List[Dict] = []
        self.gateway_configs: List[Dict] = []
        self.authorization_policies: List[Dict] = []
    
    def add_virtual_service(self, name: str, namespace: str, hosts: List[str], 
                          http_routes: List[Dict]):
        """添加虚拟服务"""
        vs = {
            'apiVersion': 'networking.istio.io/v1beta1',
            'kind': 'VirtualService',
            'metadata': {
                'name': name,
                'namespace': namespace
            },
            'spec': {
                'hosts': hosts,
                'http': http_routes
            }
        }
        self.virtual_services.append(vs)
    
    def add_destination_rule(self, name: str, namespace: str, host: str, 
                           subsets: List[Dict], traffic_policy: Dict = None):
        """添加目标规则"""
        dr = {
            'apiVersion': 'networking.istio.io/v1beta1',
            'kind': 'DestinationRule',
            'metadata': {
                'name': name,
                'namespace': namespace
            },
            'spec': {
                'host': host,
                'subsets': subsets,
                'trafficPolicy': traffic_policy or {}
            }
        }
        self.destination_rules.append(dr)
    
    def add_gateway(self, name: str, namespace: str, selector: Dict, 
                   servers: List[Dict]):
        """添加网关"""
        gateway = {
            'apiVersion': 'networking.istio.io/v1beta1',
            'kind': 'Gateway',
            'metadata': {
                'name': name,
                'namespace': namespace
            },
            'spec': {
                'selector': selector,
                'servers': servers
            }
        }
        self.gateway_configs.append(gateway)
    
    def add_authorization_policy(self, name: str, namespace: str, 
                               selector: Dict, rules: List[Dict]):
        """添加授权策略"""
        auth_policy = {
            'apiVersion': 'security.istio.io/v1beta1',
            'kind': 'AuthorizationPolicy',
            'metadata': {
                'name': name,
                'namespace': namespace
            },
            'spec': {
                'selector': selector,
                'rules': rules
            }
        }
        self.authorization_policies.append(auth_policy)
    
    def generate_yaml(self) -> str:
        """生成YAML配置"""
        yaml_content = []
        
        # 添加所有配置
        for config_list in [self.virtual_services, self.destination_rules, 
                           self.gateway_configs, self.authorization_policies]:
            for config in config_list:
                yaml_content.append('---')
                yaml_content.append(yaml.dump(config, default_flow_style=False))
        
        return '\n'.join(yaml_content)

class IstioPilot:
    """Istio Pilot（控制平面核心组件）"""
    
    def __init__(self):
        self.service_discovery = ServiceRegistry()
        self.config_generator = IstioConfig()
        self.xds_server = None
        self._running = False
    
    async def start(self):
        """启动Pilot"""
        self._running = True
        
        # 启动XDS服务器
        await self._start_xds_server()
        
        # 启动配置同步
        asyncio.create_task(self._config_sync_loop())
    
    async def stop(self):
        """停止Pilot"""
        self._running = False
        if self.xds_server:
            await self.xds_server.stop()
    
    async def _start_xds_server(self):
        """启动XDS服务器"""
        # 这里会启动gRPC服务器，提供XDS API
        pass
    
    async def _config_sync_loop(self):
        """配置同步循环"""
        while self._running:
            try:
                # 监控服务注册变更
                await self._sync_service_configs()
                
                # 生成Envoy配置
                await self._generate_envoy_configs()
                
                await asyncio.sleep(10)
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"Pilot sync error: {e}")
                await asyncio.sleep(30)
    
    async def _sync_service_configs(self):
        """同步服务配置"""
        # 从服务注册中心获取服务信息，转换为Istio配置
        pass
    
    async def _generate_envoy_configs(self):
        """生成Envoy配置"""
        # 基于Istio配置生成Envoy动态配置
        pass
```

### 9. Linkerd详解
```python
class LinkerdProxy:
    """Linkerd代理"""
    
    def __init__(self, service_name: str, control_plane_addr: str):
        self.service_name = service_name
        self.control_plane_addr = control_plane_addr
        self.proxy_config = {
            'admin': {
                'ip': '0.0.0.0',
                'port': 4191
            },
            'proxy': {
                'inbound': {
                    'port': 4143
                },
                'outbound': {
                    'port': 4140
                },
                'resource': {
                    'cpu_limit': '100m',
                    'memory_limit': '128Mi'
                }
            }
        }
    
    def get_tap_config(self) -> Dict[str, Any]:
        """获取Tap配置（实时流量监控）"""
        return {
            'proxy': self.proxy_config,
            'destination': {
                'control_plane_addr': self.control_plane_addr
            }
        }
    
    def get_metrics_config(self) -> Dict[str, Any]:
        """获取指标配置"""
        return {
            'metrics': {
                'enabled': True,
                'path': '/metrics',
                'port': 4191
            },
            'control_plane': {
                'addr': self.control_plane_addr
            }
        }

class LinkerdControlPlane:
    """Linkerd控制平面"""
    
    def __init__(self):
        self.components = {
            'destination': self._init_destination_service(),
            'proxy': self._init_proxy_service(),
            'tap': self._init_tap_service(),
            'policy_controller': self._init_policy_controller(),
            'sp_validator': self._init_sp_validator()
        }
    
    def _init_destination_service(self):
        """初始化目标服务"""
        return {
            'name': 'linkerd-destination',
            'port': 8086,
            'function': 'Service discovery and policy resolution'
        }
    
    def _init_proxy_service(self):
        """初始化代理服务"""
        return {
            'name': 'linkerd-proxy',
            'port': 4140,
            'function': 'HTTP/HTTPS proxy'
        }
    
    def _init_tap_service(self):
        """初始化Tap服务"""
        return {
            'name': 'linkerd-tap',
            'port': 8088,
            'function': 'Real-time traffic monitoring'
        }
    
    def _init_policy_controller(self):
        """初始化策略控制器"""
        return {
            'name': 'linkerd-policy-controller',
            'port': 8090,
            'function': 'Network policy enforcement'
        }
    
    def _init_sp_validator(self):
        """初始化SP验证器"""
        return {
            'name': 'linkerd-sp-validator',
            'port': 8087,
            'function': 'Service profile validation'
        }
    
    async def start(self):
        """启动控制平面"""
        for component_name, component_info in self.components.items():
            print(f"Starting {component_info['name']}...")
            # 这里会实际启动各个组件
            await asyncio.sleep(1)  # 模拟启动时间
        print("Linkerd control plane started successfully")
    
    def get_service_profile(self, service_name: str, namespace: str) -> Dict[str, Any]:
        """获取服务配置"""
        return {
            'apiVersion': 'linkerd.io/v1alpha2',
            'kind': 'ServiceProfile',
            'metadata': {
                'name': f"{service_name}.{namespace}.svc.cluster.local",
                'namespace': namespace
            },
            'spec': {
                'routes': [
                    {
                        'name': 'All requests',
                        'condition': {
                            'pathRegex': '/.*'
                        },
                        'responseClasses': [
                            {
                                'condition': {
                                    'status': {
                                        'min': 200,
                                        'max': 299
                                    }
                                },
                                'isFailureClass': False
                            }
                        ]
                    }
                ]
            }
        }
```

## 自建服务网格

### 10. 简化版服务网格实现
```python
class SimpleServiceMesh:
    """简化版服务网格"""
    
    def __init__(self):
        self.service_registry = ServiceRegistry()
        self.cert_manager = CertificateManager('ca.crt', 'ca.key')
        self.load_balancer = LoadBalancer()
        self.metrics_collector = None
        self.tracer = None
        
        # 配置
        self.routes = []
        self.circuit_breakers = {}
        self.rate_limiters = {}
    
    async def register_service(self, service_name: str, namespace: str, 
                             instance_data: Dict[str, Any]):
        """注册服务"""
        await self.service_registry.register_service(
            namespace, service_name, 
            instance_data['instance_id'], instance_data
        )
    
    def setup_monitoring(self, service_name: str):
        """设置监控"""
        self.metrics_collector = MetricsCollector(service_name)
        self.tracer = DistributedTracer(service_name)
    
    def configure_route(self, route_config: Dict[str, Any]):
        """配置路由"""
        self.routes.append(route_config)
    
    async def proxy_request(self, source_service: str, target_service: str, 
                          request: Dict) -> Dict[str, Any]:
        """代理请求"""
        # 创建追踪跨度
        trace_id = request.get('trace_id') or str(uuid.uuid4())
        span_id = str(uuid.uuid4())
        
        if self.tracer:
            span = self.tracer.create_span(
                trace_id, span_id, 
                operation_name=f"{source_service} -> {target_service}"
            )
        
        try:
            # 发现目标服务
            target_instances = await self.service_registry.discover_services(
                'default', target_service  # 简化：使用默认命名空间
            )
            
            if not target_instances:
                raise Exception(f"No instances found for service {target_service}")
            
            # 负载均衡选择实例
            selected_instance = await self.load_balancer.select_target(target_instances)
            
            if not selected_instance:
                raise Exception("No healthy instance available")
            
            # 熔断器检查
            circuit_breaker = self._get_circuit_breaker(target_service)
            if not await circuit_breaker.allow_request(selected_instance):
                raise Exception("Circuit breaker is open")
            
            # 限流检查
            rate_limiter = self._get_rate_limiter(target_service)
            if not await rate_limiter.allow_request(target_service):
                raise Exception("Rate limit exceeded")
            
            # 构建目标URL
            target_url = f"http://{selected_instance['ip']}:{selected_instance['port']}"
            endpoint = request.get('path', '/')
            full_url = f"{target_url}{endpoint}"
            
            # 发送请求
            start_time = time.time()
            
            async with aiohttp.ClientSession() as session:
                method = request.get('method', 'GET')
                async with session.request(method, full_url, 
                                         json=request.get('data')) as response:
                    response_data = await response.json()
                    
                    duration = time.time() - start_time
                    
                    # 记录指标
                    if self.metrics_collector:
                        self.metrics_collector.record_request(
                            method, endpoint, response.status, duration
                        )
                    
                    # 记录成功
                    await circuit_breaker.record_success()
                    
                    # 完成追踪
                    if self.tracer:
                        self.tracer.finish_span(span_id, {
                            'http.status_code': response.status,
                            'http.url': full_url,
                            'duration': duration
                        })
                    
                    return {
                        'success': True,
                        'status_code': response.status,
                        'data': response_data,
                        'trace_id': trace_id,
                        'span_id': span_id
                    }
        
        except Exception as e:
            # 记录错误
            if self.metrics_collector:
                self.metrics_collector.record_error('proxy_error')
            
            # 记录失败
            await circuit_breaker.record_failure()
            
            # 完成追踪
            if self.tracer:
                self.tracer.finish_span(span_id, {
                    'error': str(e),
                    'error.type': 'proxy_error'
                })
            
            return {
                'success': False,
                'error': str(e),
                'trace_id': trace_id,
                'span_id': span_id
            }
    
    def _get_circuit_breaker(self, service_name: str) -> CircuitBreaker:
        """获取熔断器"""
        if service_name not in self.circuit_breakers:
            self.circuit_breakers[service_name] = CircuitBreaker()
        return self.circuit_breakers[service_name]
    
    def _get_rate_limiter(self, service_name: str) -> RateLimiter:
        """获取限流器"""
        if service_name not in self.rate_limiters:
            self.rate_limiters[service_name] = RateLimiter(100, 60)  # 100 req/min
        return self.rate_limiters[service_name]
    
    def generate_mtls_certificates(self, service_name: str, namespace: str, 
                                 ip_addresses: List[str]):
        """生成mTLS证书"""
        return self.cert_manager.generate_service_certificate(
            service_name, namespace, ip_addresses
        )

# 使用示例
async def example_service_mesh():
    """服务网格使用示例"""
    
    # 创建服务网格
    mesh = SimpleServiceMesh()
    
    # 注册服务
    await mesh.register_service('user-service', 'default', {
        'instance_id': 'user-service-1',
        'ip': '10.0.1.1',
        'port': 8080,
        'health_check_url': 'http://10.0.1.1:8080/health'
    })
    
    await mesh.register_service('order-service', 'default', {
        'instance_id': 'order-service-1',
        'ip': '10.0.1.2',
        'port': 8080,
        'health_check_url': 'http://10.0.1.2:8080/health'
    })
    
    # 设置监控
    mesh.setup_monitoring('api-gateway')
    
    # 配置路由
    mesh.configure_route({
        'source': 'api-gateway',
        'destination': 'user-service',
        'path_pattern': '/api/users/.*'
    })
    
    # 生成mTLS证书
    cert_info = mesh.generate_mtls_certificates('user-service', 'default', 
                                               ['10.0.1.1', '10.0.1.1'])
    
    # 代理请求
    request = {
        'method': 'GET',
        'path': '/api/users/123',
        'headers': {'Content-Type': 'application/json'},
        'trace_id': '12345-67890-abcde'
    }
    
    response = await mesh.proxy_request('api-gateway', 'user-service', request)
    print(f"Response: {response}")
    
    # 获取指标
    if mesh.metrics_collector:
        metrics = mesh.metrics_collector.get_metrics()
        print(f"Metrics: {metrics}")
```

## 最佳实践

### 11. 服务网格部署与运维
```python
class ServiceMeshOperations:
    """服务网格运维"""
    
    def __init__(self, mesh: SimpleServiceMesh):
        self.mesh = mesh
        self.health_checks = {}
        self.alert_rules = []
        self.dashboard_configs = []
    
    def add_health_check(self, service_name: str, check_func: callable):
        """添加健康检查"""
        self.health_checks[service_name] = check_func
    
    def add_alert_rule(self, rule: Dict[str, Any]):
        """添加告警规则"""
        self.alert_rules.append(rule)
    
    def create_dashboard(self, name: str, panels: List[Dict[str, Any]]):
        """创建监控面板"""
        dashboard = {
            'name': name,
            'panels': panels,
            'created_at': time.time()
        }
        self.dashboard_configs.append(dashboard)
    
    async def health_check_loop(self):
        """健康检查循环"""
        while True:
            try:
                for service_name, check_func in self.health_checks.items():
                    try:
                        is_healthy = await check_func()
                        await self._handle_health_check_result(service_name, is_healthy)
                    except Exception as e:
                        print(f"Health check failed for {service_name}: {e}")
                
                await asyncio.sleep(30)  # 每30秒检查一次
                
            except asyncio.CancelledError:
                break
    
    async def _handle_health_check_result(self, service_name: str, is_healthy: bool):
        """处理健康检查结果"""
        if not is_healthy:
            print(f"ALERT: Service {service_name} is unhealthy")
            
            # 可以在这里添加自动恢复逻辑
            # 例如：重启服务实例、切换流量等
        else:
            print(f"Service {service_name} is healthy")
    
    async def monitor_performance(self):
        """性能监控"""
        while True:
            try:
                if self.mesh.metrics_collector:
                    # 获取性能指标
                    metrics = self.mesh.metrics_collector.get_metrics()
                    
                    # 检查告警规则
                    await self._check_alert_rules(metrics)
                    
                    # 更新监控面板数据
                    await self._update_dashboards(metrics)
                
                await asyncio.sleep(60)  # 每分钟收集一次指标
                
            except asyncio.CancelledError:
                break
    
    async def _check_alert_rules(self, metrics: Dict[str, Any]):
        """检查告警规则"""
        for rule in self.alert_rules:
            condition = rule['condition']
            threshold = condition['threshold']
            metric_name = condition['metric']
            
            if metric_name in metrics:
                current_value = metrics[metric_name]
                
                if condition['operator'] == '>' and current_value > threshold:
                    await self._trigger_alert(rule, current_value)
                elif condition['operator'] == '<' and current_value < threshold:
                    await self._trigger_alert(rule, current_value)
    
    async def _trigger_alert(self, rule: Dict[str, Any], current_value: float):
        """触发告警"""
        alert = {
            'rule_name': rule['name'],
            'severity': rule.get('severity', 'warning'),
            'message': rule['message'].format(value=current_value),
            'timestamp': time.time(),
            'value': current_value
        }
        
        print(f"ALERT: {alert}")
        
        # 这里可以集成各种告警渠道
        # - 发送邮件
        # - 发送钉钉/微信消息
        # - 调用PagerDuty API
        # - 发送Slack消息等
    
    async def _update_dashboards(self, metrics: Dict[str, Any]):
        """更新监控面板"""
        for dashboard in self.dashboard_configs:
            dashboard['last_updated'] = time.time()
            dashboard['current_metrics'] = metrics.copy()

class ServiceMeshSecurity:
    """服务网格安全"""
    
    def __init__(self, mesh: SimpleServiceMesh):
        self.mesh = mesh
        self.security_policies = []
        self.access_logs = []
    
    def add_security_policy(self, policy: Dict[str, Any]):
        """添加安全策略"""
        self.security_policies.append(policy)
    
    def add_access_control_rule(self, service: str, allowed_sources: List[str], 
                               permissions: List[str]):
        """添加访问控制规则"""
        rule = {
            'service': service,
            'allowed_sources': allowed_sources,
            'permissions': permissions,
            'created_at': time.time()
        }
        self.security_policies.append(rule)
    
    def log_access(self, source_service: str, target_service: str, 
                  action: str, result: str, trace_id: str = None):
        """记录访问日志"""
        log_entry = {
            'timestamp': time.time(),
            'source_service': source_service,
            'target_service': target_service,
            'action': action,
            'result': result,
            'trace_id': trace_id
        }
        
        self.access_logs.append(log_entry)
        
        # 保持日志数量限制
        if len(self.access_logs) > 10000:
            self.access_logs = self.access_logs[-5000:]
    
    async def check_access_control(self, source_service: str, 
                                  target_service: str, action: str) -> bool:
        """检查访问控制"""
        # 检查安全策略
        for policy in self.security_policies:
            if policy['service'] == target_service:
                if source_service not in policy.get('allowed_sources', []):
                    self.log_access(source_service, target_service, action, 'denied')
                    return False
        
        self.log_access(source_service, target_service, action, 'allowed')
        return True
    
    def get_security_report(self) -> Dict[str, Any]:
        """获取安全报告"""
        total_accesses = len(self.access_logs)
        denied_accesses = len([log for log in self.access_logs if log['result'] == 'denied'])
        
        # 服务间访问统计
        service_access_stats = {}
        for log in self.access_logs:
            target = log['target_service']
            if target not in service_access_stats:
                service_access_stats[target] = {'total': 0, 'denied': 0}
            
            service_access_stats[target]['total'] += 1
            if log['result'] == 'denied':
                service_access_stats[target]['denied'] += 1
        
        return {
            'total_accesses': total_accesses,
            'denied_accesses': denied_accesses,
            'allow_rate': (total_accesses - denied_accesses) / total_accesses if total_accesses > 0 else 1.0,
            'service_access_stats': service_access_stats,
            'security_policies_count': len(self.security_policies)
        }
```

### 12. 部署配置示例
```yaml
# service-mesh-deployment.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: service-mesh

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: control-plane
  namespace: service-mesh
spec:
  replicas: 3
  selector:
    matchLabels:
      app: control-plane
  template:
    metadata:
      labels:
        app: control-plane
    spec:
      containers:
      - name: control-plane
        image: service-mesh/control-plane:latest
        ports:
        - containerPort: 8080
        - containerPort: 9090
        env:
        - name: SERVICE_MESH_CONFIG
          value: "/config/mesh-config.yaml"
        volumeMounts:
        - name: config
          mountPath: /config
        - name: certs
          mountPath: /etc/certs
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
      volumes:
      - name: config
        configMap:
          name: mesh-config
      - name: certs
        secret:
          secretName: mesh-ca-cert

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mesh-config
  namespace: service-mesh
data:
  mesh-config.yaml: |
    mesh:
      # mTLS配置
      mtls:
        enabled: true
        ca_cert: /etc/certs/ca.crt
        
      # 流量管理
      traffic_management:
        load_balancing:
          algorithm: "least_connections"
        circuit_breaker:
          failure_threshold: 5
          timeout: 60
        rate_limiting:
          default_rate: 100
          time_window: 60
      
      # 可观测性
      observability:
        metrics:
          enabled: true
          prometheus:
            enabled: true
        tracing:
          enabled: true
          jaeger:
            enabled: true
        logging:
          level: "info"
          
      # 安全策略
      security:
        authorization:
          enabled: true
        policy_enforcement: "allow_all"

---
apiVersion: v1
kind: Service
metadata:
  name: control-plane
  namespace: service-mesh
spec:
  selector:
    app: control-plane
  ports:
  - name: http
    port: 8080
    targetPort: 8080
  - name: metrics
    port: 9090
    targetPort: 9090

---
# 代理Sidecar部署示例
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:latest
        ports:
        - containerPort: 8080
      - name: mesh-proxy
        image: service-mesh/proxy:latest
        ports:
        - containerPort: 15001
        - containerPort: 15006
        env:
        - name: CONTROL_PLANE_ADDR
          value: "control-plane.service-mesh.svc.cluster.local:8080"
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP

---
apiVersion: v1
kind: Secret
metadata:
  name: mesh-ca-cert
  namespace: service-mesh
type: kubernetes.io/tls
data:
  tls.crt: <base64-encoded-cert>
  tls.key: <base64-encoded-key>
```

这个服务网格概述文档涵盖了服务网格的核心概念、架构设计、实现原理以及主流服务网格的详细分析。通过Python代码示例和配置示例，展示了如何构建一个功能完整的服务网格系统，包括流量管理、安全通信、可观测性等核心功能。