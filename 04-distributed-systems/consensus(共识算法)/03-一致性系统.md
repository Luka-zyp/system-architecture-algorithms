# Quorum Systems 详解

## 目录
1. [Quorum Systems概述](#quorum-systems概述)
2. [Quorum概念和原理](#quorum概念和原理)
3. [Majority Quorum](#majority-quorum)
4. [Weighted Quorum](#weighted-quorum)
5. [Grid Quorum](#grid-quorum)
6. [Tree Quorum](#tree-quorum)
7. [Civic Quorum](#civic-quorum)
8. [Dynamic Quorum](#dynamic-quorum)
9. [Python实现](#python实现)
10. [Go语言实现](#go语言实现)
11. [实际应用案例](#实际应用案例)
12. [性能优化](#性能优化)
13. [最佳实践](#最佳实践)

## Quorum Systems概述

### 什么是Quorum Systems

Quorum Systems是分布式系统中确保数据一致性和系统可靠性的重要机制。通过定义"多数"或"法定人数"的概念，确保在任何时刻都能达成一致的决策，即使在节点故障和网络分区的情况下也能保持系统的正确性。

```python
class QuorumSystemsIntro:
    """Quorum Systems介绍"""
    
    def __init__(self):
        self.core_concepts = {
            'quorum_definition': {
                'name': '法定人数定义',
                'explanation': 'Quorum是系统中参与决策的最小节点集合',
                'formula': '|Q| > N/2 (其中N是总节点数)',
                'purpose': '确保决策的权威性和唯一性'
            },
            'intersection_property': {
                'name': '交集性质',
                'explanation': '任意两个quorum之间必须有交集',
                'formula': '∀ Q1, Q2 ∈ F: Q1 ∩ Q2 ≠ ∅',
                'purpose': '确保新决策能看到之前的决策'
            },
            'availability_property': {
                'name': '可用性性质',
                'explanation': '在大多数节点可用时，系统必须能够形成quorum',
                'formula': '|Q| ≤ N - f (其中f是故障节点数)',
                'purpose': '在部分节点故障时仍能正常工作'
            }
        }
        
        self.application_scenarios = {
            'distributed_consensus': {
                'name': '分布式共识',
                'examples': ['Paxos', 'Raft', 'PBFT'],
                'benefit': '确保所有节点达成一致的决定'
            },
            'replication_management': {
                'name': '复制管理',
                'examples': ['Dynamo', 'Cassandra', 'BigTable'],
                'benefit': '管理数据副本的一致性'
            },
            'mutual_exclusion': {
                'name': '互斥访问',
                'examples': ['分布式锁', '临界资源访问'],
                'benefit': '确保资源的排他性访问'
            },
            'leader_election': {
                'name': '领导者选举',
                'examples': ['ZooKeeper', 'Etcd'],
                'benefit': '选举唯一的领导者'
            }
        }
    
    def explain_concepts(self):
        """解释基本概念"""
        print("=== Quorum Systems Core Concepts ===\n")
        
        for concept, info in self.core_concepts.items():
            print(f"**{info['name']}**")
            print(f"解释: {info['explanation']}")
            if 'formula' in info:
                print(f"公式: {info['formula']}")
            print(f"目的: {info['purpose']}\n")
        
        print("=== Application Scenarios ===\n")
        
        for scenario, info in self.application_scenarios.items():
            print(f"**{info['name']}**")
            print(f"例子: {', '.join(info['examples'])}")
            print(f"优势: {info['benefit']}\n")

class QuorumHistory:
    """Quorum Systems发展历史"""
    
    def __init__(self):
        self.evolution = {
            '1970s': {
                'milestone': 'Basic Quorum Systems',
                'contribution': '简单的多数quorum机制',
                'limitation': '固定的节点数，无法适应动态环境'
            },
            '1980s': {
                'milestone': 'Weighted Quorum',
                'contribution': '引入权重概念，不同节点有不同的投票权',
                'limitation': '权重分配复杂，管理困难'
            },
            '1990s': {
                'milestone': 'Hierarchical Quorum',
                'contribution': '层次化quorum系统，提高扩展性',
                'limitation': '实现复杂，需要维护层次结构'
            },
            '2000s': {
                'milestone': 'Dynamic Quorum',
                'contribution': '动态调整quorum大小，适应节点变化',
                'limitation': '算法复杂，需要额外的协调机制'
            },
            '2010s+': {
                'milestone': 'Modern Applications',
                'contribution': '云原生环境下的自适应quorum系统',
                'limitation': '需要在性能和可用性之间平衡'
            }
        }
    
    def show_evolution(self):
        """展示发展历史"""
        print("=== Quorum Systems Evolution ===\n")
        
        for era, info in self.evolution.items():
            print(f"**{era}: {info['milestone']}**")
            print(f"贡献: {info['contribution']}")
            print(f"限制: {info['limitation']}\n")

# 运行示例
if __name__ == "__main__":
    print("=== Quorum Systems Introduction ===")
    
    intro = QuorumSystemsIntro()
    intro.explain_concepts()
    
    history = QuorumHistory()
    history.show_evolution()
```

## Quorum概念和原理

### 基本原理

```python
class QuorumPrinciples:
    """Quorum基本原理"""
    
    def __init__(self, total_nodes: int):
        self.total_nodes = total_nodes
        self.min_quorum = total_nodes // 2 + 1
        self.max_faults = (total_nodes - 1) // 2
    
    def calculate_basic_quorum(self) -> dict:
        """计算基本quorum参数"""
        return {
            'total_nodes': self.total_nodes,
            'minimum_quorum': self.min_quorum,
            'maximum_faults': self.max_faults,
            'quorum_percentage': (self.min_quorum / self.total_nodes) * 100,
            'fault_tolerance': (self.max_faults / self.total_nodes) * 100
        }
    
    def verify_intersection_property(self, quorums: list) -> bool:
        """验证交集性质"""
        for i in range(len(quorums)):
            for j in range(i + 1, len(quorums)):
                if len(set(quorums[i]) & set(quorums[j])) == 0:
                    return False
        return True
    
    def calculate_quorum_intersection(self, quorums: list) -> dict:
        """计算quorum交集"""
        intersections = []
        
        for i in range(len(quorums)):
            for j in range(i + 1, len(quorums)):
                intersection = set(quorums[i]) & set(quorums[j])
                intersections.append({
                    'quorum1': quorums[i],
                    'quorum2': quorums[j],
                    'intersection': list(intersection),
                    'size': len(intersection)
                })
        
        return intersections

class QuorumTypes:
    """Quorum类型分析"""
    
    def __init__(self):
        self.quorum_types = {
            'read_quorum': {
                'name': '读Quorum',
                'purpose': '确保读操作能看到最新数据',
                'condition': 'R + W > N',
                'characteristics': [
                    '确保读操作的一致性',
                    '可以容忍部分副本不可用',
                    '支持读写分离优化'
                ]
            },
            'write_quorum': {
                'name': '写Quorum',
                'purpose': '确保写操作被正确执行',
                'condition': 'R + W > N',
                'characteristics': [
                    '确保写操作的成功',
                    '保证数据的持久性',
                    '避免写写冲突'
                ]
            },
            'majority_quorum': {
                'name': '多数Quorum',
                'purpose': '最基本的quorum机制',
                'condition': '|Q| > N/2',
                'characteristics': [
                    '最简单的实现',
                    '最强的一致性保证',
                    '适用于小规模集群'
                ]
            },
            'any_quorum': {
                'name': '任意Quorum',
                'purpose': '最小化参与节点数',
                'condition': '|Q| ≥ 1',
                'characteristics': [
                    '最高可用性',
                    '最弱一致性',
                    '需要额外机制保证一致性'
                ]
            }
        }
    
    def analyze_quorum_tradeoffs(self) -> dict:
        """分析quorum权衡"""
        return {
            'consistency_vs_availability': {
                'consistency_high': 'Large quorums (e.g., majority)',
                'consistency_low': 'Small quorums (e.g., any)',
                'availability_high': 'Small quorums',
                'availability_low': 'Large quorums'
            },
            'performance_tradeoffs': {
                'latency': 'Smaller quorums = lower latency',
                'throughput': 'Larger quorums = lower throughput',
                'scalability': 'Hierarchical quorums = better scalability'
            },
            'fault_tolerance': {
                'byzantine_faults': 'Requires > 2f + 1 nodes',
                'crash_faults': 'Requires > f + 1 nodes',
                'network_partitions': 'Majority quorums handle partitions well'
            }
        }

# 基本原理演示
def demo_quorum_principles():
    """演示Quorum基本原理"""
    
    print("=== Quorum Principles Demo ===\n")
    
    # 创建不同规模的集群
    cluster_sizes = [3, 5, 7, 9, 11]
    
    for size in cluster_sizes:
        principles = QuorumPrinciples(size)
        params = principles.calculate_basic_quorum()
        
        print(f"**Cluster Size: {size} nodes**")
        print(f"  Minimum Quorum: {params['minimum_quorum']}")
        print(f"  Max Faults: {params['maximum_faults']}")
        print(f"  Quorum Percentage: {params['quorum_percentage']:.1f}%")
        print(f"  Fault Tolerance: {params['fault_tolerance']:.1f}%")
        print()
    
    # 验证交集性质
    print("=== Intersection Property Verification ===")
    quorums = [
        [1, 2, 3],
        [2, 3, 4],
        [3, 4, 5],
        [1, 3, 5]
    ]
    
    principles = QuorumPrinciples(5)
    is_valid = principles.verify_intersection_property(quorums)
    
    print(f"Quorums: {quorums}")
    print(f"Intersection property satisfied: {is_valid}")
    
    if is_valid:
        intersections = principles.calculate_quorum_intersection(quorums)
        print("\nQuorum Intersections:")
        for inter in intersections:
            print(f"  Q{quorums.index(inter['quorum1'])} ∩ Q{quorums.index(inter['quorum2'])} = {inter['intersection']}")
    
    print("\n=== Quorum Types Analysis ===")
    types = QuorumTypes()
    for qtype, info in types.quorum_types.items():
        print(f"**{info['name']}**")
        print(f"  Purpose: {info['purpose']}")
        print(f"  Condition: {info['condition']}")
        print(f"  Characteristics:")
        for char in info['characteristics']:
            print(f"    • {char}")
        print()

if __name__ == "__main__":
    demo_quorum_principles()
```

## Majority Quorum

```python
import random
from typing import List, Set, Dict
from dataclasses import dataclass
from enum import Enum

@dataclass
class NodeState:
    """节点状态"""
    node_id: str
    is_healthy: bool
    last_heartbeat: float
    value: str = None

class MajorityQuorumSystem:
    """多数Quorum系统实现"""
    
    def __init__(self, node_ids: List[str]):
        self.node_ids = node_ids
        self.total_nodes = len(node_ids)
        self.min_quorum = self.total_nodes // 2 + 1
        self.node_states: Dict[str, NodeState] = {}
        
        # 初始化节点状态
        for node_id in node_ids:
            self.node_states[node_id] = NodeState(
                node_id=node_id,
                is_healthy=True,
                last_heartbeat=0.0
            )
    
    def get_healthy_nodes(self) -> Set[str]:
        """获取健康节点集合"""
        healthy_nodes = set()
        for node_id, state in self.node_states.items():
            if state.is_healthy:
                healthy_nodes.add(node_id)
        return healthy_nodes
    
    def can_form_quorum(self) -> bool:
        """检查是否可以形成quorum"""
        return len(self.get_healthy_nodes()) >= self.min_quorum
    
    def select_quorum(self) -> List[str]:
        """选择quorum节点"""
        if not self.can_form_quorum():
            return []
        
        healthy_nodes = list(self.get_healthy_nodes())
        # 随机选择quorum（实际应用中可以根据特定策略）
        return random.sample(healthy_nodes, self.min_quorum)
    
    def simulate_node_failure(self, node_id: str):
        """模拟节点故障"""
        if node_id in self.node_states:
            self.node_states[node_id].is_healthy = False
            print(f"Node {node_id} failed")
    
    def simulate_node_recovery(self, node_id: str):
        """模拟节点恢复"""
        if node_id in self.node_states:
            self.node_states[node_id].is_healthy = True
            self.node_states[node_id].last_heartbeat = 0.0
            print(f"Node {node_id} recovered")
    
    def execute_operation(self, operation: str, value: str) -> bool:
        """执行操作"""
        if not self.can_form_quorum():
            print(f"Cannot execute {operation}: insufficient healthy nodes")
            return False
        
        quorum = self.select_quorum()
        print(f"Executing {operation} on quorum: {quorum}")
        
        # 模拟在quorum上执行操作
        success_count = 0
        for node_id in quorum:
            # 模拟操作成功（90%成功率）
            if random.random() < 0.9:
                self.node_states[node_id].value = value
                success_count += 1
        
        if success_count >= self.min_quorum // 2 + 1:
            print(f"{operation} succeeded on {success_count}/{len(quorum)} nodes")
            return True
        else:
            print(f"{operation} failed: only {success_count}/{len(quorum)} nodes succeeded")
            return False
    
    def check_consistency(self) -> bool:
        """检查数据一致性"""
        values = []
        for state in self.node_states.values():
            if state.is_healthy and state.value is not None:
                values.append(state.value)
        
        if not values:
            return True
        
        # 检查所有健康节点的值是否一致
        unique_values = set(values)
        return len(unique_values) <= 1
    
    def get_system_status(self) -> dict:
        """获取系统状态"""
        healthy_nodes = self.get_healthy_nodes()
        return {
            'total_nodes': self.total_nodes,
            'healthy_nodes': len(healthy_nodes),
            'min_quorum': self.min_quorum,
            'can_form_quorum': self.can_form_quorum(),
            'node_states': {nid: {'healthy': state.is_healthy, 'value': state.value} 
                          for nid, state in self.node_states.items()},
            'is_consistent': self.check_consistency()
        }

class FaultToleranceAnalysis:
    """容错能力分析"""
    
    @staticmethod
    def calculate_fault_tolerance(total_nodes: int) -> dict:
        """计算容错能力"""
        min_quorum = total_nodes // 2 + 1
        max_faults = total_nodes - min_quorum
        
        return {
            'total_nodes': total_nodes,
            'min_quorum': min_quorum,
            'max_faults': max_faults,
            'fault_tolerance_percentage': (max_faults / total_nodes) * 100,
            'quorum_percentage': (min_quorum / total_nodes) * 100,
            'available_nodes_after_max_faults': total_nodes - max_faults
        }
    
    @staticmethod
    def simulate_scenarios():
        """模拟不同故障场景"""
        scenarios = {
            'no_failure': {'failed_nodes': 0, 'description': '无故障'},
            'single_failure': {'failed_nodes': 1, 'description': '单节点故障'},
            'majority_failure': {'failed_nodes': 2, 'description': '多数节点故障'},
            'cluster_down': {'failed_nodes': 3, 'description': '集群宕机'}
        }
        
        cluster_sizes = [3, 5, 7, 9]
        
        for size in cluster_sizes:
            print(f"\n**Cluster Size: {size} nodes**")
            analysis = FaultToleranceAnalysis()
            
            for scenario, info in scenarios.items():
                fault_info = analysis.calculate_fault_tolerance(size)
                failed = info['failed_nodes']
                healthy = size - failed
                can_operate = healthy >= fault_info['min_quorum']
                
                print(f"  {info['description']}: {failed} failed, {healthy} healthy, "
                      f"Can operate: {'Yes' if can_operate else 'No'}")

# Majority Quorum演示
def demo_majority_quorum():
    """演示Majority Quorum系统"""
    
    print("=== Majority Quorum System Demo ===\n")
    
    # 创建5节点集群
    nodes = ['node1', 'node2', 'node3', 'node4', 'node5']
    quorum_system = MajorityQuorumSystem(nodes)
    
    print(f"Created cluster with {len(nodes)} nodes")
    print(f"Minimum quorum: {quorum_system.min_quorum}")
    print(f"Maximum faults: {quorum_system.total_nodes - quorum_system.min_quorum}")
    
    # 初始状态
    print("\n=== Initial State ===")
    status = quorum_system.get_system_status()
    print(f"System status: {status}")
    
    # 执行写操作
    print("\n=== Write Operation ===")
    success = quorum_system.execute_operation("WRITE", "initial_value")
    print(f"Write result: {success}")
    
    # 检查一致性
    print(f"System consistent: {quorum_system.check_consistency()}")
    
    # 模拟节点故障
    print("\n=== Simulate Node Failures ===")
    quorum_system.simulate_node_failure('node1')
    time.sleep(0.5)
    print(f"After node1 failure: {quorum_system.can_form_quorum()}")
    
    # 仍然可以操作
    print("\n=== Operation During Single Failure ===")
    success = quorum_system.execute_operation("UPDATE", "updated_value")
    print(f"Update result: {success}")
    
    # 模拟更多节点故障
    print("\n=== Multiple Node Failures ===")
    quorum_system.simulate_node_failure('node2')
    time.sleep(0.5)
    print(f"After node2 failure: {quorum_system.can_form_quorum()}")
    
    # 检查系统状态
    final_status = quorum_system.get_system_status()
    print(f"Final system status: {final_status}")
    
    # 容错分析
    print("\n=== Fault Tolerance Analysis ===")
    FaultToleranceAnalysis.simulate_scenarios()

if __name__ == "__main__":
    import time
    demo_majority_quorum()
```

## Weighted Quorum

```python
@dataclass
class WeightedNode:
    """加权节点"""
    node_id: str
    weight: int
    is_healthy: bool = True
    value: str = None

class WeightedQuorumSystem:
    """加权Quorum系统实现"""
    
    def __init__(self, weighted_nodes: List[WeightedNode]):
        self.weighted_nodes = weighted_nodes
        self.total_weight = sum(node.weight for node in weighted_nodes)
        self.min_weight = self.total_weight // 2 + 1
        
        # 按权重排序，便于选择
        self.weighted_nodes.sort(key=lambda x: x.weight, reverse=True)
    
    def get_healthy_nodes(self) -> List[WeightedNode]:
        """获取健康节点"""
        return [node for node in self.weighted_nodes if node.is_healthy]
    
    def can_form_weighted_quorum(self) -> bool:
        """检查是否可以形成加权quorum"""
        return sum(node.weight for node in self.get_healthy_nodes()) >= self.min_weight
    
    def select_weighted_quorum(self) -> List[WeightedNode]:
        """选择加权quorum节点"""
        if not self.can_form_weighted_quorum():
            return []
        
        healthy_nodes = self.get_healthy_nodes()
        selected = []
        current_weight = 0
        
        # 贪心算法：优先选择权重高的节点
        for node in healthy_nodes:
            if current_weight >= self.min_weight:
                break
            
            # 添加当前节点
            selected.append(node)
            current_weight += node.weight
            
            # 如果还没达到最小权重，继续添加
            if current_weight < self.min_weight and node != healthy_nodes[-1]:
                continue
        
        return selected
    
    def execute_weighted_operation(self, operation: str, value: str) -> bool:
        """执行加权操作"""
        if not self.can_form_weighted_quorum():
            print(f"Cannot execute {operation}: insufficient healthy weight")
            return False
        
        quorum = self.select_weighted_quorum()
        quorum_weight = sum(node.weight for node in quorum)
        
        print(f"Executing {operation} on weighted quorum:")
        for node in quorum:
            print(f"  {node.node_id} (weight: {node.weight})")
        print(f"Total quorum weight: {quorum_weight}/{self.min_weight}")
        
        # 模拟操作
        success_weight = 0
        for node in quorum:
            # 模拟操作成功（95%成功率）
            if random.random() < 0.95:
                node.value = value
                success_weight += node.weight
        
        if success_weight >= self.min_weight:
            print(f"{operation} succeeded with weight {success_weight}")
            return True
        else:
            print(f"{operation} failed: only {success_weight} weight succeeded")
            return False
    
    def simulate_weighted_failure(self, node_id: str):
        """模拟节点故障"""
        for node in self.weighted_nodes:
            if node.node_id == node_id:
                node.is_healthy = False
                print(f"Node {node_id} (weight: {node.weight}) failed")
                break
    
    def simulate_weighted_recovery(self, node_id: str):
        """模拟节点恢复"""
        for node in self.weighted_nodes:
            if node.node_id == node_id:
                node.is_healthy = True
                node.value = None
                print(f"Node {node_id} (weight: {node.weight}) recovered")
                break
    
    def get_weighted_status(self) -> dict:
        """获取加权系统状态"""
        healthy_nodes = self.get_healthy_nodes()
        healthy_weight = sum(node.weight for node in healthy_nodes)
        
        return {
            'total_nodes': len(self.weighted_nodes),
            'total_weight': self.total_weight,
            'healthy_weight': healthy_weight,
            'min_weight': self.min_weight,
            'can_form_quorum': self.can_form_weighted_quorum(),
            'nodes': [{'id': node.node_id, 'weight': node.weight, 
                      'healthy': node.is_healthy, 'value': node.value} 
                     for node in self.weighted_nodes]
        }

# Weighted Quorum演示
def demo_weighted_quorum():
    """演示Weighted Quorum系统"""
    
    print("=== Weighted Quorum System Demo ===\n")
    
    # 创建不同权重的节点
    # 在云环境中，不同区域的数据中心可能有不同的权重
    weighted_nodes = [
        WeightedNode('us-east-1', weight=30, is_healthy=True),  # 主要数据中心
        WeightedNode('us-west-1', weight=25, is_healthy=True),  # 次要数据中心
        WeightedNode('eu-central-1', weight=20, is_healthy=True),  # 欧洲数据中心
        WeightedNode('ap-southeast-1', weight=15, is_healthy=True),  # 亚太数据中心
        WeightedNode('ap-south-1', weight=10, is_healthy=True),   # 印度数据中心
    ]
    
    weighted_quorum = WeightedQuorumSystem(weighted_nodes)
    
    print(f"Created weighted cluster:")
    for node in weighted_quorum.weighted_nodes:
        print(f"  {node.node_id}: weight={node.weight}")
    print(f"Total weight: {weighted_quorum.total_weight}")
    print(f"Minimum quorum weight: {weighted_quorum.min_weight}")
    
    # 初始操作
    print("\n=== Initial Write Operation ===")
    success = weighted_quorum.execute_weighted_operation("WRITE", "global_config_v1")
    
    # 模拟主要数据中心故障
    print("\n=== Simulate Primary Data Center Failure ===")
    weighted_quorum.simulate_weighted_failure('us-east-1')
    
    status = weighted_quorum.get_weighted_status()
    print(f"After failure: can form quorum = {status['can_form_quorum']}")
    print(f"Healthy weight: {status['healthy_weight']}/{status['total_weight']}")
    
    # 在部分故障情况下执行操作
    print("\n=== Operation During Partial Failure ===")
    success = weighted_quorum.execute_weighted_operation("UPDATE", "global_config_v2")
    
    # 模拟更多故障
    print("\n=== Multiple Node Failures ===")
    weighted_quorum.simulate_weighted_failure('us-west-1')
    weighted_quorum.simulate_weighted_failure('eu-central-1')
    
    final_status = weighted_quorum.get_weighted_status()
    print(f"Final status: can form quorum = {final_status['can_form_quorum']}")
    
    # 恢复节点
    print("\n=== Node Recovery ===")
    weighted_quorum.simulate_weighted_recovery('us-east-1')
    weighted_quorum.simulate_weighted_recovery('us-west-1')
    
    recovery_status = weighted_quorum.get_weighted_status()
    print(f"After recovery: can form quorum = {recovery_status['can_form_quorum']}")
    
    # 恢复后操作
    print("\n=== Operation After Recovery ===")
    success = weighted_quorum.execute_weighted_operation("FINAL_UPDATE", "global_config_v3")

if __name__ == "__main__":
    demo_weighted_quorum()
```

## Grid Quorum

```python
import numpy as np
from typing import Tuple, List

class GridQuorumSystem:
    """Grid Quorum系统实现"""
    
    def __init__(self, rows: int, cols: int):
        self.rows = rows
        self.cols = cols
        self.total_nodes = rows * cols
        self.grid = np.zeros((rows, cols), dtype=object)
        
        # 初始化网格节点
        for i in range(rows):
            for j in range(cols):
                self.grid[i][j] = {
                    'node_id': f'node_{i}_{j}',
                    'healthy': True,
                    'value': None,
                    'version': 0
                }
    
    def get_quorum_row(self, row: int) -> List[dict]:
        """获取整行作为quorum"""
        return [self.grid[row][j] for j in range(self.cols)]
    
    def get_quorum_col(self, col: int) -> List[dict]:
        """获取整列作为quorum"""
        return [self.grid[i][col] for i in range(self.rows)]
    
    def get_quorum_grid(self, rows: List[int], cols: List[int]) -> List[dict]:
        """获取网格子集作为quorum"""
        quorum = []
        for i in rows:
            for j in cols:
                quorum.append(self.grid[i][j])
        return quorum
    
    def select_grid_quorum(self) -> Tuple[List[dict], str]:
        """选择Grid Quorum（行优先或列优先）"""
        # 计算行quorum和列quorum的大小
        row_quorum_size = self.rows // 2 + 1
        col_quorum_size = self.cols // 2 + 1
        
        # 检查所有行是否可形成quorum
        best_row_quorum = None
        max_healthy_in_row = 0
        
        for i in range(self.rows):
            row_nodes = self.get_quorum_row(i)
            healthy_count = sum(1 for node in row_nodes if node['healthy'])
            
            if healthy_count >= row_quorum_size and healthy_count > max_healthy_in_row:
                max_healthy_in_row = healthy_count
                best_row_quorum = row_nodes
        
        # 检查所有列是否可形成quorum
        best_col_quorum = None
        max_healthy_in_col = 0
        
        for j in range(self.cols):
            col_nodes = self.get_quorum_col(j)
            healthy_count = sum(1 for node in col_nodes if node['healthy'])
            
            if healthy_count >= col_quorum_size and healthy_count > max_healthy_in_col:
                max_healthy_in_col = healthy_count
                best_col_quorum = col_nodes
        
        # 选择更优的quorum
        if best_row_quorum and best_col_quorum:
            if max_healthy_in_row >= max_healthy_in_col:
                return best_row_quorum, "row"
            else:
                return best_col_quorum, "col"
        elif best_row_quorum:
            return best_row_quorum, "row"
        elif best_col_quorum:
            return best_col_quorum, "col"
        else:
            return [], "none"
    
    def execute_grid_operation(self, operation: str, value: str) -> bool:
        """执行Grid操作"""
        quorum, strategy = self.select_grid_quorum()
        
        if not quorum:
            print(f"Cannot execute {operation}: insufficient healthy nodes")
            return False
        
        print(f"Executing {operation} using {strategy} quorum strategy:")
        for node in quorum:
            if node['healthy']:
                print(f"  {node['node_id']}")
        
        # 执行操作
        success_count = 0
        for node in quorum:
            if node['healthy'] and random.random() < 0.95:
                node['value'] = value
                node['version'] += 1
                success_count += 1
        
        row_quorum_size = self.rows // 2 + 1
        col_quorum_size = self.cols // 2 + 1
        
        required_success = min(row_quorum_size, col_quorum_size)
        
        if success_count >= required_success:
            print(f"{operation} succeeded on {success_count}/{len(quorum)} nodes")
            return True
        else:
            print(f"{operation} failed: only {success_count} nodes succeeded")
            return False
    
    def simulate_grid_failure(self, row: int, col: int):
        """模拟网格节点故障"""
        if 0 <= row < self.rows and 0 <= col < self.cols:
            self.grid[row][col]['healthy'] = False
            print(f"Node {self.grid[row][col]['node_id']} failed")
    
    def simulate_grid_recovery(self, row: int, col: int):
        """模拟网格节点恢复"""
        if 0 <= row < self.rows and 0 <= col < self.cols:
            self.grid[row][col]['healthy'] = True
            self.grid[row][col]['value'] = None
            self.grid[row][col]['version'] = 0
            print(f"Node {self.grid[row][col]['node_id']} recovered")
    
    def get_grid_status(self) -> dict:
        """获取网格状态"""
        healthy_count = 0
        total_nodes = self.rows * self.cols
        
        for i in range(self.rows):
            for j in range(self.cols):
                if self.grid[i][j]['healthy']:
                    healthy_count += 1
        
        return {
            'grid_size': f'{self.rows}x{self.cols}',
            'total_nodes': total_nodes,
            'healthy_nodes': healthy_count,
            'health_percentage': (healthy_count / total_nodes) * 100,
            'row_quorum_size': self.rows // 2 + 1,
            'col_quorum_size': self.cols // 2 + 1,
            'can_form_quorum': self.select_grid_quorum()[0] != []
        }

# Grid Quorum演示
def demo_grid_quorum():
    """演示Grid Quorum系统"""
    
    print("=== Grid Quorum System Demo ===\n")
    
    # 创建4x4网格
    grid_system = GridQuorumSystem(4, 4)
    
    print(f"Created {grid_system.rows}x{grid_system.cols} grid:")
    print(f"Row quorum size: {grid_system.rows // 2 + 1}")
    print(f"Column quorum size: {grid_system.cols // 2 + 1}")
    
    # 初始操作
    print("\n=== Initial Grid Operation ===")
    success = grid_system.execute_grid_operation("GRID_WRITE", "grid_data_v1")
    
    # 显示网格状态
    print("\n=== Grid Status ===")
    for i in range(grid_system.rows):
        row_status = []
        for j in range(grid_system.cols):
            node = grid_system.grid[i][j]
            status = 'H' if node['healthy'] else 'F'
            row_status.append(f"{status}({node['version']})")
        print(f"Row {i}: {' '.join(row_status)}")
    
    # 模拟部分节点故障
    print("\n=== Simulate Partial Failures ===")
    failed_positions = [(0, 0), (0, 1), (1, 1), (2, 2)]
    for row, col in failed_positions:
        grid_system.simulate_grid_failure(row, col)
    
    # 操作测试
    print("\n=== Operation During Partial Failures ===")
    success = grid_system.execute_grid_operation("GRID_UPDATE", "grid_data_v2")
    
    # 检查网格状态
    status = grid_system.get_grid_status()
    print(f"Grid status: {status}")
    
    # 模拟严重故障（破坏某一行）
    print("\n=== Simulate Row Failure ===")
    for col in range(grid_system.cols):
        grid_system.simulate_grid_failure(0, col)
    
    # 检查是否能继续操作
    print("\n=== Operation After Row Failure ===")
    success = grid_system.execute_grid_operation("GRID_FINAL", "grid_data_v3")
    
    # 恢复第一行
    print("\n=== Recovery ===")
    for col in range(grid_system.cols):
        grid_system.simulate_grid_recovery(0, col)
    
    final_status = grid_system.get_grid_status()
    print(f"Final grid status: {final_status}")

if __name__ == "__main__":
    demo_grid_quorum()
```

## Tree Quorum

```python
class TreeNode:
    """树节点"""
    
    def __init__(self, node_id: str, weight: int = 1):
        self.node_id = node_id
        self.weight = weight
        self.left = None
        self.right = None
        self.parent = None
        self.healthy = True
        self.value = None
        self.version = 0

class TreeQuorumSystem:
    """Tree Quorum系统实现"""
    
    def __init__(self):
        self.root = None
        self.all_nodes = {}
        self.quorum_size = 0
    
    def build_complete_tree(self, levels: int) -> 'TreeNode':
        """构建完全二叉树"""
        def create_node(level: int, pos: int) -> TreeNode:
            node_id = f"level_{level}_pos_{pos}"
            node = TreeNode(node_id, weight=2**(levels - level))
            self.all_nodes[node_id] = node
            
            if level < levels - 1:
                node.left = create_node(level + 1, pos * 2)
                node.left.parent = node
                node.right = create_node(level + 1, pos * 2 + 1)
                node.right.parent = node
            
            return node
        
        self.root = create_node(0, 0)
        self.quorum_size = 2**(levels - 1)
        return self.root
    
    def get_tree_leaves(self, node: TreeNode = None) -> List[TreeNode]:
        """获取所有叶子节点"""
        if node is None:
            node = self.root
        
        if node.left is None and node.right is None:
            return [node]
        
        leaves = []
        if node.left:
            leaves.extend(self.get_tree_leaves(node.left))
        if node.right:
            leaves.extend(self.get_tree_leaves(node.right))
        
        return leaves
    
    def get_subtree_weight(self, node: TreeNode) -> int:
        """计算子树权重"""
        if node is None:
            return 0
        
        weight = node.weight
        if node.left:
            weight += self.get_subtree_weight(node.left)
        if node.right:
            weight += self.get_subtree_weight(node.right)
        
        return weight
    
    def select_tree_quorum(self, node: TreeNode = None) -> List[TreeNode]:
        """选择Tree Quorum"""
        if node is None:
            node = self.root
        
        if node.healthy and self.get_subtree_weight(node) >= self.quorum_size:
            # 当前节点子树足以形成quorum
            return [node]
        
        quorum_nodes = []
        
        # 递归选择左右子树
        if node.left and node.left.healthy:
            left_quorum = self.select_tree_quorum(node.left)
            if left_quorum:
                quorum_nodes.extend(left_quorum)
        
        if node.right and node.right.healthy:
            right_quorum = self.select_tree_quorum(node.right)
            if right_quorum:
                quorum_nodes.extend(right_quorum)
        
        # 检查是否达到quorum要求
        total_weight = sum(self.get_subtree_weight(n) for n in quorum_nodes)
        if total_weight >= self.quorum_size:
            return quorum_nodes
        
        return []
    
    def execute_tree_operation(self, operation: str, value: str) -> bool:
        """执行Tree操作"""
        quorum = self.select_tree_quorum()
        
        if not quorum:
            print(f"Cannot execute {operation}: insufficient weight for quorum")
            return False
        
        print(f"Executing {operation} using tree quorum:")
        for node in quorum:
            print(f"  {node.node_id} (weight: {self.get_subtree_weight(node)})")
        
        # 执行操作
        success_weight = 0
        for node in quorum:
            if node.healthy and random.random() < 0.95:
                node.value = value
                node.version += 1
                success_weight += self.get_subtree_weight(node)
        
        if success_weight >= self.quorum_size:
            print(f"{operation} succeeded with weight {success_weight}")
            return True
        else:
            print(f"{operation} failed: only {success_weight} weight succeeded")
            return False
    
    def simulate_tree_failure(self, node_id: str):
        """模拟树节点故障"""
        if node_id in self.all_nodes:
            node = self.all_nodes[node_id]
            node.healthy = False
            print(f"Tree node {node_id} failed")
    
    def simulate_tree_recovery(self, node_id: str):
        """模拟树节点恢复"""
        if node_id in self.all_nodes:
            node = self.all_nodes[node_id]
            node.healthy = True
            node.value = None
            node.version = 0
            print(f"Tree node {node_id} recovered")
    
    def get_tree_status(self, node: TreeNode = None) -> dict:
        """获取树状态"""
        if node is None:
            node = self.root
        
        healthy_weight = self.get_subtree_weight(node) if node.healthy else 0
        
        def collect_node_info(current_node):
            if current_node is None:
                return []
            
            info = [{
                'node_id': current_node.node_id,
                'weight': current_node.weight,
                'subtree_weight': self.get_subtree_weight(current_node),
                'healthy': current_node.healthy,
                'value': current_node.value,
                'version': current_node.version
            }]
            
            info.extend(collect_node_info(current_node.left))
            info.extend(collect_node_info(current_node.right))
            
            return info
        
        return {
            'root_weight': self.get_subtree_weight(self.root),
            'quorum_size': self.quorum_size,
            'can_form_quorum': self.get_subtree_weight(self.root) >= self.quorum_size,
            'nodes': collect_node_info(self.root),
            'healthy_weight': healthy_weight
        }

# Tree Quorum演示
def demo_tree_quorum():
    """演示Tree Quorum系统"""
    
    print("=== Tree Quorum System Demo ===\n")
    
    # 创建4层完全二叉树（15个节点）
    tree_system = TreeQuorumSystem()
    root = tree_system.build_complete_tree(4)
    
    print("Built 4-level complete binary tree:")
    print(f"Total nodes: {len(tree_system.all_nodes)}")
    print(f"Root weight: {tree_system.get_subtree_weight(root)}")
    print(f"Quorum size: {tree_system.quorum_size}")
    
    # 初始操作
    print("\n=== Initial Tree Operation ===")
    success = tree_system.execute_tree_operation("TREE_WRITE", "tree_data_v1")
    
    # 显示树结构
    print("\n=== Tree Structure ===")
    def print_tree(node, level=0):
        if node is None:
            return
        
        indent = "  " * level
        status = "H" if node.healthy else "F"
        print(f"{indent}{node.node_id}: weight={node.weight}, status={status}, version={node.version}")
        
        if node.left:
            print_tree(node.left, level + 1)
        if node.right:
            print_tree(node.right, level + 1)
    
    print_tree(tree_system.root)
    
    # 模拟子节点故障
    print("\n=== Simulate Subtree Failures ===")
    # 故障左子树的某些叶子节点
    leaves = tree_system.get_tree_leaves()
    failed_leaves = leaves[:3]  # 前3个叶子节点故障
    for leaf in failed_leaves:
        tree_system.simulate_tree_failure(leaf.node_id)
    
    # 检查quorum选择
    print("\n=== Quorum Selection After Failures ===")
    quorum = tree_system.select_tree_quorum()
    print(f"Selected quorum nodes: {len(quorum)}")
    for node in quorum:
        print(f"  {node.node_id} (subtree weight: {tree_system.get_subtree_weight(node)})")
    
    # 操作测试
    print("\n=== Operation During Partial Failures ===")
    success = tree_system.execute_tree_operation("TREE_UPDATE", "tree_data_v2")
    
    # 模拟更严重故障
    print("\n=== Simulate Root Child Failure ===")
    if tree_system.root.left:
        tree_system.simulate_tree_failure(tree_system.root.left.node_id)
    
    print("\n=== Operation After Child Failure ===")
    success = tree_system.execute_tree_operation("TREE_FINAL", "tree_data_v3")
    
    # 恢复操作
    print("\n=== Recovery ===")
    for leaf in failed_leaves:
        tree_system.simulate_tree_recovery(leaf.node_id)
    if tree_system.root.left:
        tree_system.simulate_tree_recovery(tree_system.root.left.node_id)
    
    final_status = tree_system.get_tree_status()
    print(f"Final tree status: can_form_quorum = {final_status['can_form_quorum']}")
    
    # 恢复后操作
    print("\n=== Operation After Recovery ===")
    success = tree_system.execute_tree_operation("TREE_RECOVERED", "tree_data_final")

if __name__ == "__main__":
    demo_tree_quorum()
```

这个Quorum Systems学习文档涵盖了：

1. **系统概述**：基本概念、应用场景、发展历史
2. **基本原理**：交集性质、可用性、 quorum类型分析
3. **Majority Quorum**：最简单的quorum机制实现
4. **Weighted Quorum**：加权节点的支持
5. **Grid Quorum**：二维网格结构
6. **Tree Quorum**：层次化结构
7. **Python实现**：完整的代码示例
8. **实际应用**：各种场景的演示

文档提供了从基础概念到高级实现的完整学习路径，帮助深入理解不同quorum系统的原理和应用场景。