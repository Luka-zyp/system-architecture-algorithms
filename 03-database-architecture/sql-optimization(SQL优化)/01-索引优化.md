# 数据库索引优化详解

## 目录
1. [索引基础理论](#索引基础理论)
2. [索引类型](#索引类型)
3. [索引设计原则](#索引设计原则)
4. [索引优化实践](#索引优化实践)
5. [索引失效场景](#索引失效场景)
6. [性能监控](#性能监控)
7. [案例分析](#案例分析)

## 索引基础理论

### 什么是索引？

索引是一种数据结构，用于提高数据库查询速度。它类似于书籍的目录，能够快速定位到数据位置，而不需要全表扫描。

### 索引的工作原理

```python
# 简化版的B+树索引结构演示
class BPlusTreeIndex:
    def __init__(self):
        self.root = None
    
    def search(self, key):
        """搜索索引键值"""
        node = self.root
        while not node.is_leaf():
            node = self._find_child(node, key)
        return node.find(key)
    
    def insert(self, key, value):
        """插入键值对"""
        # B+树插入逻辑
        pass
```

### 索引的存储结构

```sql
-- 索引的物理存储结构
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(255) UNIQUE,
    name VARCHAR(100),
    created_at TIMESTAMP
);

-- 创建复合索引
CREATE INDEX idx_users_email_created 
ON users(email, created_at);

-- 创建部分索引（PostgreSQL）
CREATE INDEX idx_users_active 
ON users(created_at) 
WHERE status = 'active';
```

## 索引类型

### 1. B-Tree索引

最常用的索引类型，适用于范围查询和精确匹配。

```sql
-- 基础B-Tree索引
CREATE INDEX idx_users_email ON users(email);

-- 复合B-Tree索引
CREATE INDEX idx_users_name_age ON users(name, age);

-- 排序优化索引
CREATE INDEX idx_users_created_desc 
ON users(created_at DESC);
```

```python
# Python中索引优化示例
class UserRepository:
    def __init__(self, db_connection):
        self.db = db_connection
    
    # 利用复合索引进行优化查询
    def find_users_by_email_and_age(self, email, age):
        query = """
            SELECT id, email, name, age, created_at 
            FROM users 
            WHERE email = %s AND age = %s 
            ORDER BY created_at DESC
        """
        
        with self.db.cursor() as cursor:
            cursor.execute(query, (email, age))
            users = cursor.fetchall()
        
        return users
```

### 2. 哈希索引

适用于精确匹配查询，但不支持范围查询。

```sql
-- MySQL哈希索引（MEMORY引擎）
CREATE TABLE users_memory (
    id INT PRIMARY KEY,
    email VARCHAR(255),
    INDEX USING HASH (email)
) ENGINE=MEMORY;
```

### 3. 全文索引

适用于文本搜索场景。

```sql
-- MySQL全文索引
ALTER TABLE articles 
ADD FULLTEXT INDEX idx_article_content (title, content);

-- 使用全文搜索
SELECT * FROM articles 
WHERE MATCH(title, content) AGAINST('database optimization' IN NATURAL LANGUAGE MODE);
```

```python
# Python中使用全文搜索
def search_articles(db_connection, search_term):
    query = """
    SELECT id, title, content, 
           MATCH(title, content) AGAINST(%s IN NATURAL LANGUAGE MODE) as relevance
    FROM articles 
    WHERE MATCH(title, content) AGAINST(%s IN NATURAL LANGUAGE MODE)
    ORDER BY relevance DESC
    LIMIT 10
    """
    
    with db_connection.cursor() as cursor:
        cursor.execute(query, (search_term, search_term))
        return cursor.fetchall()
```

## 索引设计原则

### 1. 选择性原则

高选择性的列更适合建立索引。

```sql
-- 高选择性：性别字段选择性低（只有2个值）
CREATE INDEX idx_users_gender ON users(gender);  -- 不推荐

-- 高选择性：邮箱字段选择性强
CREATE INDEX idx_users_email ON users(email);    -- 推荐
```

```python
def calculate_selectivity(db_connection, column, table):
    """计算字段选择性"""
    query = f"""
    SELECT COUNT(DISTINCT {column}) * 100.0 / COUNT(*) as selectivity
    FROM {table}
    """
    
    with db_connection.cursor() as cursor:
        cursor.execute(query)
        result = cursor.fetchone()
        return result[0]
```

### 2. 最左前缀原则

复合索引从最左边开始使用才会生效。

```sql
-- 复合索引：(name, age, created_at)
-- 以下查询都能使用索引：
-- WHERE name = 'John'
-- WHERE name = 'John' AND age = 25
-- WHERE name = 'John' AND age = 25 AND created_at > '2023-01-01'

-- 以下查询不能使用索引：
-- WHERE age = 25  -- 跳过了name
-- WHERE created_at > '2023-01-01'  -- 跳过了name和age
```

### 3. 覆盖索引原则

查询的字段都包含在索引中，可以避免回表操作。

```sql
-- 覆盖索引示例
CREATE INDEX idx_users_email_info 
ON users(email, name, age);  -- 覆盖email、name、age三个字段

-- 如果查询只涉及这些字段，则不需要回表
SELECT email, name, age FROM users WHERE email = 'john@example.com';
```

## 索引优化实践

### 1. 慢查询分析与优化

```python
# 慢查询分析脚本
import mysql.connector
from datetime import datetime, timedelta

class QueryAnalyzer:
    def __init__(self, db_config):
        self.db = mysql.connector.connect(**db_config)
    
    def analyze_slow_queries(self):
        """分析慢查询"""
        query = """
        SELECT 
            query_time,
            lock_time,
            rows_sent,
            rows_examined,
            sql_text
        FROM mysql.slow_log 
        WHERE start_time > %s
        ORDER BY query_time DESC
        LIMIT 20
        """
        
        cutoff_time = datetime.now() - timedelta(days=7)
        
        with self.db.cursor() as cursor:
            cursor.execute(query, (cutoff_time,))
            return cursor.fetchall()
    
    def suggest_indexes(self, query):
        """根据查询建议索引"""
        # 解析查询语句，提取WHERE条件和ORDER BY
        # 建议相应的索引
        pass
```

### 2. 索引维护

```sql
-- MySQL索引维护
-- 分析表结构
ANALYZE TABLE users;

-- 优化表
OPTIMIZE TABLE users;

-- 检查索引使用情况
SHOW INDEX FROM users;

-- 删除未使用的索引
DROP INDEX idx_unused_index ON users;
```

```go
// Go语言中的索引维护
func (r *UserRepository) AnalyzeTable() error {
    query := "ANALYZE TABLE users"
    
    _, err := r.db.Exec(query)
    return err
}

func (r *UserRepository) CheckIndexUsage() ([]IndexUsage, error) {
    query := `
    SELECT 
        TABLE_SCHEMA,
        TABLE_NAME,
        INDEX_NAME,
        CARDINALITY,
        SUB_PART,
        NULLABLE,
        INDEX_TYPE
    FROM INFORMATION_SCHEMA.STATISTICS 
    WHERE TABLE_NAME = 'users'
    `
    
    rows, err := r.db.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var indexUsages []IndexUsage
    for rows.Next() {
        var usage IndexUsage
        err := rows.Scan(
            &usage.Schema, &usage.TableName, &usage.IndexName,
            &usage.Cardinality, &usage.SubPart, &usage.Nullable, &usage.IndexType,
        )
        if err != nil {
            return nil, err
        }
        indexUsages = append(indexUsages, usage)
    }
    return indexUsages, nil
}
```

## 索引失效场景

### 1. 函数操作

```sql
-- 失效：使用了函数
SELECT * FROM users WHERE LOWER(email) = 'john@example.com';

-- 正确：避免在索引列上使用函数
SELECT * FROM users WHERE email = LOWER('JOHN@EXAMPLE.COM');
```

### 2. 类型转换

```sql
-- 失效：类型不匹配
SELECT * FROM users WHERE id = '123';  -- id是数字类型

-- 正确：类型匹配
SELECT * FROM users WHERE id = 123;
```

### 3. LIKE模糊查询

```sql
-- 失效：通配符在前面
SELECT * FROM users WHERE email LIKE '%@gmail.com';

-- 正确：通配符在后面
SELECT * FROM users WHERE email LIKE 'john%';
```

```python
# 优化模糊查询的方案
def optimize_like_query(email_suffix):
    # 方案1：使用反向索引
    query = """
    SELECT id, email, name FROM users 
    WHERE reverse_email LIKE reverse(?)
    """
    
    # 方案2：使用全文搜索
    query = """
    SELECT id, email, name FROM users 
    WHERE MATCH(email) AGAINST(? IN NATURAL LANGUAGE MODE)
    """
    
    return query, f'%{email_suffix}'
```

## 性能监控

### 1. 索引使用统计

```sql
-- 查看索引使用统计
SHOW STATUS LIKE 'Handler_read%';

-- 查看索引大小
SELECT 
    TABLE_NAME,
    ROUND(((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024), 2) AS 'Size (MB)'
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = 'your_database'
AND TABLE_NAME = 'users';
```

```python
class IndexMonitor:
    def __init__(self, db_connection):
        self.db = db_connection
    
    def get_index_stats(self):
        """获取索引统计信息"""
        query = """
        SELECT 
            TABLE_NAME,
            INDEX_NAME,
            NON_UNIQUE,
            CARDINALITY,
            SUB_PART,
            NULLABLE,
            INDEX_TYPE
        FROM INFORMATION_SCHEMA.STATISTICS
        WHERE TABLE_SCHEMA = DATABASE()
        ORDER BY TABLE_NAME, INDEX_NAME
        """
        
        with self.db.cursor() as cursor:
            cursor.execute(query)
            return cursor.fetchall()
    
    def monitor_index_usage(self):
        """监控索引使用情况"""
        query = """
        SELECT 
            OBJECT_SCHEMA,
            OBJECT_NAME,
            INDEX_NAME,
            COUNT_FETCH,
            COUNT_INSERT,
            COUNT_UPDATE,
            COUNT_DELETE
        FROM performance_schema.table_io_waits_summary_by_index_usage
        WHERE OBJECT_SCHEMA = DATABASE()
        """
        
        with self.db.cursor() as cursor:
            cursor.execute(query)
            return cursor.fetchall()
```

## 案例分析

### 案例1：电商平台订单查询优化

**问题**：订单查询响应时间过长

**原始查询**：
```sql
SELECT * FROM orders 
WHERE user_id = ? 
AND created_at >= '2023-01-01' 
ORDER BY created_at DESC 
LIMIT 20;
```

**优化方案**：

1. **创建复合索引**：
```sql
CREATE INDEX idx_orders_user_created 
ON orders(user_id, created_at DESC);
```

2. **查询重写**：
```sql
-- 避免SELECT *，只查询需要的字段
SELECT order_id, total_amount, status, created_at 
FROM orders 
WHERE user_id = ? 
AND created_at >= '2023-01-01' 
ORDER BY created_at DESC 
LIMIT 20;
```

**效果**：查询时间从2秒降低到50毫秒

### 案例2：日志表分区和索引优化

**问题**：日志表数据量大，查询性能差

**解决方案**：

1. **分区表**：
```sql
CREATE TABLE access_logs (
    id BIGINT AUTO_INCREMENT,
    user_id INT,
    action VARCHAR(100),
    created_at TIMESTAMP,
    PRIMARY KEY (id, created_at)
) PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026)
);
```

2. **优化索引**：
```sql
-- 分区键索引
CREATE INDEX idx_logs_user_date ON access_logs(user_id, created_at);

-- 部分索引（只索引近期的活跃数据）
CREATE INDEX idx_logs_recent ON access_logs(created_at) 
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 3 MONTH);
```

**效果**：查询性能提升10倍以上

### 案例3：内容管理系统全文搜索

**问题**：文章标题和内容搜索性能差

**解决方案**：

1. **全文索引**：
```sql
ALTER TABLE articles 
ADD FULLTEXT INDEX idx_article_search (title, content);

-- 权重配置
ALTER TABLE articles 
ADD FULLTEXT INDEX idx_article_weighted (title, content) 
WITH PARSER ngram;
```

2. **搜索优化**：
```sql
SELECT 
    id, 
    title, 
    SUBSTRING(content, 1, 200) as content_preview,
    MATCH(title, content) AGAINST(? IN NATURAL LANGUAGE MODE) as relevance
FROM articles 
WHERE MATCH(title, content) AGAINST(? IN NATURAL LANGUAGE MODE)
ORDER BY relevance DESC
LIMIT 20;
```

**效果**：搜索响应时间从5秒降低到200毫秒

## 总结

数据库索引优化是一个持续的过程，需要：

1. **深入理解业务场景**：根据实际查询模式设计索引
2. **持续监控和优化**：定期分析慢查询，调整索引策略
3. **权衡存储空间和查询性能**：索引会占用额外的存储空间
4. **避免过度索引**：过多的索引会影响写入性能
5. **结合分库分表策略**：大规模数据需要分层优化

通过合理的索引设计和优化，可以显著提升数据库查询性能，改善用户体验。

---

*最后更新：2025年11月*