# 网络协议在分布式系统中的应用

## 概述

网络是分布式系统的基础，了解网络协议对于构建可靠的分布式系统至关重要。本文档将探讨网络协议的核心概念、常见的网络协议模式，以及它们在分布式系统架构中的实际应用。

## TCP/IP协议栈

### TCP连接管理

```python
import socket
import threading
import ssl
import time
from typing import Dict, List, Optional, Callable, Any
from enum import Enum
from dataclasses import dataclass
import asyncio
import aiohttp
import websockets
from contextlib import asynccontextmanager

class ConnectionState(Enum):
    CLOSED = "closed"
    LISTENING = "listening"
    SYN_SENT = "syn_sent"
    SYN_RECEIVED = "syn_received"
    ESTABLISHED = "established"
    FIN_WAIT_1 = "fin_wait_1"
    FIN_WAIT_2 = "fin_wait_2"
    CLOSE_WAIT = "close_wait"
    CLOSING = "closing"
    LAST_ACK = "last_ack"
    TIME_WAIT = "time_wait"

@dataclass
class Connection:
    """TCP连接"""
    connection_id: str
    local_addr: tuple
    remote_addr: tuple
    state: ConnectionState
    created_at: float
    last_activity: float
    bytes_sent: int = 0
    bytes_received: int = 0
    packets_sent: int = 0
    packets_received: int = 0
    retransmissions: int = 0

class TCPConnectionManager:
    """TCP连接管理器"""
    
    def __init__(self):
        self.connections: Dict[str, Connection] = {}
        self.connection_lock = threading.Lock()
        self.max_connections = 1000
        self.connection_timeout = 300  # 5分钟
        self.keep_alive_interval = 30  # 30秒
        
        # 连接池
        self.connection_pools: Dict[str, List[Connection]] = {}
        self.pool_lock = threading.Lock()
    
    def create_connection(self, host: str, port: int, timeout: float = 30.0) -> Optional[Connection]:
        """创建TCP连接"""
        if len(self.connections) >= self.max_connections:
            return None
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            sock.connect((host, port))
            
            connection_id = f"{host}:{port}:{time.time()}"
            
            conn = Connection(
                connection_id=connection_id,
                local_addr=sock.getsockname(),
                remote_addr=(host, port),
                state=ConnectionState.ESTABLISHED,
                created_at=time.time(),
                last_activity=time.time()
            )
            
            with self.connection_lock:
                self.connections[connection_id] = conn
            
            return conn
            
        except Exception as e:
            print(f"Failed to create connection to {host}:{port}: {e}")
            return None
    
    def send_data(self, connection_id: str, data: bytes) -> bool:
        """发送数据"""
        try:
            with self.connection_lock:
                if connection_id not in self.connections:
                    return False
                
                conn = self.connections[connection_id]
                if conn.state != ConnectionState.ESTABLISHED:
                    return False
            
            # 这里应该实现真正的网络发送
            # 简化实现
            conn.bytes_sent += len(data)
            conn.packets_sent += 1
            conn.last_activity = time.time()
            
            return True
            
        except Exception as e:
            print(f"Failed to send data on connection {connection_id}: {e}")
            return False
    
    def close_connection(self, connection_id: str) -> bool:
        """关闭连接"""
        with self.connection_lock:
            if connection_id in self.connections:
                conn = self.connections[connection_id]
                conn.state = ConnectionState.CLOSED
                del self.connections[connection_id]
                return True
        return False
    
    def cleanup_expired_connections(self):
        """清理过期连接"""
        current_time = time.time()
        expired_ids = []
        
        with self.connection_lock:
            for conn_id, conn in self.connections.items():
                if current_time - conn.last_activity > self.connection_timeout:
                    expired_ids.append(conn_id)
        
        for conn_id in expired_ids:
            self.close_connection(conn_id)
    
    def get_connection_stats(self) -> Dict:
        """获取连接统计"""
        with self.connection_lock:
            total_connections = len(self.connections)
            total_bytes_sent = sum(conn.bytes_sent for conn in self.connections.values())
            total_bytes_received = sum(conn.bytes_received for conn in self.connections.values())
            total_packets_sent = sum(conn.packets_sent for conn in self.connections.values())
            total_packets_received = sum(conn.packets_received for conn in self.connections.values())
            
            return {
                'total_connections': total_connections,
                'max_connections': self.max_connections,
                'total_bytes_sent': total_bytes_sent,
                'total_bytes_received': total_bytes_received,
                'total_packets_sent': total_packets_sent,
                'total_packets_received': total_packets_received,
                'connection_utilization': total_connections / self.max_connections
            }

class SecureConnectionWrapper:
    """安全连接包装器"""
    
    def __init__(self, connection_manager: TCPConnectionManager, ssl_context: ssl.SSLContext = None):
        self.connection_manager = connection_manager
        self.ssl_context = ssl_context or self._create_default_ssl_context()
    
    def _create_default_ssl_context(self) -> ssl.SSLContext:
        """创建默认SSL上下文"""
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        return context
    
    def create_secure_connection(self, host: str, port: int) -> Optional[Connection]:
        """创建安全连接"""
        try:
            # 这里应该实现SSL/TLS握手
            print(f"创建SSL/TLS连接到 {host}:{port}")
            
            # 简化实现，返回普通连接
            return self.connection_manager.create_connection(host, port)
            
        except Exception as e:
            print(f"Failed to create secure connection: {e}")
            return None

class ConnectionPool:
    """连接池"""
    
    def __init__(self, host: str, port: int, min_size: int = 5, max_size: int = 20):
        self.host = host
        self.port = port
        self.min_size = min_size
        self.max_size = max_size
        self.connections: List[Connection] = []
        self.in_use: set = set()
        self.lock = threading.Lock()
        self.connection_manager = TCPConnectionManager()
    
    def get_connection(self, timeout: float = 30.0) -> Optional[Connection]:
        """获取连接"""
        with self.lock:
            # 优先使用空闲连接
            available_connections = [conn for conn in self.connections if conn not in self.in_use]
            
            if available_connections:
                conn = available_connections[0]
                self.in_use.add(conn)
                return conn
            
            # 创建新连接
            if len(self.connections) < self.max_size:
                conn = self.connection_manager.create_connection(self.host, self.port, timeout)
                if conn:
                    self.connections.append(conn)
                    self.in_use.add(conn)
                    return conn
        
        return None
    
    def return_connection(self, connection: Connection):
        """归还连接"""
        with self.lock:
            if connection in self.in_use:
                self.in_use.remove(connection)
                connection.last_activity = time.time()
    
    def close_all_connections(self):
        """关闭所有连接"""
        with self.lock:
            for conn in self.connections:
                self.connection_manager.close_connection(conn.connection_id)
            self.connections.clear()
            self.in_use.clear()
    
    def health_check(self) -> Dict:
        """健康检查"""
        with self.lock:
            healthy_connections = 0
            for conn in self.connections:
                if conn.state == ConnectionState.ESTABLISHED:
                    healthy_connections += 1
            
            return {
                'total_connections': len(self.connections),
                'healthy_connections': healthy_connections,
                'in_use_connections': len(self.in_use),
                'idle_connections': healthy_connections - len(self.in_use),
                'min_size': self.min_size,
                'max_size': self.max_size,
                'utilization': len(self.in_use) / len(self.connections) if self.connections else 0
            }

# 异步连接管理
class AsyncConnectionManager:
    """异步连接管理器"""
    
    def __init__(self):
        self.connections: Dict[str, asyncio.AbstractServer] = {}
        self.client_connections: Dict[str, aiohttp.ClientSession] = {}
        self.lock = asyncio.Lock()
    
    @asynccontextmanager
    async def create_tcp_server(self, host: str, port: int, handler: Callable):
        """创建异步TCP服务器"""
        async def tcp_handler(reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
            addr = writer.get_extra_info('peername')
            print(f"New connection from {addr}")
            
            try:
                while True:
                    data = await reader.read(1024)
                    if not data:
                        break
                    
                    # 处理数据
                    response = await handler(data, addr)
                    if response:
                        writer.write(response)
                        await writer.drain()
                    
            except asyncio.IncompleteReadError:
                pass
            except Exception as e:
                print(f"Error in TCP handler: {e}")
            finally:
                writer.close()
                await writer.wait_closed()
                print(f"Connection from {addr} closed")
        
        server = await asyncio.start_server(tcp_handler, host, port)
        
        async with self.lock:
            self.connections[f"{host}:{port}"] = server
        
        try:
            yield server
        finally:
            server.close()
            await server.wait_closed()
            
            async with self.lock:
                if f"{host}:{port}" in self.connections:
                    del self.connections[f"{host}:{port}"]
    
    async def create_http_client(self, base_url: str) -> aiohttp.ClientSession:
        """创建HTTP客户端"""
        async with self.lock:
            if base_url not in self.client_connections:
                timeout = aiohttp.ClientTimeout(total=30)
                connector = aiohttp.TCPConnector(limit=100)
                self.client_connections[base_url] = aiohttp.ClientSession(
                    timeout=timeout, connector=connector
                )
            return self.client_connections[base_url]
    
    async def make_request(self, base_url: str, method: str, url: str, **kwargs) -> Optional[dict]:
        """发起HTTP请求"""
        session = await self.create_http_client(base_url)
        
        try:
            async with session.request(method, f"{base_url}{url}", **kwargs) as response:
                if response.status == 200:
                    data = await response.json()
                    return data
                else:
                    print(f"HTTP request failed: {response.status}")
                    return None
        except Exception as e:
            print(f"HTTP request error: {e}")
            return None
    
    async def create_websocket_server(self, host: str, port: int, handler: Callable):
        """创建WebSocket服务器"""
        async def websocket_handler(websocket, path):
            print(f"WebSocket connection established: {path}")
            
            try:
                async for message in websocket:
                    response = await handler(message, path)
                    if response:
                        await websocket.send(response)
            except websockets.exceptions.ConnectionClosed:
                print("WebSocket connection closed")
            except Exception as e:
                print(f"WebSocket error: {e}")
        
        server = await websockets.serve(websocket_handler, host, port)
        return server
    
    async def create_websocket_client(self, uri: str) -> Optional[websockets.WebSocketClientProtocol]:
        """创建WebSocket客户端"""
        try:
            websocket = await websockets.connect(uri)
            return websocket
        except Exception as e:
            print(f"WebSocket client creation failed: {e}")
            return None
    
    async def close_all(self):
        """关闭所有连接"""
        async with self.lock:
            for server in self.connections.values():
                server.close()
                await server.wait_closed()
            
            for session in self.client_connections.values():
                await session.close()
            
            self.connections.clear()
            self.client_connections.clear()
```

### HTTP/HTTPS协议应用

```python
from typing import Dict, List, Optional, Union
from dataclasses import dataclass
from enum import Enum
import json
import urllib.parse
from urllib.parse import urlparse, urljoin

class HTTPMethod(Enum):
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    HEAD = "HEAD"
    OPTIONS = "OPTIONS"

class HTTPStatus(Enum):
    OK = 200
    CREATED = 201
    BAD_REQUEST = 400
    UNAUTHORIZED = 401
    FORBIDDEN = 403
    NOT_FOUND = 404
    INTERNAL_SERVER_ERROR = 500

@dataclass
class Request:
    """HTTP请求"""
    method: HTTPMethod
    url: str
    headers: Dict[str, str]
    body: Optional[bytes] = None
    params: Dict[str, str] = None
    
    def __post_init__(self):
        if self.params is None:
            self.params = {}

@dataclass
class Response:
    """HTTP响应"""
    status_code: int
    headers: Dict[str, str]
    body: bytes
    response_time: float
    
    @property
    def json_data(self) -> Optional[dict]:
        """解析JSON响应"""
        try:
            return json.loads(self.body.decode('utf-8'))
        except (json.JSONDecodeError, UnicodeDecodeError):
            return None

class APIGateway:
    """API网关 - HTTP协议在微服务架构中的应用"""
    
    def __init__(self):
        self.services: Dict[str, Dict] = {}  # 服务名称 -> 服务配置
        self.routing_rules: List[Dict] = []  # 路由规则
        self.middleware: List[Callable] = []  # 中间件
        self.rate_limiter: RateLimiter = RateLimiter()
        self.load_balancer: LoadBalancer = LoadBalancer()
        
        # 统计信息
        self.stats = {
            'total_requests': 0,
            'successful_requests': 0,
            'failed_requests': 0,
            'average_response_time': 0.0
        }
    
    def register_service(self, service_name: str, base_url: str, instances: List[str]):
        """注册服务"""
        self.services[service_name] = {
            'base_url': base_url,
            'instances': instances,
            'current_instance': 0,
            'health_check_url': f"{base_url}/health"
        }
    
    def add_routing_rule(self, path_pattern: str, service_name: str, methods: List[HTTPMethod] = None):
        """添加路由规则"""
        if methods is None:
            methods = [HTTPMethod.GET, HTTPMethod.POST, HTTPMethod.PUT, HTTPMethod.DELETE]
        
        self.routing_rules.append({
            'path_pattern': path_pattern,
            'service_name': service_name,
            'methods': methods
        })
    
    def add_middleware(self, middleware_func: Callable):
        """添加中间件"""
        self.middleware.append(middleware_func)
    
    async def handle_request(self, request: Request) -> Response:
        """处理请求"""
        start_time = time.time()
        
        try:
            # 应用中间件
            processed_request = request
            for middleware in self.middleware:
                processed_request = await middleware(processed_request)
                if processed_request is None:
                    break
            
            if processed_request is None:
                return Response(400, {}, b'Middleware rejected request', 0)
            
            # 速率限制检查
            client_id = request.headers.get('X-Client-ID', 'unknown')
            if not self.rate_limiter.allow_request(client_id):
                return Response(429, {}, b'Rate limit exceeded', 0)
            
            # 路由到服务
            service_name = self._route_request(request)
            if not service_name:
                return Response(404, {}, b'Service not found', 0)
            
            # 负载均衡
            instance_url = self.load_balancer.select_instance(
                self.services[service_name]['instances']
            )
            
            # 转发请求
            response = await self._forward_request(processed_request, service_name, instance_url)
            
            # 更新统计
            response_time = time.time() - start_time
            self._update_stats(response.status_code, response_time)
            
            return response
            
        except Exception as e:
            return Response(500, {}, f'Internal error: {str(e)}'.encode(), 0)
    
    def _route_request(self, request: Request) -> Optional[str]:
        """路由请求到服务"""
        parsed_url = urlparse(request.url)
        path = parsed_url.path
        
        for rule in self.routing_rules:
            if self._match_path(rule['path_pattern'], path) and request.method in rule['methods']:
                return rule['service_name']
        return None
    
    def _match_path(self, pattern: str, path: str) -> bool:
        """简单的路径匹配"""
        # 简化实现，实际应该支持正则表达式
        return pattern in path
    
    async def _forward_request(self, request: Request, service_name: str, instance_url: str) -> Response:
        """转发请求到服务实例"""
        try:
            async with aiohttp.ClientSession() as session:
                url = urljoin(instance_url, request.url)
                
                async with session.request(
                    request.method.value,
                    url,
                    headers=request.headers,
                    data=request.body
                ) as response:
                    response_body = await response.read()
                    
                    return Response(
                        status_code=response.status,
                        headers=dict(response.headers),
                        body=response_body,
                        response_time=0  # 将在外层计算
                    )
        except Exception as e:
            return Response(502, {}, f'Bad gateway: {str(e)}'.encode(), 0)
    
    def _update_stats(self, status_code: int, response_time: float):
        """更新统计信息"""
        self.stats['total_requests'] += 1
        
        if 200 <= status_code < 300:
            self.stats['successful_requests'] += 1
        else:
            self.stats['failed_requests'] += 1
        
        # 更新平均响应时间
        total_requests = self.stats['total_requests']
        current_avg = self.stats['average_response_time']
        self.stats['average_response_time'] = (current_avg * (total_requests - 1) + response_time) / total_requests
    
    def get_stats(self) -> Dict:
        """获取统计信息"""
        success_rate = (self.stats['successful_requests'] / self.stats['total_requests'] * 100 
                       if self.stats['total_requests'] > 0 else 0)
        
        return {
            'total_requests': self.stats['total_requests'],
            'successful_requests': self.stats['successful_requests'],
            'failed_requests': self.stats['failed_requests'],
            'success_rate': success_rate,
            'average_response_time': self.stats['average_response_time']
        }

class RateLimiter:
    """速率限制器"""
    
    def __init__(self, max_requests: int = 100, time_window: int = 60):
        self.max_requests = max_requests
        self.time_window = time_window
        self.request_history: Dict[str, List[float]] = {}
    
    def allow_request(self, client_id: str) -> bool:
        """检查是否允许请求"""
        current_time = time.time()
        
        if client_id not in self.request_history:
            self.request_history[client_id] = []
        
        # 清理过期请求
        self.request_history[client_id] = [
            req_time for req_time in self.request_history[client_id]
            if current_time - req_time < self.time_window
        ]
        
        # 检查是否超过限制
        if len(self.request_history[client_id]) < self.max_requests:
            self.request_history[client_id].append(current_time)
            return True
        
        return False

class LoadBalancer:
    """负载均衡器"""
    
    def __init__(self):
        self.strategy = 'round_robin'
        self.current_index = 0
    
    def select_instance(self, instances: List[str]) -> str:
        """选择实例"""
        if self.strategy == 'round_robin':
            selected = instances[self.current_index % len(instances)]
            self.current_index += 1
            return selected
        elif self.strategy == 'random':
            import random
            return random.choice(instances)
        elif self.strategy == 'least_connections':
            # 简化实现，返回第一个实例
            return instances[0]
        else:
            return instances[0]

class RESTfulAPIClient:
    """RESTful API客户端"""
    
    def __init__(self, base_url: str, timeout: float = 30.0):
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self.session: Optional[aiohttp.ClientSession] = None
        self.default_headers = {
            'Content-Type': 'application/json',
            'User-Agent': 'DistributedSystemAPI/1.0'
        }
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=self.timeout),
            headers=self.default_headers
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def get(self, endpoint: str, params: Dict = None) -> Optional[dict]:
        """GET请求"""
        return await self._request('GET', endpoint, params=params)
    
    async def post(self, endpoint: str, data: dict = None) -> Optional[dict]:
        """POST请求"""
        return await self._request('POST', endpoint, json=data)
    
    async def put(self, endpoint: str, data: dict = None) -> Optional[dict]:
        """PUT请求"""
        return await self._request('PUT', endpoint, json=data)
    
    async def delete(self, endpoint: str) -> Optional[dict]:
        """DELETE请求"""
        return await self._request('DELETE', endpoint)
    
    async def _request(self, method: str, endpoint: str, **kwargs) -> Optional[dict]:
        """发起HTTP请求"""
        if not self.session:
            return None
        
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            async with self.session.request(method, url, **kwargs) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    print(f"API request failed: {method} {url} - Status: {response.status}")
                    return None
        except Exception as e:
            print(f"API request error: {e}")
            return None
```

### UDP协议应用

```python
import struct
from typing import Callable, Optional

class UDPMessage:
    """UDP消息"""
    
    def __init__(self, message_id: int, message_type: int, data: bytes):
        self.message_id = message_id
        self.message_type = message_type
        self.data = data
        self.timestamp = time.time()
    
    def serialize(self) -> bytes:
        """序列化消息"""
        header = struct.pack('!II', self.message_id, self.message_type)
        return header + self.data
    
    @classmethod
    def deserialize(cls, data: bytes) -> 'UDPMessage':
        """反序列化消息"""
        if len(data) < 8:
            raise ValueError("Invalid UDP message format")
        
        header = data[:8]
        message_id, message_type = struct.unpack('!II', header)
        message_data = data[8:]
        
        message = cls(message_id, message_type, message_data)
        return message

class UDPTransport:
    """UDP传输层"""
    
    def __init__(self):
        self.socket: Optional[socket.socket] = None
        self.message_handlers: Dict[int, Callable] = {}
        self.message_queue = asyncio.Queue()
        self.running = False
    
    async def start(self, host: str, port: int):
        """启动UDP传输"""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind((host, port))
        self.running = True
        
        # 启动消息处理任务
        asyncio.create_task(self._message_processor())
    
    def register_handler(self, message_type: int, handler: Callable):
        """注册消息处理器"""
        self.message_handlers[message_type] = handler
    
    async def send_message(self, host: str, port: int, message: UDPMessage):
        """发送UDP消息"""
        if self.socket:
            data = message.serialize()
            self.socket.sendto(data, (host, port))
    
    async def _message_processor(self):
        """消息处理器"""
        while self.running:
            try:
                data, addr = await asyncio.get_event_loop().run_in_executor(
                    None, self.socket.recvfrom, 1024
                )
                
                # 反序列化消息
                message = UDPMessage.deserialize(data)
                
                # 查找处理器
                if message.message_type in self.message_handlers:
                    handler = self.message_handlers[message.message_type]
                    await handler(message, addr)
                
            except Exception as e:
                print(f"UDP message processing error: {e}")
    
    async def stop(self):
        """停止UDP传输"""
        self.running = False
        if self.socket:
            self.socket.close()

class ServiceDiscovery:
    """服务发现 - 基于UDP的轻量级服务发现"""
    
    def __init__(self, service_name: str, port: int):
        self.service_name = service_name
        self.port = port
        self.node_id = f"{socket.gethostname()}:{port}"
        self.udp_transport = UDPTransport()
        self.service_instances: Dict[str, Dict] = {}
        self.heartbeat_interval = 5  # 心跳间隔（秒）
        self.service_timeout = 15    # 服务超时（秒）
        self.running = False
    
    async def start(self):
        """启动服务发现"""
        await self.udp_transport.start('0.0.0.0', self.port)
        
        # 注册消息处理器
        self.udp_transport.register_handler(1, self._handle_service_announcement)  # 服务公告
        self.udp_transport.register_handler(2, self._handle_service_query)        # 服务查询
        self.udp_transport.register_handler(3, self._handle_heartbeat)           # 心跳
        
        self.running = True
        
        # 启动服务公告
        asyncio.create_task(self._service_announcer())
        
        # 启动心跳检查
        asyncio.create_task(self._heartbeat_checker())
    
    async def _service_announcer(self):
        """服务公告者"""
        while self.running:
            # 广播服务公告
            message = UDPMessage(0, 1, f"{self.service_name}:{self.node_id}".encode())
            
            # 发送到局域网广播地址（简化实现）
            await self.udp_transport.send_message('255.255.255.255', self.port, message)
            
            await asyncio.sleep(self.heartbeat_interval)
    
    async def _heartbeat_checker(self):
        """心跳检查器"""
        while self.running:
            current_time = time.time()
            
            # 清理超时的服务实例
            timeout_instances = []
            for node_id, instance_info in self.service_instances.items():
                if current_time - instance_info['last_heartbeat'] > self.service_timeout:
                    timeout_instances.append(node_id)
            
            for node_id in timeout_instances:
                print(f"Service instance {node_id} timed out")
                del self.service_instances[node_id]
            
            await asyncio.sleep(1)
    
    async def _handle_service_announcement(self, message: UDPMessage, addr: tuple):
        """处理服务公告"""
        try:
            service_info = message.data.decode()
            service_name, node_id = service_info.split(':', 1)
            
            if service_name == self.service_name:
                if node_id not in self.service_instances:
                    print(f"New service instance discovered: {node_id} from {addr}")
                
                self.service_instances[node_id] = {
                    'addr': addr,
                    'last_heartbeat': time.time(),
                    'service_name': service_name
                }
                
                # 发送心跳确认（可选）
                heartbeat_message = UDPMessage(message.message_id, 3, self.node_id.encode())
                await self.udp_transport.send_message(addr[0], addr[1], heartbeat_message)
                
        except Exception as e:
            print(f"Error handling service announcement: {e}")
    
    async def _handle_service_query(self, message: UDPMessage, addr: tuple):
        """处理服务查询"""
        try:
            service_name = message.data.decode()
            
            if service_name == self.service_name:
                # 返回服务实例列表
                instances = list(self.service_instances.keys())
                response_data = json.dumps(instances).encode()
                
                response_message = UDPMessage(message.message_id, 1, response_data)
                await self.udp_transport.send_message(addr[0], addr[1], response_message)
                
        except Exception as e:
            print(f"Error handling service query: {e}")
    
    async def _handle_heartbeat(self, message: UDPMessage, addr: tuple):
        """处理心跳"""
        try:
            node_id = message.data.decode()
            
            if node_id in self.service_instances:
                self.service_instances[node_id]['last_heartbeat'] = time.time()
                print(f"Heartbeat received from {node_id}")
                
        except Exception as e:
            print(f"Error handling heartbeat: {e}")
    
    def get_service_instances(self) -> List[Dict]:
        """获取服务实例列表"""
        return list(self.service_instances.values())
    
    async def query_service(self, service_name: str, timeout: float = 5.0) -> List[str]:
        """查询服务实例"""
        # 发送服务查询
        query_message = UDPMessage(0, 2, service_name.encode())
        
        # 设置查询超时
        start_time = time.time()
        await self.udp_transport.send_message('255.255.255.255', self.port, query_message)
        
        # 等待响应（简化实现）
        while time.time() - start_time < timeout:
            await asyncio.sleep(0.1)
            # 这里应该等待UDP响应，简化实现返回当前缓存的实例
            if service_name in [info['service_name'] for info in self.service_instances.values()]:
                return [info['addr'][0] for info in self.service_instances.values() if info['service_name'] == service_name]
        
        return []
    
    async def stop(self):
        """停止服务发现"""
        self.running = False
        await self.udp_transport.stop()
```

## 网络安全协议

### TLS/SSL在分布式系统中的应用

```python
import ssl
import cryptography
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.serialization import pkcs12
from cryptography.x509.oid import NameOID
from typing import List, Dict, Optional
import tempfile

class CertificateManager:
    """证书管理器"""
    
    def __init__(self):
        self.private_key = None
        self.certificate = None
        self.cert_chain = []
    
    def generate_self_signed_certificate(self, common_name: str, validity_days: int = 365) -> bytes:
        """生成自签名证书"""
        # 生成私钥
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
        )
        
        # 生成证书
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COMMON_NAME, common_name),
        ])
        
        cert = x509.CertificateBuilder().subject_name(
            subject
        ).issuer_name(
            issuer
        ).public_key(
            self.private_key.public_key()
        ).serial_number(
            x509.random_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + datetime.timedelta(days=validity_days)
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.DNSName(common_name),
                x509.DNSName("localhost"),
                x509.IPAddress(ipaddress.IPv4Address("127.0.0.1")),
            ]),
            critical=False,
        ).sign(self.private_key, hashes.SHA256())
        
        self.certificate = cert
        
        # 导出为PEM格式
        cert_pem = cert.public_bytes(serialization.Encoding.PEM)
        key_pem = self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        return cert_pem + key_pem
    
    def create_server_certificate(self, common_name: str, alt_names: List[str] = None) -> str:
        """创建服务器证书"""
        if alt_names is None:
            alt_names = []
        
        cert_data = self.generate_self_signed_certificate(common_name)
        
        # 保存到临时文件
        with tempfile.NamedTemporaryFile(mode='wb', delete=False, suffix='.pem') as f:
            f.write(cert_data)
            return f.name
    
    def create_ssl_context(self, cert_file: str, key_file: str = None, ca_file: str = None) -> ssl.SSLContext:
        """创建SSL上下文"""
        context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
        
        # 加载证书和私钥
        context.load_cert_chain(cert_file, key_file)
        
        # 加载CA证书（如果提供）
        if ca_file:
            context.load_verify_locations(ca_file)
            context.verify_mode = ssl.CERT_REQUIRED
        
        # 设置安全选项
        context.minimum_version = ssl.TLSVersion.TLSv1_2
        context.set_ciphers('ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS')
        
        return context

class SecureChannel:
    """安全通道"""
    
    def __init__(self, ssl_context: ssl.SSLContext):
        self.ssl_context = ssl_context
        self.connections: Dict[str, ssl.SSLSocket] = {}
    
    def establish_secure_connection(self, host: str, port: int) -> Optional[ssl.SSLSocket]:
        """建立安全连接"""
        try:
            # 创建socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            
            # 包装为SSL socket
            secure_sock = self.ssl_context.wrap_socket(
                sock, server_hostname=host
            )
            
            # 连接到服务器
            secure_sock.connect((host, port))
            
            # 验证证书
            cert = secure_sock.getpeercert()
            if cert:
                print(f"Server certificate: {cert.get('subject', 'Unknown')}")
            
            connection_id = f"{host}:{port}"
            self.connections[connection_id] = secure_sock
            
            return secure_sock
            
        except Exception as e:
            print(f"Failed to establish secure connection: {e}")
            return None
    
    def send_secure_data(self, connection_id: str, data: bytes) -> bool:
        """发送安全数据"""
        if connection_id not in self.connections:
            return False
        
        try:
            secure_sock = self.connections[connection_id]
            secure_sock.sendall(data)
            return True
        except Exception as e:
            print(f"Failed to send secure data: {e}")
            return False
    
    def receive_secure_data(self, connection_id: str, buffer_size: int = 1024) -> Optional[bytes]:
        """接收安全数据"""
        if connection_id not in self.connections:
            return None
        
        try:
            secure_sock = self.connections[connection_id]
            return secure_sock.recv(buffer_size)
        except Exception as e:
            print(f"Failed to receive secure data: {e}")
            return None
    
    def close_connection(self, connection_id: str):
        """关闭连接"""
        if connection_id in self.connections:
            self.connections[connection_id].close()
            del self.connections[connection_id]
    
    def close_all_connections(self):
        """关闭所有连接"""
        for connection_id in list(self.connections.keys()):
            self.close_connection(connection_id)

# 导入必要的库
from datetime import datetime, timedelta
import ipaddress
```

### 网络安全最佳实践

```python
import hashlib
import hmac
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class NetworkSecurityManager:
    """网络安全管理器"""
    
    def __init__(self):
        self.encryption_key: Optional[bytes] = None
        self.cipher_suite: Optional[Fernet] = None
        self.api_keys: Dict[str, str] = {}  # API密钥存储
        self.session_tokens: Dict[str, Dict] = {}  # 会话令牌
    
    def generate_encryption_key(self, password: str, salt: bytes = None) -> bytes:
        """生成加密密钥"""
        if salt is None:
            salt = secrets.token_bytes(16)
        
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        self.encryption_key = kdf.derive(password.encode())
        self.cipher_suite = Fernet(Fernet.generate_key())
        
        return salt
    
    def encrypt_data(self, data: bytes) -> bytes:
        """加密数据"""
        if not self.cipher_suite:
            raise ValueError("Encryption key not initialized")
        return self.cipher_suite.encrypt(data)
    
    def decrypt_data(self, encrypted_data: bytes) -> bytes:
        """解密数据"""
        if not self.cipher_suite:
            raise ValueError("Encryption key not initialized")
        return self.cipher_suite.decrypt(encrypted_data)
    
    def generate_api_key(self, service_name: str) -> str:
        """生成API密钥"""
        api_key = secrets.token_urlsafe(32)
        self.api_keys[service_name] = api_key
        return api_key
    
    def verify_api_key(self, service_name: str, api_key: str) -> bool:
        """验证API密钥"""
        stored_key = self.api_keys.get(service_name)
        return hmac.compare_digest(stored_key, api_key) if stored_key else False
    
    def create_session_token(self, user_id: str, expires_in: int = 3600) -> str:
        """创建会话令牌"""
        token = secrets.token_urlsafe(32)
        expires_at = time.time() + expires_in
        
        self.session_tokens[token] = {
            'user_id': user_id,
            'expires_at': expires_at,
            'created_at': time.time()
        }
        
        return token
    
    def verify_session_token(self, token: str) -> Optional[str]:
        """验证会话令牌"""
        if token not in self.session_tokens:
            return None
        
        session_info = self.session_tokens[token]
        
        # 检查是否过期
        if time.time() > session_info['expires_at']:
            del self.session_tokens[token]
            return None
        
        return session_info['user_id']
    
    def revoke_session_token(self, token: str):
        """撤销会话令牌"""
        if token in self.session_tokens:
            del self.session_tokens[token]
    
    def create_message_signature(self, message: str, secret_key: str) -> str:
        """创建消息签名"""
        return hmac.new(
            secret_key.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
    
    def verify_message_signature(self, message: str, signature: str, secret_key: str) -> bool:
        """验证消息签名"""
        expected_signature = self.create_message_signature(message, secret_key)
        return hmac.compare_digest(expected_signature, signature)

class FirewallRule:
    """防火墙规则"""
    
    def __init__(self, rule_id: str, action: str, protocol: str, 
                 source_ip: str, dest_ip: str, dest_port: int):
        self.rule_id = rule_id
        self.action = action  # 'allow' or 'deny'
        self.protocol = protocol
        self.source_ip = source_ip
        self.dest_ip = dest_ip
        self.dest_port = dest_port
    
    def matches(self, protocol: str, source_ip: str, dest_ip: str, dest_port: int) -> bool:
        """检查规则是否匹配"""
        return (
            self.protocol == protocol and
            self.source_ip == source_ip and
            self.dest_ip == dest_ip and
            self.dest_port == dest_port
        )

class NetworkFirewall:
    """网络防火墙"""
    
    def __init__(self):
        self.rules: List[FirewallRule] = []
        self.blocked_ips: set = set()
        self.rate_limits: Dict[str, List[float]] = {}  # IP -> 请求时间戳列表
    
    def add_rule(self, rule: FirewallRule):
        """添加防火墙规则"""
        self.rules.append(rule)
    
    def block_ip(self, ip_address: str):
        """阻止IP"""
        self.blocked_ips.add(ip_address)
    
    def unblock_ip(self, ip_address: str):
        """取消阻止IP"""
        self.blocked_ips.discard(ip_address)
    
    def check_access(self, protocol: str, source_ip: str, dest_ip: str, dest_port: int) -> bool:
        """检查访问权限"""
        # 检查IP黑名单
        if source_ip in self.blocked_ips:
            return False
        
        # 检查速率限制
        if not self._check_rate_limit(source_ip):
            return False
        
        # 应用防火墙规则
        for rule in self.rules:
            if rule.matches(protocol, source_ip, dest_ip, dest_port):
                return rule.action == 'allow'
        
        # 默认拒绝
        return False
    
    def _check_rate_limit(self, ip_address: str, max_requests: int = 100, time_window: int = 60) -> bool:
        """检查速率限制"""
        current_time = time.time()
        
        if ip_address not in self.rate_limits:
            self.rate_limits[ip_address] = []
        
        # 清理过期请求
        self.rate_limits[ip_address] = [
            req_time for req_time in self.rate_limits[ip_address]
            if current_time - req_time < time_window
        ]
        
        # 检查是否超过限制
        if len(self.rate_limits[ip_address]) >= max_requests:
            return False
        
        # 记录当前请求
        self.rate_limits[ip_address].append(current_time)
        return True
    
    def get_stats(self) -> Dict:
        """获取防火墙统计"""
        total_requests = sum(len(requests) for requests in self.rate_limits.values())
        
        return {
            'total_rules': len(self.rules),
            'blocked_ips': len(self.blocked_ips),
            'active_ips': len(self.rate_limits),
            'total_requests': total_requests,
            'blocked_ips_list': list(self.blocked_ips)
        }

# 使用示例
async def demo_network_protocols():
    """网络协议演示"""
    print("=== 网络协议在分布式系统中的应用 ===")
    
    # 1. TCP连接管理
    print("\n1. TCP连接管理")
    tcp_manager = TCPConnectionManager()
    
    # 创建连接
    conn1 = tcp_manager.create_connection("192.168.1.100", 8080)
    if conn1:
        print(f"创建连接: {conn1.connection_id}")
        
        # 发送数据
        tcp_manager.send_data(conn1.connection_id, b"Hello, TCP!")
        print("数据发送成功")
    
    # 获取统计
    stats = tcp_manager.get_connection_stats()
    print(f"连接统计: {stats}")
    
    # 2. API网关
    print("\n2. API网关")
    gateway = APIGateway()
    
    # 注册服务
    gateway.register_service("user-service", "http://user-service", ["http://user-1:8001", "http://user-2:8002"])
    gateway.add_routing_rule("/api/users", "user-service")
    
    # 添加速率限制中间件
    async def rate_limit_middleware(request: Request) -> Optional[Request]:
        print(f"速率限制检查: {request.headers.get('X-Client-ID', 'unknown')}")
        return request
    
    gateway.add_middleware(rate_limit_middleware)
    
    # 3. UDP服务发现
    print("\n3. UDP服务发现")
    discovery = ServiceDiscovery("user-service", 8000)
    
    # 4. 网络安全
    print("\n4. 网络安全")
    security_manager = NetworkSecurityManager()
    
    # 生成API密钥
    api_key = security_manager.generate_api_key("user-service")
    print(f"API密钥: {api_key}")
    
    # 验证API密钥
    is_valid = security_manager.verify_api_key("user-service", api_key)
    print(f"API密钥验证: {is_valid}")
    
    # 创建会话令牌
    token = security_manager.create_session_token("user123")
    print(f"会话令牌: {token}")
    
    # 验证会话令牌
    user_id = security_manager.verify_session_token(token)
    print(f"会话令牌验证: {user_id}")
    
    # 5. 防火墙
    print("\n5. 防火墙")
    firewall = NetworkFirewall()
    
    # 添加规则
    allow_rule = FirewallRule("allow-http", "allow", "tcp", "192.168.1.0/24", "0.0.0.0", 80)
    firewall.add_rule(allow_rule)
    
    # 检查访问
    access_allowed = firewall.check_access("tcp", "192.168.1.100", "0.0.0.0", 80)
    print(f"访问检查结果: {'允许' if access_allowed else '拒绝'}")
    
    # 获取防火墙统计
    firewall_stats = firewall.get_stats()
    print(f"防火墙统计: {firewall_stats}")
    
    print("\n=== 网络协议演示完成 ===")

if __name__ == "__main__":
    asyncio.run(demo_network_protocols())
```

## 总结

网络协议在分布式系统中的应用非常广泛，主要体现在以下几个方面：

### 核心协议应用

1. **TCP协议**
   - 可靠的数据传输
   - 连接管理和状态跟踪
   - 连接池和负载均衡
   - 错误处理和重试机制

2. **UDP协议**
   - 轻量级服务发现
   - 实时数据传输
   - 广播和多播通信
   - 心跳检测和健康检查

3. **HTTP/HTTPS协议**
   - RESTful API设计
   - 微服务通信
   - API网关和路由
   - 负载均衡和缓存

### 安全机制

1. **TLS/SSL加密**
   - 端到端加密通信
   - 证书管理和验证
   - 安全通道建立

2. **身份认证**
   - API密钥管理
   - 会话令牌
   - 消息签名和验证

3. **访问控制**
   - 防火墙规则
   - 速率限制
   - IP黑名单和白名单

### 架构模式

1. **API网关模式**
   - 统一入口
   - 请求路由和转发
   - 安全和监控

2. **服务发现模式**
   - 动态服务注册
   - 健康检查
   - 负载均衡

3. **安全通信模式**
   - 端到端加密
   - 证书轮换
   - 安全审计

这些网络协议的应用为构建安全、可靠、高性能的分布式系统提供了坚实的基础。在实际应用中，需要根据具体业务需求选择合适的协议组合，并实现相应的安全机制和监控策略。