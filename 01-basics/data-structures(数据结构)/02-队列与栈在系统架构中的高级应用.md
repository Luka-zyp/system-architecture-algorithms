# 队列与栈在系统架构中的高级应用

## 概述

队列（Queue）和栈（Stack）作为基础数据结构，在系统架构中有着广泛的高级应用。队列的FIFO特性和栈的LIFO特性使它们成为实现各种系统功能的核心组件。

## 队列的高级应用

### 1. 消息队列系统

消息队列是现代分布式系统中最重要的组件之一。

```python
import asyncio
import time
from typing import Any, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import json
import logging

class MessagePriority(Enum):
    LOW = 1
    NORMAL = 2
    HIGH = 3
    URGENT = 4

@dataclass
class Message:
    id: str
    content: Any
    priority: MessagePriority
    timestamp: float
    retry_count: int = 0
    max_retries: int = 3

class PriorityMessageQueue:
    """优先级消息队列实现"""
    
    def __init__(self):
        self.queues = {
            MessagePriority.URGENT: [],
            MessagePriority.HIGH: [],
            MessagePriority.NORMAL: [],
            MessagePriority.LOW: []
        }
        self.callbacks = {}
        self.running = False
        self.logger = logging.getLogger(__name__)
    
    def put(self, message: Message):
        """添加消息到队列"""
        self.queues[message.priority].append(message)
        self.logger.info(f"Message {message.id} added with priority {message.priority}")
    
    def get(self) -> Optional[Message]:
        """获取最高优先级的消息"""
        for priority in [MessagePriority.URGENT, MessagePriority.HIGH, 
                        MessagePriority.NORMAL, MessagePriority.LOW]:
            if self.queues[priority]:
                return self.queues[priority].pop(0)
        return None
    
    async def consume(self, handler: Callable[[Message], bool]):
        """消费消息"""
        while self.running:
            message = self.get()
            if message:
                try:
                    success = await handler(message)
                    if not success:
                        self._handle_failed_message(message)
                except Exception as e:
                    self.logger.error(f"Error processing message {message.id}: {e}")
                    self._handle_failed_message(message)
            else:
                await asyncio.sleep(0.1)
    
    def _handle_failed_message(self, message: Message):
        """处理失败消息"""
        message.retry_count += 1
        if message.retry_count < message.max_retries:
            # 延迟重试，使用指数退避
            delay = 2 ** message.retry_count
            self.logger.warning(f"Retrying message {message.id} in {delay} seconds")
            # 这里可以添加重试调度逻辑
        else:
            self.logger.error(f"Message {message.id} failed after {message.max_retries} retries")

# 使用示例
async def message_handler(message: Message) -> bool:
    """消息处理器"""
    print(f"Processing message {message.id}: {message.content}")
    # 模拟处理时间
    await asyncio.sleep(0.1)
    return True

async def demo_priority_queue():
    """演示优先级队列"""
    queue = PriorityMessageQueue()
    queue.running = True
    
    # 创建消费任务
    consumer_task = asyncio.create_task(queue.consume(message_handler))
    
    # 生产消息
    messages = [
        Message("msg1", "Normal message", MessagePriority.NORMAL, time.time()),
        Message("msg2", "Urgent message", MessagePriority.URGENT, time.time()),
        Message("msg3", "Low priority", MessagePriority.LOW, time.time()),
        Message("msg4", "High priority", MessagePriority.HIGH, time.time()),
    ]
    
    for msg in messages:
        queue.put(msg)
    
    # 等待处理完成
    await asyncio.sleep(2)
    queue.running = False
    consumer_task.cancel()

# 运行示例
# asyncio.run(demo_priority_queue())
```

### 2. 流量控制和背压机制

队列在流量控制和背压机制中发挥重要作用：

```python
import asyncio
from collections import deque
import time

class BackPressureQueue:
    """带背压控制的队列"""
    
    def __init__(self, max_size: int = 100):
        self.max_size = max_size
        self.queue = deque()
        self.waiting_producers = []
        self.waiting_consumers = []
        self.lock = asyncio.Lock()
        self.metrics = {
            'produced': 0,
            'consumed': 0,
            'dropped': 0,
            'blocked_producers': 0
        }
    
    async def put(self, item: Any, timeout: float = None):
        """生产者添加数据，带背压控制"""
        async with self.lock:
            # 检查是否队列已满
            if len(self.queue) >= self.max_size:
                if timeout is None:
                    # 阻塞等待
                    self.metrics['blocked_producers'] += 1
                    producer_event = asyncio.Event()
                    self.waiting_producers.append(producer_event)
                    async with self.lock:
                        pass  # 释放锁等待
                    await producer_event.wait()
                else:
                    # 超时失败
                    raise asyncio.TimeoutError("Queue full and timeout")
            
            # 添加到队列
            self.queue.append(item)
            self.metrics['produced'] += 1
            
            # 通知等待的消费者
            if self.waiting_consumers:
                consumer_event = self.waiting_consumers.pop(0)
                consumer_event.set()
    
    async def get(self, timeout: float = None) -> Any:
        """消费者获取数据"""
        async with self.lock:
            if not self.queue:
                if timeout is None:
                    # 阻塞等待
                    consumer_event = asyncio.Event()
                    self.waiting_consumers.append(consumer_event)
                    async with self.lock:
                        pass  # 释放锁等待
                    await consumer_event.wait()
                else:
                    # 超时失败
                    raise asyncio.TimeoutError("Queue empty and timeout")
            
            # 从队列获取数据
            item = self.queue.popleft()
            self.metrics['consumed'] += 1
            
            # 通知等待的生产者
            if self.waiting_producers:
                producer_event = self.waiting_producers.pop(0)
                producer_event.set()
            
            return item
    
    def get_metrics(self) -> dict:
        """获取队列指标"""
        return self.metrics.copy()

class TrafficShaper:
    """流量整形器"""
    
    def __init__(self, max_rate: float, burst_size: int = 10):
        self.max_rate = max_rate  # 每秒最大处理数
        self.burst_size = burst_size
        self.tokens = burst_size
        self.last_refill = time.time()
        self.queue = BackPressureQueue(max_size=1000)
    
    def _refill_tokens(self):
        """补充令牌"""
        now = time.time()
        elapsed = now - self.last_refill
        tokens_to_add = elapsed * self.max_rate
        self.tokens = min(self.burst_size, self.tokens + tokens_to_add)
        self.last_refill = now
    
    async def send(self, item: Any, timeout: float = None) -> bool:
        """发送数据"""
        self._refill_tokens()
        
        if self.tokens >= 1:
            self.tokens -= 1
            await self.queue.put(item, timeout)
            return True
        else:
            # 令牌不足，丢弃或等待
            return False
    
    async def receive(self, timeout: float = None) -> Any:
        """接收数据"""
        return await self.queue.get(timeout)

# 使用示例
async def demo_backpressure():
    """演示背压控制"""
    queue = BackPressureQueue(max_size=3)
    
    async def producer():
        for i in range(10):
            try:
                await queue.put(f"item_{i}", timeout=0.5)
                print(f"Produced item_{i}")
                await asyncio.sleep(0.1)
            except asyncio.TimeoutError:
                print(f"Producer timed out for item_{i}")
    
    async def consumer():
        for i in range(5):
            try:
                item = await queue.get(timeout=1.0)
                print(f"Consumed {item}")
                await asyncio.sleep(0.3)  # 消费较慢
            except asyncio.TimeoutError:
                print("Consumer timed out")
    
    await asyncio.gather(producer(), consumer())
    
    print("Final metrics:", queue.get_metrics())

# asyncio.run(demo_backpressure())
```

## 栈的高级应用

### 1. 状态机实现

栈是实现状态机的理想数据结构：

```python
from typing import Dict, Any, List, Callable, Optional
from enum import Enum

class StateContext:
    """状态上下文"""
    def __init__(self):
        self.data = {}
        self.history = []

class StateMachine:
    """基于栈的状态机"""
    
    def __init__(self):
        self.states = {}
        self.state_stack = []
        self.current_state = None
        self.transitions = {}
        self.context = StateContext()
    
    def add_state(self, name: str, enter_callback: Callable = None, 
                  exit_callback: Callable = None):
        """添加状态"""
        self.states[name] = {
            'enter': enter_callback,
            'exit': exit_callback
        }
    
    def add_transition(self, from_state: str, to_state: str, 
                      event: str, condition: Callable = None,
                      action: Callable = None):
        """添加状态转换"""
        if from_state not in self.transitions:
            self.transitions[from_state] = {}
        
        self.transitions[from_state][event] = {
            'to': to_state,
            'condition': condition,
            'action': action
        }
    
    def push_state(self, state_name: str):
        """推入新状态"""
        if state_name not in self.states:
            raise ValueError(f"State {state_name} not found")
        
        # 执行当前状态退出回调
        if self.current_state and self.states[self.current_state]['exit']:
            self.states[self.current_state]['exit'](self.context)
        
        # 推入新状态
        self.state_stack.append(self.current_state)
        self.current_state = state_name
        
        # 执行新状态进入回调
        if self.states[state_name]['enter']:
            self.states[state_name]['enter'](self.context)
    
    def pop_state(self):
        """弹出状态"""
        if len(self.state_stack) > 0:
            # 执行当前状态退出回调
            if self.current_state and self.states[self.current_state]['exit']:
                self.states[self.current_state]['exit'](self.context)
            
            # 弹出之前的状态
            self.current_state = self.state_stack.pop()
            
            # 执行新状态进入回调
            if self.current_state and self.states[self.current_state]['enter']:
                self.states[self.current_state]['enter'](self.context)
    
    def set_state(self, state_name: str):
        """直接设置状态（清空栈）"""
        if state_name not in self.states:
            raise ValueError(f"State {state_name} not found")
        
        # 执行当前状态退出回调
        if self.current_state and self.states[self.current_state]['exit']:
            self.states[self.current_state]['exit'](self.context)
        
        # 清空栈并设置新状态
        self.state_stack.clear()
        self.current_state = state_name
        
        # 执行新状态进入回调
        if self.states[state_name]['enter']:
            self.states[state_name]['enter'](self.context)
    
    def send_event(self, event: str):
        """发送事件"""
        if not self.current_state:
            return False
        
        # 查找转换
        transitions = self.transitions.get(self.current_state, {})
        transition = transitions.get(event)
        
        if transition:
            # 检查条件
            if transition['condition'] and not transition['condition'](self.context):
                return False
            
            # 执行动作
            if transition['action']:
                transition['action'](self.context)
            
            # 转换状态
            self.set_state(transition['to'])
            return True
        
        return False
    
    def get_current_state(self) -> Optional[str]:
        """获取当前状态"""
        return self.current_state

# 状态机示例：用户认证流程
class AuthState(Enum):
    UNAUTHENTICATED = "unauthenticated"
    AUTHENTICATING = "authenticating"
    AUTHENTICATED = "authenticated"
    AUTHORIZING = "authorizing"
    AUTHORIZED = "authorized"

class AuthStateMachine:
    """认证状态机"""
    
    def __init__(self):
        self.sm = StateMachine()
        self._setup_states()
        self._setup_transitions()
    
    def _setup_states(self):
        """设置状态"""
        self.sm.add_state(
            AuthState.UNAUTHENTICATED.value,
            enter=self._on_enter_unauthenticated,
            exit=self._on_exit_unauthenticated
        )
        self.sm.add_state(
            AuthState.AUTHENTICATING.value,
            enter=self._on_enter_authenticating,
            exit=self._on_exit_authenticating
        )
        self.sm.add_state(
            AuthState.AUTHENTICATED.value,
            enter=self._on_enter_authenticated,
            exit=self._on_exit_authenticated
        )
        self.sm.add_state(
            AuthState.AUTHORIZING.value,
            enter=self._on_enter_authorizing,
            exit=self._on_exit_authorizing
        )
        self.sm.add_state(
            AuthState.AUTHORIZED.value,
            enter=self._on_enter_authorized,
            exit=self._on_exit_authorized
        )
    
    def _setup_transitions(self):
        """设置转换"""
        self.sm.add_transition(
            AuthState.UNAUTHENTICATED.value,
            AuthState.AUTHENTICATING.value,
            "login",
            condition=self._check_credentials,
            action=self._start_authentication
        )
        
        self.sm.add_transition(
            AuthState.AUTHENTICATING.value,
            AuthState.AUTHENTICATED.value,
            "auth_success",
            condition=self._verify_authentication,
            action=self._complete_authentication
        )
        
        self.sm.add_transition(
            AuthState.AUTHENTICATED.value,
            AuthState.AUTHORIZING.value,
            "require_permission",
            action=self._start_authorization
        )
        
        self.sm.add_transition(
            AuthState.AUTHORIZING.value,
            AuthState.AUTHORIZED.value,
            "authz_success",
            condition=self._verify_authorization,
            action=self._complete_authorization
        )
        
        self.sm.add_transition(
            AuthState.AUTHENTICATING.value,
            AuthState.UNAUTHENTICATED.value,
            "auth_failure",
            condition=lambda ctx: False  # 总是失败
        )
    
    # 状态回调方法
    def _on_enter_unauthenticated(self, ctx):
        print("Entering UNAUTHENTICATED state")
        ctx.data.clear()
    
    def _on_exit_unauthenticated(self, ctx):
        print("Exiting UNAUTHENTICATED state")
    
    def _on_enter_authenticating(self, ctx):
        print("Entering AUTHENTICATING state")
        ctx.data['auth_start_time'] = time.time()
    
    def _on_exit_authenticating(self, ctx):
        print("Exiting AUTHENTICATING state")
    
    def _on_enter_authenticated(self, ctx):
        print("Entering AUTHENTICATED state")
        ctx.data['authenticated_at'] = time.time()
    
    def _on_exit_authenticated(self, ctx):
        print("Exiting AUTHENTICATED state")
    
    def _on_enter_authorizing(self, ctx):
        print("Entering AUTHORIZING state")
    
    def _on_exit_authorizing(self, ctx):
        print("Exiting AUTHORIZING state")
    
    def _on_enter_authorized(self, ctx):
        print("Entering AUTHORIZED state")
        ctx.data['authorized_at'] = time.time()
    
    def _on_exit_authorized(self, ctx):
        print("Exiting AUTHORIZED state")
    
    # 条件和动作方法
    def _check_credentials(self, ctx) -> bool:
        return ctx.data.get('username') and ctx.data.get('password')
    
    def _verify_authentication(self, ctx) -> bool:
        # 模拟验证过程
        return ctx.data.get('password') == 'correct_password'
    
    def _verify_authorization(self, ctx) -> bool:
        # 模拟权限验证
        return ctx.data.get('required_permission') in ctx.data.get('user_permissions', [])
    
    def _start_authentication(self, ctx):
        print("Starting authentication process")
        ctx.data['auth_method'] = 'password'
    
    def _complete_authentication(self, ctx):
        print("Authentication completed successfully")
    
    def _start_authorization(self, ctx):
        print("Starting authorization process")
    
    def _complete_authorization(self, ctx):
        print("Authorization completed successfully")
    
    def login(self, username: str, password: str):
        """登录"""
        self.sm.context.data['username'] = username
        self.sm.context.data['password'] = password
        return self.sm.send_event("login")
    
    def authentication_result(self, success: bool):
        """认证结果"""
        if success:
            return self.sm.send_event("auth_success")
        else:
            return self.sm.send_event("auth_failure")
    
    def require_permission(self, permission: str):
        """请求权限"""
        self.sm.context.data['required_permission'] = permission
        return self.sm.send_event("require_permission")
    
    def authorization_result(self, success: bool):
        """授权结果"""
        if success:
            self.sm.context.data['user_permissions'] = ['read', 'write']
            return self.sm.send_event("authz_success")
    
    def get_state(self) -> str:
        """获取当前状态"""
        return self.sm.get_current_state()

# 使用示例
async def demo_state_machine():
    """演示状态机"""
    auth_sm = AuthStateMachine()
    
    # 设置初始状态
    auth_sm.sm.set_state(AuthState.UNAUTHENTICATED.value)
    
    print(f"Initial state: {auth_sm.get_state()}")
    
    # 尝试登录
    if auth_sm.login("user", "wrong_password"):
        auth_sm.authentication_result(False)
    print(f"After failed login: {auth_sm.get_state()}")
    
    # 重新登录
    if auth_sm.login("user", "correct_password"):
        auth_sm.authentication_result(True)
    print(f"After successful auth: {auth_sm.get_state()}")
    
    # 请求权限
    if auth_sm.require_permission("read"):
        auth_sm.authorization_result(True)
    print(f"After authorization: {auth_sm.get_state()}")

# asyncio.run(demo_state_machine())
```

### 2. 表达式求值引擎

栈在表达式求值中有着经典应用：

```python
import re
from typing import List, Union

class ExpressionEvaluator:
    """表达式求值引擎"""
    
    def __init__(self):
        self.operators = {
            '+': {'precedence': 1, 'associativity': 'left', 'arity': 2},
            '-': {'precedence': 1, 'associativity': 'left', 'arity': 2},
            '*': {'precedence': 2, 'associativity': 'left', 'arity': 2},
            '/': {'precedence': 2, 'associativity': 'left', 'arity': 2},
            '^': {'precedence': 3, 'associativity': 'right', 'arity': 2},
            'u-': {'precedence': 4, 'associativity': 'right', 'arity': 1}  # 一元负号
        }
    
    def tokenize(self, expression: str) -> List[str]:
        """词法分析，将表达式分解为token"""
        # 清理表达式
        expression = expression.replace(' ', '')
        
        # 匹配数字（包括小数）
        number_pattern = r'\d+\.?\d*'
        # 匹配运算符
        operator_pattern = r'[\+\-\*/\^\(\)]'
        
        tokens = []
        i = 0
        while i < len(expression):
            # 匹配数字
            number_match = re.match(number_pattern, expression[i:])
            if number_match:
                tokens.append(number_match.group())
                i += len(number_match.group())
                continue
            
            # 匹配运算符
            operator_match = re.match(operator_pattern, expression[i])
            if operator_match:
                token = operator_match.group()
                
                # 处理一元负号
                if token == '-' and (not tokens or tokens[-1] in ['(', '+', '-', '*', '/', '^']):
                    tokens.append('u-')
                else:
                    tokens.append(token)
                
                i += 1
                continue
            
            raise ValueError(f"Invalid character: {expression[i]}")
        
        return tokens
    
    def to_postfix(self, tokens: List[str]) -> List[str]:
        """转换为后缀表达式（逆波兰表示法）"""
        output = []
        operator_stack = []
        
        for token in tokens:
            if token in self.operators:
                # 处理运算符
                while (operator_stack and 
                       operator_stack[-1] in self.operators and
                       ((self.operators[token]['associativity'] == 'left' and 
                         self.operators[token]['precedence'] <= self.operators[operator_stack[-1]]['precedence']) or
                        (self.operators[token]['associativity'] == 'right' and 
                         self.operators[token]['precedence'] < self.operators[operator_stack[-1]]['precedence']))):
                    output.append(operator_stack.pop())
                operator_stack.append(token)
            
            elif token == '(':
                operator_stack.append(token)
            
            elif token == ')':
                # 弹出直到左括号
                while operator_stack and operator_stack[-1] != '(':
                    output.append(operator_stack.pop())
                if operator_stack and operator_stack[-1] == '(':
                    operator_stack.pop()
                else:
                    raise ValueError("Mismatched parentheses")
            
            else:
                # 操作数
                output.append(token)
        
        # 弹出剩余的运算符
        while operator_stack:
            if operator_stack[-1] in ['(', ')']:
                raise ValueError("Mismatched parentheses")
            output.append(operator_stack.pop())
        
        return output
    
    def evaluate_postfix(self, postfix_tokens: List[str]) -> float:
        """求值后缀表达式"""
        value_stack = []
        
        for token in postfix_tokens:
            if token in self.operators:
                # 弹出操作数
                if self.operators[token]['arity'] == 2:
                    if len(value_stack) < 2:
                        raise ValueError("Insufficient operands")
                    b = float(value_stack.pop())
                    a = float(value_stack.pop())
                    result = self._apply_operator(token, a, b)
                else:  # 一元运算符
                    if len(value_stack) < 1:
                        raise ValueError("Insufficient operands")
                    a = float(value_stack.pop())
                    result = self._apply_operator(token, a)
                
                value_stack.append(result)
            
            else:
                # 操作数
                try:
                    value_stack.append(float(token))
                except ValueError:
                    raise ValueError(f"Invalid number: {token}")
        
        if len(value_stack) != 1:
            raise ValueError("Invalid expression")
        
        return value_stack[0]
    
    def _apply_operator(self, operator: str, a: float, b: float = None) -> float:
        """应用运算符"""
        if operator == '+':
            return a + (b if b is not None else 0)
        elif operator == '-':
            return a - (b if b is not None else 0)
        elif operator == '*':
            return a * b
        elif operator == '/':
            if b == 0:
                raise ValueError("Division by zero")
            return a / b
        elif operator == '^':
            return a ** b
        elif operator == 'u-':
            return -a
        else:
            raise ValueError(f"Unknown operator: {operator}")
    
    def evaluate(self, expression: str) -> float:
        """求值表达式"""
        try:
            tokens = self.tokenize(expression)
            postfix_tokens = self.to_postfix(tokens)
            result = self.evaluate_postfix(postfix_tokens)
            return result
        except Exception as e:
            raise ValueError(f"Error evaluating expression '{expression}': {str(e)}")

class ExpressionCache:
    """表达式缓存"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache = {}
        self.access_order = []
    
    def get(self, expression: str) -> float:
        """从缓存获取表达式结果"""
        if expression in self.cache:
            # 更新访问顺序
            self.access_order.remove(expression)
            self.access_order.append(expression)
            return self.cache[expression]
        return None
    
    def put(self, expression: str, result: float):
        """将表达式结果放入缓存"""
        if expression in self.cache:
            self.cache[expression] = result
            self.access_order.remove(expression)
            self.access_order.append(expression)
        else:
            # 缓存满时移除最老的条目
            if len(self.cache) >= self.max_size:
                oldest = self.access_order.pop(0)
                del self.cache[oldest]
            
            self.cache[expression] = result
            self.access_order.append(expression)

class OptimizedExpressionEvaluator(ExpressionEvaluator):
    """优化的表达式求值器，支持缓存"""
    
    def __init__(self):
        super().__init__()
        self.cache = ExpressionCache()
    
    def evaluate(self, expression: str) -> float:
        """求值表达式（带缓存）"""
        # 尝试从缓存获取
        cached_result = self.cache.get(expression)
        if cached_result is not None:
            return cached_result
        
        # 计算并缓存结果
        result = super().evaluate(expression)
        self.cache.put(expression, result)
        return result

# 使用示例
async def demo_expression_evaluator():
    """演示表达式求值器"""
    evaluator = OptimizedExpressionEvaluator()
    
    expressions = [
        "2 + 3 * 4",
        "(2 + 3) * 4",
        "2^3 + 4*5",
        "-(3 + 4) * 2",
        "1 + 2 + 3 + 4",
        "((1 + 2) * 3 + 4) / 5"
    ]
    
    for expr in expressions:
        try:
            result = evaluator.evaluate(expr)
            print(f"{expr} = {result}")
        except ValueError as e:
            print(f"Error evaluating '{expr}': {e}")
    
    print(f"\nCache size: {len(evaluator.cache.cache)}")
    print(f"Cached expressions: {list(evaluator.cache.cache.keys())}")

# asyncio.run(demo_expression_evaluator())
```

## 队列和栈的组合应用

### 1. 双端队列（Deque）实现

双端队列结合了队列和栈的特性：

```python
from collections import deque
import threading
from typing import Any, Optional

class ThreadSafeDeque:
    """线程安全的双端队列"""
    
    def __init__(self, maxlen: Optional[int] = None):
        self.deque = deque(maxlen=maxlen)
        self.lock = threading.RLock()
        self.not_empty = threading.Condition(self.lock)
        self.not_full = threading.Condition(self.lock)
    
    def append_left(self, item: Any):
        """在左侧添加元素"""
        with self.not_full:
            while self.deque.maxlen is not None and len(self.deque) >= self.deque.maxlen:
                self.not_full.wait()
            self.deque.appendleft(item)
            self.not_empty.notify()
    
    def append(self, item: Any):
        """在右侧添加元素"""
        with self.not_full:
            while self.deque.maxlen is not None and len(self.deque) >= self.deque.maxlen:
                self.not_full.wait()
            self.deque.append(item)
            self.not_empty.notify()
    
    def popleft(self) -> Any:
        """从左侧移除并返回元素"""
        with self.not_empty:
            while not self.deque:
                self.not_empty.wait()
            item = self.deque.popleft()
            self.not_full.notify()
            return item
    
    def pop(self) -> Any:
        """从右侧移除并返回元素"""
        with self.not_empty:
            while not self.deque:
                self.not_empty.wait()
            item = self.deque.pop()
            self.not_full.notify()
            return item
    
    def peek_left(self) -> Any:
        """查看左侧元素（不移除）"""
        with self.not_empty:
            while not self.deque:
                self.not_empty.wait()
            return self.deque[0]
    
    def peek(self) -> Any:
        """查看右侧元素（不移除）"""
        with self.not_empty:
            while not self.deque:
                self.not_empty.wait()
            return self.deque[-1]
    
    def is_empty(self) -> bool:
        """检查是否为空"""
        with self.lock:
            return len(self.deque) == 0
    
    def is_full(self) -> bool:
        """检查是否已满"""
        with self.lock:
            return self.deque.maxlen is not None and len(self.deque) >= self.deque.maxlen
    
    def size(self) -> int:
        """获取大小"""
        with self.lock:
            return len(self.deque)
    
    def maxlen(self) -> Optional[int]:
        """获取最大长度"""
        with self.lock:
            return self.deque.maxlen

class TaskScheduler:
    """基于双端队列的任务调度器"""
    
    def __init__(self, max_size: int = 1000):
        self.task_queue = ThreadSafeDeque(maxlen=max_size)
        self.running = False
        self.workers = []
        self.completed_tasks = ThreadSafeDeque()
        self.failed_tasks = ThreadSafeDeque()
    
    def add_high_priority_task(self, task):
        """添加高优先级任务（左侧）"""
        self.task_queue.append_left(task)
    
    def add_normal_task(self, task):
        """添加普通任务（右侧）"""
        self.task_queue.append(task)
    
    def add_low_priority_task(self, task):
        """添加低优先级任务（最右侧）"""
        self.task_queue.append(task)
    
    def start_scheduler(self, num_workers: int = 4):
        """启动调度器"""
        self.running = True
        
        # 启动工作线程
        for i in range(num_workers):
            worker = threading.Thread(target=self._worker_loop, args=(i,))
            worker.daemon = True
            worker.start()
            self.workers.append(worker)
    
    def stop_scheduler(self):
        """停止调度器"""
        self.running = False
        
        # 等待所有工作线程结束
        for worker in self.workers:
            worker.join()
    
    def _worker_loop(self, worker_id: int):
        """工作线程循环"""
        while self.running or not self.task_queue.is_empty():
            try:
                task = self.task_queue.popleft()
                self._execute_task(task, worker_id)
            except Exception as e:
                print(f"Worker {worker_id} error: {e}")
    
    def _execute_task(self, task, worker_id: int):
        """执行任务"""
        try:
            result = task()
            self.completed_tasks.append((task, result, worker_id))
            print(f"Worker {worker_id} completed task: {task}")
        except Exception as e:
            self.failed_tasks.append((task, e, worker_id))
            print(f"Worker {worker_id} failed task: {task}, error: {e}")
    
    def get_completed_tasks(self):
        """获取已完成的任务"""
        return list(self.completed_tasks.deque)
    
    def get_failed_tasks(self):
        """获取失败的任务"""
        return list(self.failed_tasks.deque)

# 使用示例
async def demo_deque_scheduler():
    """演示双端队列调度器"""
    import random
    
    def create_task(name: str, duration: float):
        def task():
            print(f"Executing {name}")
            time.sleep(duration)
            return f"Result of {name}"
        return task
    
    scheduler = TaskScheduler(max_size=100)
    
    # 添加不同优先级的任务
    tasks = [
        (create_task("High Priority 1", 0.1), 'high'),
        (create_task("Normal Priority 1", 0.2), 'normal'),
        (create_task("High Priority 2", 0.05), 'high'),
        (create_task("Low Priority 1", 0.3), 'low'),
        (create_task("Normal Priority 2", 0.15), 'normal'),
    ]
    
    for task, priority in tasks:
        if priority == 'high':
            scheduler.add_high_priority_task(task)
        elif priority == 'low':
            scheduler.add_low_priority_task(task)
        else:
            scheduler.add_normal_task(task)
    
    # 启动调度器
    scheduler.start_scheduler(num_workers=2)
    
    # 等待任务完成
    await asyncio.sleep(3)
    
    scheduler.stop_scheduler()
    
    completed = scheduler.get_completed_tasks()
    failed = scheduler.get_failed_tasks()
    
    print(f"Completed tasks: {len(completed)}")
    print(f"Failed tasks: {len(failed)}")

# asyncio.run(demo_deque_scheduler())
```

## 性能优化策略

### 1. 内存池技术

```python
import array
from typing import TypeVar, Generic, List

T = TypeVar('T')

class MemoryPool(Generic[T]):
    """内存池实现"""
    
    def __init__(self, item_class: type, initial_size: int = 100, max_size: int = 1000):
        self.item_class = item_class
        self.max_size = max_size
        self.available_items = []
        self.in_use_items = set()
        
        # 预分配对象
        for _ in range(initial_size):
            self.available_items.append(item_class())
    
    def acquire(self) -> T:
        """获取对象"""
        if self.available_items:
            item = self.available_items.pop()
        else:
            item = self.item_class()
        
        self.in_use_items.add(item)
        return item
    
    def release(self, item: T):
        """释放对象"""
        if item in self.in_use_items:
            self.in_use_items.remove(item)
            
            if len(self.available_items) < self.max_size:
                # 重置对象状态
                if hasattr(item, 'reset'):
                    item.reset()
                self.available_items.append(item)
    
    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            'available': len(self.available_items),
            'in_use': len(self.in_use_items),
            'total_capacity': len(self.available_items) + len(self.in_use_items)
        }

class QueueNode:
    """队列节点"""
    
    __slots__ = ['data', 'prev', 'next']
    
    def __init__(self):
        self.data = None
        self.prev = None
        self.next = None
    
    def reset(self):
        """重置节点状态"""
        self.data = None
        self.prev = None
        self.next = None

class PooledQueue:
    """基于内存池的队列"""
    
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.head = None
        self.tail = None
        self.size = 0
        self.node_pool = MemoryPool(QueueNode, initial_size=100, max_size=max_size)
    
    def enqueue(self, data: T):
        """入队"""
        if self.size >= self.max_size:
            raise OverflowError("Queue is full")
        
        node = self.node_pool.acquire()
        node.data = data
        
        if not self.head:
            self.head = self.tail = node
        else:
            node.prev = self.tail
            self.tail.next = node
            self.tail = node
        
        self.size += 1
    
    def dequeue(self) -> T:
        """出队"""
        if not self.head:
            raise IndexError("Queue is empty")
        
        node = self.head
        data = node.data
        
        self.head = node.next
        if self.head:
            self.head.prev = None
        else:
            self.tail = None
        
        self.size -= 1
        
        # 释放节点到内存池
        self.node_pool.release(node)
        
        return data
    
    def is_empty(self) -> bool:
        """检查是否为空"""
        return self.size == 0
    
    def is_full(self) -> bool:
        """检查是否已满"""
        return self.size >= self.max_size
    
    def get_stats(self) -> dict:
        """获取统计信息"""
        return {
            'size': self.size,
            'max_size': self.max_size,
            'node_pool': self.node_pool.get_stats()
        }

# 使用示例
async def demo_memory_pool():
    """演示内存池"""
    queue = PooledQueue(max_size=5)
    
    # 入队操作
    for i in range(5):
        queue.enqueue(f"Item {i}")
        print(f"Enqueued: Item {i}")
        print(f"Stats: {queue.get_stats()}")
    
    # 出队操作
    for i in range(3):
        item = queue.dequeue()
        print(f"Dequeued: {item}")
        print(f"Stats: {queue.get_stats()}")
    
    # 继续入队
    for i in range(3):
        queue.enqueue(f"New Item {i}")
        print(f"Enqueued: New Item {i}")

# asyncio.run(demo_memory_pool())
```

## 实际应用案例

### 1. 订单处理系统

```python
from datetime import datetime, timedelta
from enum import Enum
import uuid

class OrderStatus(Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    FAILED = "failed"

class Order:
    """订单类"""
    
    def __init__(self, order_id: str, customer_id: str, items: list, total: float):
        self.order_id = order_id
        self.customer_id = customer_id
        self.items = items
        self.total = total
        self.status = OrderStatus.PENDING
        self.created_at = datetime.now()
        self.processed_at = None
        self.failure_reason = None

class OrderProcessingSystem:
    """订单处理系统"""
    
    def __init__(self, max_queue_size: int = 1000):
        self.pending_orders = PriorityQueue()
        self.processing_orders = set()
        self.completed_orders = []
        self.failed_orders = []
        self.order_history = {}  # 订单历史记录
        
        # 处理器
        self.inventory_handler = InventoryHandler()
        self.payment_handler = PaymentHandler()
        self.shipping_handler = ShippingHandler()
    
    def submit_order(self, order: Order):
        """提交订单"""
        # 检查库存
        if not self.inventory_handler.check_availability(order.items):
            order.status = OrderStatus.CANCELLED
            order.failure_reason = "Insufficient inventory"
            self.failed_orders.append(order)
            return False
        
        # 根据订单金额确定优先级
        priority = self._calculate_priority(order)
        self.pending_orders.put(order, priority)
        
        self.order_history[order.order_id] = order
        return True
    
    def _calculate_priority(self, order: Order) -> int:
        """计算订单优先级"""
        base_priority = 1
        
        # 订单金额影响优先级
        if order.total > 1000:
            base_priority += 2
        elif order.total > 500:
            base_priority += 1
        
        # VIP客户优先级更高
        if self._is_vip_customer(order.customer_id):
            base_priority += 3
        
        return -base_priority  # 负数，因为heapq是最小堆
    
    def _is_vip_customer(self, customer_id: str) -> bool:
        """检查是否为VIP客户"""
        # 模拟VIP客户检查
        return customer_id.startswith('VIP')
    
    async def process_orders(self):
        """处理订单（主循环）"""
        while True:
            if not self.pending_orders.is_empty():
                order = self.pending_orders.get()
                await self._process_single_order(order)
            
            await asyncio.sleep(0.1)  # 避免忙等待
    
    async def _process_single_order(self, order: Order):
        """处理单个订单"""
        try:
            order.status = OrderStatus.PROCESSING
            self.processing_orders.add(order)
            
            # 步骤1：验证支付
            if not await self.payment_handler.verify_payment(order):
                raise Exception("Payment verification failed")
            
            # 步骤2：扣减库存
            if not await self.inventory_handler.reserve_items(order.items):
                raise Exception("Failed to reserve inventory")
            
            # 步骤3：安排发货
            shipping_info = await self.shipping_handler.schedule_shipping(order)
            
            # 订单处理完成
            order.status = OrderStatus.COMPLETED
            order.processed_at = datetime.now()
            order.shipping_info = shipping_info
            
            self.completed_orders.append(order)
            self.processing_orders.remove(order)
            
            print(f"Order {order.order_id} completed successfully")
            
        except Exception as e:
            order.status = OrderStatus.FAILED
            order.failure_reason = str(e)
            order.processed_at = datetime.now()
            
            self.failed_orders.append(order)
            self.processing_orders.remove(order)
            
            print(f"Order {order.order_id} failed: {e}")
    
    def get_processing_stats(self) -> dict:
        """获取处理统计"""
        return {
            'pending': self.pending_orders.size(),
            'processing': len(self.processing_orders),
            'completed_today': len([o for o in self.completed_orders 
                                  if o.processed_at.date() == datetime.now().date()]),
            'failed_today': len([o for o in self.failed_orders 
                               if o.processed_at.date() == datetime.now().date()]),
        }

class PriorityQueue:
    """优先级队列实现"""
    
    def __init__(self):
        self._queue = []
        self._entry_finder = {}
        self._counter = itertools.count()
        self.lock = asyncio.Lock()
    
    def put(self, item, priority):
        """添加项目"""
        if item in self._entry_finder:
            self.remove(item)
        
        priority = int(priority)
        count = next(self._counter)
        entry = [priority, count, item]
        self._entry_finder[item] = entry
        heapq.heappush(self._queue, entry)
    
    def remove(self, item):
        """移除项目"""
        entry = self._entry_finder.pop(item, None)
        if entry:
            entry[-1] = None
    
    def get(self):
        """获取项目"""
        while self._queue:
            priority, count, item = heapq.heappop(self._queue)
            if item is not None:
                del self._entry_finder[item]
                return item
        raise KeyError('pop from an empty priority queue')
    
    def is_empty(self) -> bool:
        """检查是否为空"""
        return len(self._entry_finder) == 0
    
    def size(self) -> int:
        """获取大小"""
        return len(self._entry_finder)

# 处理器类（简化实现）
class InventoryHandler:
    async def check_availability(self, items: list) -> bool:
        # 模拟库存检查
        await asyncio.sleep(0.01)
        return True
    
    async def reserve_items(self, items: list) -> bool:
        # 模拟库存预留
        await asyncio.sleep(0.02)
        return True

class PaymentHandler:
    async def verify_payment(self, order: Order) -> bool:
        # 模拟支付验证
        await asyncio.sleep(0.03)
        return True

class ShippingHandler:
    async def schedule_shipping(self, order: Order) -> dict:
        # 模拟发货安排
        await asyncio.sleep(0.01)
        return {"tracking_number": f"TRACK_{order.order_id}", "estimated_days": 3}

# 使用示例
async def demo_order_processing():
    """演示订单处理系统"""
    system = OrderProcessingSystem()
    
    # 创建测试订单
    test_orders = [
        Order("ORDER_001", "CUST_001", ["Item1", "Item2"], 299.99),
        Order("ORDER_002", "VIP_CUST_001", ["Item3"], 1299.99),
        Order("ORDER_003", "CUST_002", ["Item4", "Item5", "Item6"], 89.99),
        Order("ORDER_004", "VIP_CUST_002", ["Item7"], 1999.99),
    ]
    
    # 提交订单
    for order in test_orders:
        success = system.submit_order(order)
        print(f"Order {order.order_id} submitted: {success}")
    
    # 启动处理
    processing_task = asyncio.create_task(system.process_orders())
    
    # 等待处理完成
    await asyncio.sleep(2)
    
    # 获取统计信息
    stats = system.get_processing_stats()
    print("\nProcessing Statistics:")
    for key, value in stats.items():
        print(f"  {key}: {value}")

# asyncio.run(demo_order_processing())
```

## 最佳实践

### 1. 性能优化建议

1. **内存管理**
   - 使用内存池减少内存分配开销
   - 合理设置队列大小，避免内存浪费
   - 及时清理过期数据

2. **并发控制**
   - 使用线程安全的队列实现
   - 合理设置超时时间，避免死锁
   - 考虑背压机制防止系统过载

3. **监控和调试**
   - 添加队列长度监控
   - 记录处理时间统计
   - 实现优雅的降级机制

### 2. 常见陷阱

1. **队列满载处理**
   - 不要盲目阻塞，设置合理的超时时间
   - 考虑丢弃策略或降级处理

2. **内存泄漏**
   - 及时清理不需要的对象引用
   - 使用弱引用避免循环引用

3. **性能瓶颈**
   - 避免在锁内进行耗时操作
   - 考虑使用无锁数据结构

## 总结

队列和栈作为基础数据结构，在系统架构中发挥着重要作用：

- **队列**适用于任务调度、消息传递、流量控制等场景
- **栈**适用于状态管理、表达式求值、回溯操作等场景
- **双端队列**结合了两种特性，适用于更复杂的调度场景

通过合理选择和使用这些数据结构，可以构建高效、可靠的系统架构。在实际应用中，需要根据具体场景选择合适的实现方式和优化策略。